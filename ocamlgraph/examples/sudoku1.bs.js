// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Array from "../../node_modules/rescript/lib/es6/array.js";
import * as Curry from "../../node_modules/rescript/lib/es6/curry.js";
import * as Format from "../../node_modules/rescript/lib/es6/format.js";
import * as Coloring from "../src/coloring.bs.js";
import * as Caml_array from "../../node_modules/rescript/lib/es6/caml_array.js";
import * as Imperative from "../src/imperative.bs.js";
import * as Pervasives from "../../node_modules/rescript/lib/es6/pervasives.js";
import * as Caml_string from "../../node_modules/rescript/lib/es6/caml_string.js";

var G = Imperative.Graph.Abstract({});

var g = Curry._2(G.create, undefined, undefined);

var nodes = $$Array.init(9, (function (i) {
        return $$Array.init(9, (function (param) {
                      var v = Curry._1(G.V.create, [
                            i,
                            param
                          ]);
                      Curry._2(G.add_vertex, g, v);
                      return v;
                    }));
      }));

function node(i, j) {
  return Caml_array.get(Caml_array.get(nodes, i), j);
}

for(var i = 0; i <= 8; ++i){
  for(var j = 0; j <= 8; ++j){
    for(var k = 0; k <= 8; ++k){
      if (k !== i) {
        Curry._3(G.add_edge, g, node(i, j), node(k, j));
      }
      if (k !== j) {
        Curry._3(G.add_edge, g, node(i, j), node(i, k));
      }
      
    }
    var gi = Math.imul(3, i / 3 | 0);
    var gj = Math.imul(3, j / 3 | 0);
    for(var di = 0; di <= 2; ++di){
      for(var dj = 0; dj <= 2; ++dj){
        var i$p = gi + di | 0;
        var j$p = gj + dj | 0;
        if (i$p !== i || j$p !== j) {
          Curry._3(G.add_edge, g, node(i, j), node(i$p, j$p));
        }
        
      }
    }
  }
}

function display(param) {
  for(var i = 0; i <= 8; ++i){
    for(var j = 0; j <= 8; ++j){
      Curry._1(Format.printf(/* Format */{
                _0: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: /* End_of_format */0
                },
                _1: "%d"
              }), Curry._1(G.Mark.get, node(i, j)));
    }
    Format.printf(/* Format */{
          _0: {
            TAG: /* Char_literal */12,
            _0: /* '\n' */10,
            _1: /* End_of_format */0
          },
          _1: "\n"
        });
  }
  return Format.printf(/* Format */{
              _0: {
                TAG: /* Formatting_lit */17,
                _0: /* FFlush */2,
                _1: /* End_of_format */0
              },
              _1: "@?"
            });
}

for(var i$1 = 0; i$1 <= 8; ++i$1){
  var s = Pervasives.read_line(undefined);
  for(var j$1 = 0; j$1 <= 8; ++j$1){
    var ch = Caml_string.get(s, j$1);
    if (ch > 57 || ch < 49) {
      
    } else {
      Curry._2(G.Mark.set, node(i$1, j$1), ch - /* '0' */48 | 0);
    }
  }
}

display(undefined);

Format.printf(/* Format */{
      _0: {
        TAG: /* String_literal */11,
        _0: "---------",
        _1: {
          TAG: /* Formatting_lit */17,
          _0: /* Flush_newline */4,
          _1: /* End_of_format */0
        }
      },
      _1: "---------@."
    });

var $$let = G.Mark;

var C = Coloring.Mark({
      is_directed: G.is_directed,
      nb_vertex: G.nb_vertex,
      V: G.V,
      out_degree: G.out_degree,
      iter_vertex: G.iter_vertex,
      fold_vertex: G.fold_vertex,
      iter_succ: G.iter_succ,
      fold_succ: G.fold_succ,
      Mark: {
        get: $$let.get,
        set: $$let.set
      }
    });

Curry._2(C.coloring, g, 9);

display(undefined);

export {
  G ,
  g ,
  nodes ,
  node ,
  display ,
  C ,
  
}
/* G Not a pure module */
