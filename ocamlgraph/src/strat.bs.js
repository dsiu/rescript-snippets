// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Set = require("rescript/lib/js/set.js");
var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function Algo(G, P, S) {
  var SetV = $$Set.Make(G.V);
  var eq = function (_l1, _l2) {
    while(true) {
      var l2 = _l2;
      var l1 = _l1;
      if (!l1) {
        if (l2) {
          return false;
        } else {
          return true;
        }
      }
      if (!l2) {
        return false;
      }
      if (!Caml_obj.caml_equal(l1.hd, l2.hd)) {
        return false;
      }
      _l2 = l2.tl;
      _l1 = l1.tl;
      continue ;
    };
  };
  var eq_mem = function (i, _l1, _l2) {
    while(true) {
      var l2 = _l2;
      var l1 = _l1;
      if (!l1) {
        if (l2) {
          return [
                  false,
                  false
                ];
        } else {
          return [
                  true,
                  false
                ];
        }
      }
      if (!l2) {
        return [
                false,
                false
              ];
      }
      var e1 = l1.hd;
      if (!Caml_obj.caml_equal(e1, l2.hd)) {
        return [
                false,
                false
              ];
      }
      var l2$p = l2.tl;
      var l1$p = l1.tl;
      if (Caml_obj.caml_equal(e1, i)) {
        return [
                eq(l1$p, l2$p),
                true
              ];
      }
      _l2 = l2$p;
      _l1 = l1$p;
      continue ;
    };
  };
  var puit = function (g, v) {
    var match = Curry._2(G.succ, g, v);
    if (match) {
      return false;
    } else {
      return true;
    }
  };
  var get_finals = function (g, p) {
    var f = function (a, l) {
      if (Curry._2(P.is_final, p, a)) {
        return {
                hd: a,
                tl: l
              };
      } else {
        return l;
      }
    };
    return Curry._3(G.fold_vertex, f, g, /* [] */0);
  };
  var coherent_player = function (g, p) {
    return Curry._2(G.mem_vertex, g, Curry._1(P.get_initial, p));
  };
  var coherent_strat = function (g, s) {
    var f = function (v, b) {
      try {
        var v$p = Curry._2(S.next, s, v);
        if (b) {
          return Curry._2(G.mem_vertex, g, v$p);
        } else {
          return false;
        }
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Invalid_argument") {
          return true;
        }
        throw exn;
      }
    };
    return Curry._3(G.fold_vertex, f, g, true);
  };
  var game = function (param, p, a, b) {
    var game_aux = function (l, pi) {
      var $$continue = function (x) {
        try {
          return game_aux(Curry._2(SetV.add, pi, l), Curry._2(S.next, x, pi));
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Invalid_argument") {
            return false;
          }
          throw exn;
        }
      };
      if (Curry._2(P.is_final, p, pi)) {
        return true;
      } else if (Curry._2(SetV.mem, pi, l)) {
        return false;
      } else if (Curry._2(P.turn, p, pi)) {
        return $$continue(a);
      } else {
        return $$continue(b);
      }
    };
    return game_aux(SetV.empty, Curry._1(P.get_initial, p));
  };
  var attract1 = function (g, p, s, l) {
    var f = function (v, l1) {
      if (List.mem(v, l1)) {
        return l1;
      }
      if (!Curry._2(P.turn, p, v)) {
        if (puit(g, v) || !Curry._4(G.fold_succ, (function (v$p, b) {
                  return b ? List.mem(v$p, l1) : false;
                }), g, v, true)) {
          return l1;
        } else {
          return {
                  hd: v,
                  tl: l1
                };
        }
      }
      try {
        if (List.mem(Curry._2(S.next, s, v), l1)) {
          return {
                  hd: v,
                  tl: l1
                };
        } else {
          return l1;
        }
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Invalid_argument") {
          return l1;
        }
        throw exn;
      }
    };
    return Curry._3(G.fold_vertex, f, g, l);
  };
  var strategy = function (g, p, s) {
    var finaux = get_finals(g, p);
    var _l1 = attract1(g, p, s, finaux);
    var _l2 = finaux;
    while(true) {
      var l2 = _l2;
      var l1 = _l1;
      var match = eq_mem(Curry._1(P.get_initial, p), l1, l2);
      if (match[0]) {
        return match[1];
      }
      _l2 = l1;
      _l1 = attract1(g, p, s, l1);
      continue ;
    };
  };
  var attract = function (g, p, param) {
    var f = function (v, param) {
      var l1$p = param[1];
      var l1 = param[0];
      if (List.mem(v, l1)) {
        return [
                l1,
                l1$p
              ];
      }
      if (!Curry._2(P.turn, p, v)) {
        if (puit(g, v) || !Curry._4(G.fold_succ, (function (v$p, b) {
                  return b ? List.mem(v$p, l1) : false;
                }), g, v, true)) {
          return [
                  l1,
                  l1$p
                ];
        } else {
          return [
                  {
                    hd: v,
                    tl: l1
                  },
                  l1$p
                ];
        }
      }
      var f$p = function (v$p, l2) {
        if (l2) {
          return l2;
        } else if (List.mem(v$p, l1)) {
          return {
                  hd: v$p,
                  tl: /* [] */0
                };
        } else {
          return /* [] */0;
        }
      };
      var match = Curry._4(G.fold_succ, f$p, g, v, /* [] */0);
      if (match) {
        return [
                {
                  hd: v,
                  tl: l1
                },
                Curry._3(S.add, l1$p, v, match.hd)
              ];
      } else {
        return [
                l1,
                l1$p
              ];
      }
    };
    return Curry._3(G.fold_vertex, f, g, [
                param[0],
                param[1]
              ]);
  };
  var strategyA = function (g, p) {
    var finaux = get_finals(g, p);
    var match = attract(g, p, [
          finaux,
          S.empty
        ]);
    var _l1 = match[0];
    var _l2 = finaux;
    var _f = match[1];
    while(true) {
      var f = _f;
      var l2 = _l2;
      var l1 = _l1;
      var match$1 = eq_mem(Curry._1(P.get_initial, p), l1, l2);
      if (match$1[0]) {
        return [
                match$1[1],
                f
              ];
      }
      var match$2 = attract(g, p, [
            l1,
            f
          ]);
      _f = match$2[1];
      _l2 = l1;
      _l1 = match$2[0];
      continue ;
    };
  };
  return {
          coherent_player: coherent_player,
          coherent_strat: coherent_strat,
          game: game,
          strategy: strategy,
          strategyA: strategyA
        };
}

exports.Algo = Algo;
/* No side effect */
