// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Bitv = require("./lib/bitv.bs.js");
var Caml = require("rescript/lib/js/caml.js");
var $$Array = require("rescript/lib/js/array.js");
var Curry = require("rescript/lib/js/curry.js");
var Blocks = require("./blocks.bs.js");
var Hashtbl = require("rescript/lib/js/hashtbl.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var I = Blocks.Make(function (funarg) {
      var $$let = Blocks.Make_Hashtbl(funarg);
      return {
              create: $$let.create,
              create_from: $$let.create_from,
              empty: $$let.empty,
              clear: $$let.clear,
              is_empty: $$let.is_empty,
              add: $$let.add,
              remove: $$let.remove,
              mem: $$let.mem,
              find: $$let.find,
              find_and_raise: $$let.find_and_raise,
              iter: $$let.iter,
              map: $$let.map,
              fold: $$let.fold,
              copy: $$let.copy
            };
    });

var compare = Caml.caml_int_compare;

function equal(prim0, prim1) {
  return prim0 === prim1;
}

function create(i) {
  return i;
}

function label(i) {
  return i;
}

var V = {
  compare: compare,
  hash: Hashtbl.hash,
  equal: equal,
  create: create,
  label: label
};

var compare$1 = Caml_obj.caml_compare;

function create$1(v1, param, v2) {
  return [
          v1,
          v2
        ];
}

function src(prim) {
  return prim[0];
}

function dst(prim) {
  return prim[1];
}

function label$1(param) {
  
}

function create$2(param, param$1) {
  return Pervasives.failwith("[ocamlgraph] do not use Matrix.create; please use Matrix.make instead");
}

function make(n) {
  if (n < 0) {
    Pervasives.invalid_arg("[ocamlgraph] Matrix.make");
  }
  return $$Array.init(n, (function (param) {
                return Bitv.create(n, false);
              }));
}

function nb_vertex(prim) {
  return prim.length;
}

function is_empty(g) {
  return g.length === 0;
}

function nb_edges(param) {
  return $$Array.fold_left((function (param, param$1) {
                return Bitv.fold_left((function (n, b) {
                              if (b) {
                                return n + 1 | 0;
                              } else {
                                return n;
                              }
                            }), param, param$1);
              }), 0, param);
}

function mem_vertex(g, v) {
  if (0 <= v) {
    return v < g.length;
  } else {
    return false;
  }
}

function mem_edge(g, i, j) {
  return Bitv.get(Caml_array.get(g, i), j);
}

function mem_edge_e(g, param) {
  return Bitv.get(Caml_array.get(g, param[0]), param[1]);
}

function find_edge(g, i, j) {
  if (mem_edge(g, i, j)) {
    return [
            i,
            j
          ];
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function find_all_edges(g, i, j) {
  try {
    return {
            hd: find_edge(g, i, j),
            tl: /* [] */0
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return /* [] */0;
    }
    throw exn;
  }
}

function add_edge(g, i, j) {
  return Bitv.set(Caml_array.get(g, i), j, true);
}

function add_edge_e(g, param) {
  return Bitv.set(Caml_array.get(g, param[0]), param[1], true);
}

function remove_edge(g, i, j) {
  return Bitv.set(Caml_array.get(g, i), j, false);
}

function remove_edge_e(g, param) {
  return Bitv.set(Caml_array.get(g, param[0]), param[1], false);
}

function unsafe_add_edge(g, i, j) {
  return Bitv.unsafe_set(g[i], j, true);
}

function unsafe_remove_edge(g, i, j) {
  return Bitv.unsafe_set(g[i], j, false);
}

function remove_vertex(param, param$1) {
  
}

function add_vertex(param, param$1) {
  
}

function clear(g) {
  return $$Array.iter((function (b) {
                return Bitv.iteri((function (j, param) {
                              return Bitv.set(b, j, false);
                            }), b);
              }), g);
}

function copy(g) {
  return $$Array.init(g.length, (function (i) {
                return Bitv.copy(Caml_array.get(g, i));
              }));
}

function iter_vertex(f, g) {
  for(var i = 0 ,i_finish = g.length; i < i_finish; ++i){
    Curry._1(f, i);
  }
  
}

function iter_edges(f, g) {
  for(var i = 0 ,i_finish = g.length; i < i_finish; ++i){
    Bitv.iteri((function(i){
        return function (j, b) {
          if (b) {
            return Curry._2(f, i, j);
          }
          
        }
        }(i)), Caml_array.get(g, i));
  }
  
}

function fold_vertex(f, g, a) {
  var n = g.length;
  var _i = 0;
  var _a = a;
  while(true) {
    var a$1 = _a;
    var i = _i;
    if (i === n) {
      return a$1;
    }
    _a = Curry._2(f, i, a$1);
    _i = i + 1 | 0;
    continue ;
  };
}

function fold_edges(f, g, a) {
  return fold_vertex((function (i, a) {
                return Bitv.foldi_right((function (j, b, a) {
                              if (b) {
                                return Curry._3(f, i, j, a);
                              } else {
                                return a;
                              }
                            }), Caml_array.get(g, i), a);
              }), g, a);
}

function succ(g, i) {
  return Bitv.foldi_left((function (l, j, b) {
                if (b) {
                  return {
                          hd: j,
                          tl: l
                        };
                } else {
                  return l;
                }
              }), /* [] */0, Caml_array.get(g, i));
}

function pred(g, i) {
  return fold_vertex((function (j, a) {
                if (Bitv.unsafe_get(Caml_array.get(g, j), i)) {
                  return {
                          hd: j,
                          tl: a
                        };
                } else {
                  return a;
                }
              }), g, /* [] */0);
}

function iter_succ(f, g, i) {
  var si = Caml_array.get(g, i);
  for(var j = 0 ,j_finish = g.length; j < j_finish; ++j){
    if (Bitv.unsafe_get(si, j)) {
      Curry._1(f, j);
    }
    
  }
  
}

function iter_pred(f, g, i) {
  for(var j = 0 ,j_finish = g.length; j < j_finish; ++j){
    if (Bitv.unsafe_get(Caml_array.get(g, j), i)) {
      Curry._1(f, j);
    }
    
  }
  
}

function fold_succ(f, g, i, a) {
  return Bitv.foldi_right((function (j, b, a) {
                if (b) {
                  return Curry._2(f, j, a);
                } else {
                  return a;
                }
              }), Caml_array.get(g, i), a);
}

function fold_pred(f, g, i, a) {
  return fold_vertex((function (j, a) {
                if (Bitv.unsafe_get(Caml_array.get(g, j), i)) {
                  return Curry._2(f, j, a);
                } else {
                  return a;
                }
              }), g, a);
}

function out_degree(g, i) {
  return fold_succ((function (param, n) {
                return n + 1 | 0;
              }), g, i, 0);
}

function in_degree(g, i) {
  return fold_pred((function (param, n) {
                return n + 1 | 0;
              }), g, i, 0);
}

function map_vertex(f, g) {
  var n = g.length;
  var g$p = make(n);
  iter_edges((function (i, j) {
          var fi = Curry._1(f, i);
          var fj = Curry._1(f, j);
          if (fi < 0 || fi >= n || fj < 0 || fj >= n) {
            Pervasives.invalid_arg("[ocamlgraph] map_vertex");
          }
          return Bitv.unsafe_set(Caml_array.get(g$p, fi), fj, true);
        }), g);
  return g$p;
}

function succ_e(g, i) {
  return Bitv.foldi_left((function (l, j, b) {
                if (b) {
                  return {
                          hd: [
                            i,
                            j
                          ],
                          tl: l
                        };
                } else {
                  return l;
                }
              }), /* [] */0, Caml_array.get(g, i));
}

function pred_e(g, i) {
  return fold_vertex((function (j, a) {
                if (Bitv.unsafe_get(Caml_array.get(g, j), i)) {
                  return {
                          hd: [
                            j,
                            i
                          ],
                          tl: a
                        };
                } else {
                  return a;
                }
              }), g, /* [] */0);
}

function iter_edges_e(f, g) {
  for(var i = 0 ,i_finish = g.length; i < i_finish; ++i){
    Bitv.iteri((function(i){
        return function (j, b) {
          if (b) {
            return Curry._1(f, [
                        i,
                        j
                      ]);
          }
          
        }
        }(i)), Caml_array.get(g, i));
  }
  
}

function fold_edges_e(f, g, a) {
  return fold_vertex((function (i, a) {
                return Bitv.foldi_right((function (j, b, a) {
                              if (b) {
                                return Curry._2(f, [
                                            i,
                                            j
                                          ], a);
                              } else {
                                return a;
                              }
                            }), Caml_array.get(g, i), a);
              }), g, a);
}

function iter_succ_e(f, g, i) {
  var si = Caml_array.get(g, i);
  for(var j = 0 ,j_finish = g.length; j < j_finish; ++j){
    if (Bitv.unsafe_get(si, j)) {
      Curry._1(f, [
            i,
            j
          ]);
    }
    
  }
  
}

function iter_pred_e(f, g, i) {
  for(var j = 0 ,j_finish = g.length; j < j_finish; ++j){
    if (Bitv.unsafe_get(Caml_array.get(g, j), i)) {
      Curry._1(f, [
            j,
            i
          ]);
    }
    
  }
  
}

function fold_succ_e(f, g, i, a) {
  return Bitv.foldi_right((function (j, b, a) {
                if (b) {
                  return Curry._2(f, [
                              i,
                              j
                            ], a);
                } else {
                  return a;
                }
              }), Caml_array.get(g, i), a);
}

function fold_pred_e(f, g, i, a) {
  return fold_vertex((function (j, a) {
                if (Bitv.unsafe_get(Caml_array.get(g, j), i)) {
                  return Curry._2(f, [
                              j,
                              i
                            ], a);
                } else {
                  return a;
                }
              }), g, a);
}

var include = Blocks.Graph({
      V: V,
      E: {
        compare: compare$1,
        src: src,
        dst: dst,
        create: create$1,
        label: label$1
      },
      is_directed: true,
      is_empty: is_empty,
      nb_vertex: nb_vertex,
      nb_edges: nb_edges,
      out_degree: out_degree,
      in_degree: in_degree,
      mem_vertex: mem_vertex,
      mem_edge: mem_edge,
      mem_edge_e: mem_edge_e,
      find_edge: find_edge,
      find_all_edges: find_all_edges,
      succ: succ,
      pred: pred,
      succ_e: succ_e,
      pred_e: pred_e,
      iter_vertex: iter_vertex,
      fold_vertex: fold_vertex,
      iter_edges: iter_edges,
      fold_edges: fold_edges,
      iter_edges_e: iter_edges_e,
      fold_edges_e: fold_edges_e,
      map_vertex: map_vertex,
      iter_succ: iter_succ,
      iter_pred: iter_pred,
      fold_succ: fold_succ,
      fold_pred: fold_pred,
      iter_succ_e: iter_succ_e,
      fold_succ_e: fold_succ_e,
      iter_pred_e: iter_pred_e,
      fold_pred_e: fold_pred_e,
      create: create$2,
      clear: clear,
      copy: copy,
      add_vertex: add_vertex,
      remove_vertex: remove_vertex
    });

function add_edge$1(g, v1, v2) {
  add_edge(g, v1, v2);
  unsafe_add_edge(g, v2, v1);
  
}

function add_edge_e$1(g, param) {
  return add_edge$1(g, param[0], param[1]);
}

function remove_edge$1(g, v1, v2) {
  remove_edge(g, v1, v2);
  unsafe_remove_edge(g, v2, v1);
  
}

function remove_edge_e$1(g, param) {
  return remove_edge$1(g, param[0], param[1]);
}

function Digraph_Concrete(funarg) {
  var include = Curry._1(I.Digraph.Concrete, funarg);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var E = include.E;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var add_vertex = include.add_vertex;
  var add_edge = include.add_edge;
  var add_edge_e = include.add_edge_e;
  var add_vertex$1 = function (g, v) {
    Curry._2(add_vertex, g, v);
    
  };
  var add_edge$1 = function (g, v1, v2) {
    Curry._3(add_edge, g, v1, v2);
    
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  var add_edge_e$1 = function (g, e) {
    Curry._2(add_edge_e, g, e);
    
  };
  var remove_vertex = function (g, v) {
    if (Curry._2(HM.mem, v, g)) {
      Curry._2(HM.remove, v, g);
      return Curry._2(HM.iter, (function (k, s) {
                    Curry._3(HM.add, k, Curry._2(S.remove, v, s), g);
                    
                  }), g);
    }
    
  };
  return {
          V: {
            compare: V.compare,
            hash: V.hash,
            equal: V.equal,
            create: V.create,
            label: V.label
          },
          E: {
            compare: E.compare,
            src: E.src,
            dst: E.dst,
            create: E.create,
            label: E.label
          },
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          create: include.create,
          clear: include.clear,
          copy: include.copy,
          add_vertex: add_vertex$1,
          remove_vertex: remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e$1,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1
        };
}

function Digraph_Abstract(funarg) {
  var compare = function (x, y) {
    return Caml.caml_int_compare(x.tag, y.tag);
  };
  var hash = function (x) {
    return x.tag;
  };
  var equal = function (x, y) {
    return x.tag === y.tag;
  };
  var label = function (x) {
    return x.label;
  };
  var create = function (l) {
    if (Blocks.cpt_vertex.contents === (Blocks.first_value_for_cpt_vertex - 1 | 0)) {
      Pervasives.invalid_arg("Too much vertices");
    }
    Blocks.cpt_vertex.contents = Blocks.cpt_vertex.contents + 1 | 0;
    return {
            tag: Blocks.cpt_vertex.contents,
            label: l,
            mark: 0
          };
  };
  var include = Curry._1(I.Digraph.Abstract, {
        compare: compare,
        hash: hash,
        equal: equal,
        create: create,
        label: label
      });
  var G = include.G;
  var HM = include.HM;
  var S = include.S;
  var unsafe_add_edge = include.unsafe_add_edge;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var iter_vertex = include.iter_vertex;
  var add_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      g.size = g.size + 1 | 0;
      Curry._2(G.unsafe_add_vertex, g.edges, v);
      return ;
    }
    
  };
  var add_edge = function (g, v1, v2) {
    add_vertex(g, v1);
    add_vertex(g, v2);
    Curry._3(unsafe_add_edge, g.edges, v1, v2);
    
  };
  var add_edge_e = function (g, param) {
    return add_edge(g, param[0], param[1]);
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      return ;
    }
    var e = g.edges;
    Curry._2(HM.remove, v, e);
    Curry._2(HM.iter, (function (k, s) {
            Curry._3(HM.add, k, Curry._2(S.remove, v, s), e);
            
          }), e);
    g.size = g.size - 1 | 0;
    
  };
  var get = function (v) {
    return v.mark;
  };
  var set = function (v, m) {
    v.mark = m;
    
  };
  var clear = function (g) {
    return Curry._2(iter_vertex, (function (v) {
                  v.mark = 0;
                  
                }), g);
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  return {
          V: include.V,
          E: include.E,
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          create: include.create,
          clear: include.clear,
          copy: include.copy,
          add_vertex: add_vertex,
          remove_vertex: remove_vertex,
          add_edge: add_edge,
          add_edge_e: add_edge_e,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1,
          Mark: {
            clear: clear,
            get: get,
            set: set
          }
        };
}

function Digraph_ConcreteLabeled(funarg, funarg$1) {
  var include = Curry._2(I.Digraph.ConcreteLabeled, funarg, funarg$1);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var E = include.E;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var add_vertex = include.add_vertex;
  var add_edge_e = include.add_edge_e;
  var add_edge = include.add_edge;
  var add_vertex$1 = function (g, v) {
    Curry._2(add_vertex, g, v);
    
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  var add_edge_e$1 = function (g, e) {
    Curry._2(add_edge_e, g, e);
    
  };
  var add_edge$1 = function (g, v1, v2) {
    Curry._3(add_edge, g, v1, v2);
    
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g)) {
      return ;
    }
    Curry._2(HM.remove, v, g);
    var remove = function (v) {
      return Curry._1(S.filter, (function (param) {
                    return !Curry._2(V.equal, v, param[0]);
                  }));
    };
    return Curry._2(HM.iter, (function (k, s) {
                  Curry._3(HM.add, k, Curry._1(remove(v), s), g);
                  
                }), g);
  };
  return {
          V: {
            compare: V.compare,
            hash: V.hash,
            equal: V.equal,
            create: V.create,
            label: V.label
          },
          E: {
            compare: E.compare,
            src: E.src,
            dst: E.dst,
            create: E.create,
            label: E.label
          },
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          create: include.create,
          clear: include.clear,
          copy: include.copy,
          add_vertex: add_vertex$1,
          remove_vertex: remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e$1,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1
        };
}

function Digraph_AbstractLabeled(funarg, funarg$1) {
  var compare = function (x, y) {
    return Caml.caml_int_compare(x.tag, y.tag);
  };
  var hash = function (x) {
    return x.tag;
  };
  var equal = function (x, y) {
    return x.tag === y.tag;
  };
  var label = function (x) {
    return x.label;
  };
  var create = function (l) {
    if (Blocks.cpt_vertex.contents === (Blocks.first_value_for_cpt_vertex - 1 | 0)) {
      Pervasives.invalid_arg("Too much vertices");
    }
    Blocks.cpt_vertex.contents = Blocks.cpt_vertex.contents + 1 | 0;
    return {
            tag: Blocks.cpt_vertex.contents,
            label: l,
            mark: 0
          };
  };
  var include = Curry._2(I.Digraph.AbstractLabeled, {
        compare: compare,
        hash: hash,
        equal: equal,
        create: create,
        label: label
      }, funarg$1);
  var G = include.G;
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var unsafe_add_edge = include.unsafe_add_edge;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var iter_vertex = include.iter_vertex;
  var add_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      g.size = g.size + 1 | 0;
      Curry._2(G.unsafe_add_vertex, g.edges, v);
      return ;
    }
    
  };
  var add_edge_e = function (g, param) {
    var v2 = param[2];
    var v1 = param[0];
    add_vertex(g, v1);
    add_vertex(g, v2);
    Curry._3(unsafe_add_edge, g.edges, v1, [
          v2,
          param[1]
        ]);
    
  };
  var add_edge = function (g, v1, v2) {
    return add_edge_e(g, [
                v1,
                funarg$1.$$default,
                v2
              ]);
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      return ;
    }
    var remove = function (s) {
      return Curry._3(S.fold, (function (e, s) {
                    if (Curry._2(V.equal, v, e[0])) {
                      return s;
                    } else {
                      return Curry._2(S.add, e, s);
                    }
                  }), s, S.empty);
    };
    var e = g.edges;
    Curry._2(HM.remove, v, e);
    Curry._2(HM.iter, (function (k, s) {
            Curry._3(HM.add, k, remove(s), e);
            
          }), e);
    g.size = g.size - 1 | 0;
    
  };
  var get = function (v) {
    return v.mark;
  };
  var set = function (v, m) {
    v.mark = m;
    
  };
  var clear = function (g) {
    return Curry._2(iter_vertex, (function (v) {
                  v.mark = 0;
                  
                }), g);
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  return {
          V: V,
          E: include.E,
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          create: include.create,
          clear: include.clear,
          copy: include.copy,
          add_vertex: add_vertex,
          remove_vertex: remove_vertex,
          add_edge: add_edge,
          add_edge_e: add_edge_e,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1,
          Mark: {
            clear: clear,
            get: get,
            set: set
          }
        };
}

function Digraph_ConcreteBidirectional(funarg) {
  var include = Curry._1(I.Digraph.ConcreteBidirectional, funarg);
  var V = include.V;
  var HM = include.HM;
  var E = include.E;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var iter_succ_e = include.iter_succ_e;
  var iter_pred_e = include.iter_pred_e;
  var add_vertex = include.add_vertex;
  var add_edge = include.add_edge;
  var add_vertex$1 = function (g, v) {
    Curry._2(add_vertex, g, v);
    
  };
  var add_edge$1 = function (g, v1, v2) {
    Curry._3(add_edge, g, v1, v2);
    
  };
  var add_edge_e = function (g, param) {
    return add_edge$1(g, param[0], param[1]);
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  var remove_vertex = function (g, v) {
    if (Curry._2(HM.mem, v, g)) {
      Curry._3(iter_pred_e, (function (e) {
              Curry._2(remove_edge_e, g, e);
              
            }), g, v);
      Curry._3(iter_succ_e, (function (e) {
              Curry._2(remove_edge_e, g, e);
              
            }), g, v);
      Curry._2(HM.remove, v, g);
      return ;
    }
    
  };
  return {
          V: {
            compare: V.compare,
            hash: V.hash,
            equal: V.equal,
            create: V.create,
            label: V.label
          },
          E: {
            compare: E.compare,
            src: E.src,
            dst: E.dst,
            create: E.create,
            label: E.label
          },
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          create: include.create,
          clear: include.clear,
          copy: include.copy,
          add_vertex: add_vertex$1,
          remove_vertex: remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1
        };
}

function Digraph_ConcreteBidirectionalLabeled(funarg, funarg$1) {
  var include = Curry._2(I.Digraph.ConcreteBidirectionalLabeled, funarg, funarg$1);
  var V = include.V;
  var HM = include.HM;
  var E = include.E;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var iter_succ_e = include.iter_succ_e;
  var iter_pred_e = include.iter_pred_e;
  var add_vertex = include.add_vertex;
  var add_edge_e = include.add_edge_e;
  var add_edge = include.add_edge;
  var add_vertex$1 = function (g, v) {
    Curry._2(add_vertex, g, v);
    
  };
  var add_edge$1 = function (g, v1, v2) {
    Curry._3(add_edge, g, v1, v2);
    
  };
  var add_edge_e$1 = function (g, param) {
    Curry._2(add_edge_e, g, [
          param[0],
          param[1],
          param[2]
        ]);
    
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  var remove_vertex = function (g, v) {
    if (Curry._2(HM.mem, v, g)) {
      Curry._3(iter_pred_e, (function (e) {
              Curry._2(remove_edge_e, g, e);
              
            }), g, v);
      Curry._3(iter_succ_e, (function (e) {
              Curry._2(remove_edge_e, g, e);
              
            }), g, v);
      Curry._2(HM.remove, v, g);
      return ;
    }
    
  };
  return {
          V: {
            compare: V.compare,
            hash: V.hash,
            equal: V.equal,
            create: V.create,
            label: V.label
          },
          E: {
            compare: E.compare,
            src: E.src,
            dst: E.dst,
            create: E.create,
            label: E.label
          },
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          create: include.create,
          clear: include.clear,
          copy: include.copy,
          add_vertex: add_vertex$1,
          remove_vertex: remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e$1,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1
        };
}

var Digraph = {
  Concrete: Digraph_Concrete,
  Abstract: Digraph_Abstract,
  ConcreteLabeled: Digraph_ConcreteLabeled,
  AbstractLabeled: Digraph_AbstractLabeled,
  ConcreteBidirectional: Digraph_ConcreteBidirectional,
  ConcreteBidirectionalLabeled: Digraph_ConcreteBidirectionalLabeled
};

function Graph_Concrete(funarg) {
  var include = Curry._1(I.Digraph.Concrete, funarg);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var E = include.E;
  var unsafe_remove_edge = include.unsafe_remove_edge;
  var remove_edge = include.remove_edge;
  var unsafe_add_edge = include.unsafe_add_edge;
  var add_vertex = include.add_vertex;
  var add_edge = include.add_edge;
  var add_vertex$1 = function (g, v) {
    Curry._2(add_vertex, g, v);
    
  };
  var add_edge$1 = function (g, v1, v2) {
    Curry._3(add_edge, g, v1, v2);
    
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_vertex = function (g, v) {
    if (Curry._2(HM.mem, v, g)) {
      Curry._2(HM.remove, v, g);
      return Curry._2(HM.iter, (function (k, s) {
                    Curry._3(HM.add, k, Curry._2(S.remove, v, s), g);
                    
                  }), g);
    }
    
  };
  var include$1 = Blocks.Graph({
        V: {
          compare: V.compare,
          hash: V.hash,
          equal: V.equal,
          create: V.create,
          label: V.label
        },
        E: {
          compare: E.compare,
          src: E.src,
          dst: E.dst,
          create: E.create,
          label: E.label
        },
        is_directed: include.is_directed,
        is_empty: include.is_empty,
        nb_vertex: include.nb_vertex,
        nb_edges: include.nb_edges,
        out_degree: include.out_degree,
        in_degree: include.in_degree,
        mem_vertex: include.mem_vertex,
        mem_edge: include.mem_edge,
        mem_edge_e: include.mem_edge_e,
        find_edge: include.find_edge,
        find_all_edges: include.find_all_edges,
        succ: include.succ,
        pred: include.pred,
        succ_e: include.succ_e,
        pred_e: include.pred_e,
        iter_vertex: include.iter_vertex,
        fold_vertex: include.fold_vertex,
        iter_edges: include.iter_edges,
        fold_edges: include.fold_edges,
        iter_edges_e: include.iter_edges_e,
        fold_edges_e: include.fold_edges_e,
        map_vertex: include.map_vertex,
        iter_succ: include.iter_succ,
        iter_pred: include.iter_pred,
        fold_succ: include.fold_succ,
        fold_pred: include.fold_pred,
        iter_succ_e: include.iter_succ_e,
        fold_succ_e: include.fold_succ_e,
        iter_pred_e: include.iter_pred_e,
        fold_pred_e: include.fold_pred_e,
        create: include.create,
        clear: include.clear,
        copy: include.copy,
        add_vertex: add_vertex$1,
        remove_vertex: remove_vertex
      });
  var mem_edge = include$1.mem_edge;
  var add_edge$2 = function (g, v1, v2) {
    if (Curry._3(mem_edge, g, v1, v2)) {
      return ;
    }
    add_edge$1(g, v1, v2);
    if (!(Curry._2(HM.mem, v1, g) && Curry._2(HM.mem, v2, g))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              243,
              8
            ],
            Error: new Error()
          };
    }
    Curry._3(unsafe_add_edge, g, v2, v1);
    
  };
  var add_edge_e = function (g, param) {
    return add_edge$2(g, param[0], param[1]);
  };
  var remove_edge$2 = function (g, v1, v2) {
    remove_edge$1(g, v1, v2);
    if (!(Curry._2(HM.mem, v1, g) && Curry._2(HM.mem, v2, g))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              251,
              6
            ],
            Error: new Error()
          };
    }
    Curry._3(unsafe_remove_edge, g, v2, v1);
    
  };
  var remove_edge_e = function (g, param) {
    return remove_edge$2(g, param[0], param[1]);
  };
  return {
          V: include$1.V,
          E: include$1.E,
          is_directed: include$1.is_directed,
          is_empty: include$1.is_empty,
          nb_vertex: include$1.nb_vertex,
          nb_edges: include$1.nb_edges,
          out_degree: include$1.out_degree,
          in_degree: include$1.in_degree,
          mem_vertex: include$1.mem_vertex,
          mem_edge: mem_edge,
          mem_edge_e: include$1.mem_edge_e,
          find_edge: include$1.find_edge,
          find_all_edges: include$1.find_all_edges,
          succ: include$1.succ,
          pred: include$1.pred,
          succ_e: include$1.succ_e,
          pred_e: include$1.pred_e,
          iter_vertex: include$1.iter_vertex,
          fold_vertex: include$1.fold_vertex,
          iter_edges: include$1.iter_edges,
          fold_edges: include$1.fold_edges,
          iter_edges_e: include$1.iter_edges_e,
          fold_edges_e: include$1.fold_edges_e,
          map_vertex: include$1.map_vertex,
          iter_succ: include$1.iter_succ,
          iter_pred: include$1.iter_pred,
          fold_succ: include$1.fold_succ,
          fold_pred: include$1.fold_pred,
          iter_succ_e: include$1.iter_succ_e,
          fold_succ_e: include$1.fold_succ_e,
          iter_pred_e: include$1.iter_pred_e,
          fold_pred_e: include$1.fold_pred_e,
          create: include$1.create,
          clear: include$1.clear,
          copy: include$1.copy,
          add_vertex: include$1.add_vertex,
          remove_vertex: include$1.remove_vertex,
          add_edge: add_edge$2,
          add_edge_e: add_edge_e,
          remove_edge: remove_edge$2,
          remove_edge_e: remove_edge_e
        };
}

function Graph_Abstract(funarg) {
  var compare = function (x, y) {
    return Caml.caml_int_compare(x.tag, y.tag);
  };
  var hash = function (x) {
    return x.tag;
  };
  var equal = function (x, y) {
    return x.tag === y.tag;
  };
  var label = function (x) {
    return x.label;
  };
  var create = function (l) {
    if (Blocks.cpt_vertex.contents === (Blocks.first_value_for_cpt_vertex - 1 | 0)) {
      Pervasives.invalid_arg("Too much vertices");
    }
    Blocks.cpt_vertex.contents = Blocks.cpt_vertex.contents + 1 | 0;
    return {
            tag: Blocks.cpt_vertex.contents,
            label: l,
            mark: 0
          };
  };
  var include = Curry._1(I.Digraph.Abstract, {
        compare: compare,
        hash: hash,
        equal: equal,
        create: create,
        label: label
      });
  var G = include.G;
  var iter_edges = include.iter_edges;
  var fold_edges = include.fold_edges;
  var iter_edges_e = include.iter_edges_e;
  var fold_edges_e = include.fold_edges_e;
  var create$1 = include.create;
  var clear = include.clear;
  var iter_pred = include.iter_pred;
  var fold_pred = include.fold_pred;
  var pred = include.pred;
  var iter_pred_e = include.iter_pred_e;
  var fold_pred_e = include.fold_pred_e;
  var pred_e = include.pred_e;
  var is_empty = include.is_empty;
  var nb_vertex = include.nb_vertex;
  var V = include.V;
  var E = include.E;
  var HM = include.HM;
  var S = include.S;
  var unsafe_add_edge = include.unsafe_add_edge;
  var unsafe_remove_edge = include.unsafe_remove_edge;
  var is_directed = include.is_directed;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var out_degree = include.out_degree;
  var in_degree = include.in_degree;
  var nb_edges = include.nb_edges;
  var succ = include.succ;
  var mem_vertex = include.mem_vertex;
  var mem_edge = include.mem_edge;
  var mem_edge_e = include.mem_edge_e;
  var find_edge = include.find_edge;
  var find_all_edges = include.find_all_edges;
  var iter_vertex = include.iter_vertex;
  var fold_vertex = include.fold_vertex;
  var iter_succ = include.iter_succ;
  var fold_succ = include.fold_succ;
  var succ_e = include.succ_e;
  var iter_succ_e = include.iter_succ_e;
  var fold_succ_e = include.fold_succ_e;
  var map_vertex = include.map_vertex;
  var copy = include.copy;
  var add_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      g.size = g.size + 1 | 0;
      Curry._2(G.unsafe_add_vertex, g.edges, v);
      return ;
    }
    
  };
  var add_edge = function (g, v1, v2) {
    add_vertex(g, v1);
    add_vertex(g, v2);
    Curry._3(unsafe_add_edge, g.edges, v1, v2);
    
  };
  var add_edge_e = function (g, param) {
    return add_edge(g, param[0], param[1]);
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      return ;
    }
    var e = g.edges;
    Curry._2(HM.remove, v, e);
    Curry._2(HM.iter, (function (k, s) {
            Curry._3(HM.add, k, Curry._2(S.remove, v, s), e);
            
          }), e);
    g.size = g.size - 1 | 0;
    
  };
  var get = function (v) {
    return v.mark;
  };
  var set = function (v, m) {
    v.mark = m;
    
  };
  var clear$1 = function (g) {
    return Curry._2(iter_vertex, (function (v) {
                  v.mark = 0;
                  
                }), g);
  };
  var Mark = {
    get: get,
    set: set,
    clear: clear$1
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  var G_I = include.I;
  var G_PV = include.PV;
  var G_PE = include.PE;
  var G_unsafe_remove_edge_e = include.unsafe_remove_edge_e;
  var include$1 = Blocks.Graph({
        V: V,
        E: E,
        is_directed: is_directed,
        is_empty: is_empty,
        nb_vertex: nb_vertex,
        nb_edges: nb_edges,
        out_degree: out_degree,
        in_degree: in_degree,
        mem_vertex: mem_vertex,
        mem_edge: mem_edge,
        mem_edge_e: mem_edge_e,
        find_edge: find_edge,
        find_all_edges: find_all_edges,
        succ: succ,
        pred: pred,
        succ_e: succ_e,
        pred_e: pred_e,
        iter_vertex: iter_vertex,
        fold_vertex: fold_vertex,
        iter_edges: iter_edges,
        fold_edges: fold_edges,
        iter_edges_e: iter_edges_e,
        fold_edges_e: fold_edges_e,
        map_vertex: map_vertex,
        iter_succ: iter_succ,
        iter_pred: iter_pred,
        fold_succ: fold_succ,
        fold_pred: fold_pred,
        iter_succ_e: iter_succ_e,
        fold_succ_e: fold_succ_e,
        iter_pred_e: iter_pred_e,
        fold_pred_e: fold_pred_e,
        create: create$1,
        clear: clear,
        copy: copy,
        add_vertex: add_vertex,
        remove_vertex: remove_vertex
      });
  var add_edge$1 = function (g, v1, v2) {
    add_edge(g, v1, v2);
    if (!(Curry._2(HM.mem, v1, g.edges) && Curry._2(HM.mem, v2, g.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              301,
              6
            ],
            Error: new Error()
          };
    }
    Curry._3(unsafe_add_edge, g.edges, v2, v1);
    
  };
  var add_edge_e$1 = function (g, param) {
    return add_edge$1(g, param[0], param[1]);
  };
  var remove_edge$2 = function (g, v1, v2) {
    remove_edge$1(g, v1, v2);
    if (!(Curry._2(HM.mem, v1, g.edges) && Curry._2(HM.mem, v2, g.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              308,
              6
            ],
            Error: new Error()
          };
    }
    Curry._3(unsafe_remove_edge, g.edges, v2, v1);
    
  };
  var remove_edge_e$2 = function (g, param) {
    return remove_edge$2(g, param[0], param[1]);
  };
  var $$let = Mark;
  return {
          V: include$1.V,
          E: include$1.E,
          is_directed: include$1.is_directed,
          is_empty: include$1.is_empty,
          nb_vertex: include$1.nb_vertex,
          nb_edges: include$1.nb_edges,
          out_degree: include$1.out_degree,
          in_degree: include$1.in_degree,
          mem_vertex: include$1.mem_vertex,
          mem_edge: include$1.mem_edge,
          mem_edge_e: include$1.mem_edge_e,
          find_edge: include$1.find_edge,
          find_all_edges: include$1.find_all_edges,
          succ: include$1.succ,
          pred: include$1.pred,
          succ_e: include$1.succ_e,
          pred_e: include$1.pred_e,
          iter_vertex: include$1.iter_vertex,
          fold_vertex: include$1.fold_vertex,
          iter_edges: include$1.iter_edges,
          fold_edges: include$1.fold_edges,
          iter_edges_e: include$1.iter_edges_e,
          fold_edges_e: include$1.fold_edges_e,
          map_vertex: include$1.map_vertex,
          iter_succ: include$1.iter_succ,
          iter_pred: include$1.iter_pred,
          fold_succ: include$1.fold_succ,
          fold_pred: include$1.fold_pred,
          iter_succ_e: include$1.iter_succ_e,
          fold_succ_e: include$1.fold_succ_e,
          iter_pred_e: include$1.iter_pred_e,
          fold_pred_e: include$1.fold_pred_e,
          create: include$1.create,
          clear: include$1.clear,
          copy: include$1.copy,
          add_vertex: include$1.add_vertex,
          remove_vertex: include$1.remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e$1,
          remove_edge: remove_edge$2,
          remove_edge_e: remove_edge_e$2,
          Mark: {
            clear: $$let.clear,
            get: $$let.get,
            set: $$let.set
          }
        };
}

function Graph_ConcreteLabeled(funarg, funarg$1) {
  var include = Curry._2(I.Digraph.ConcreteLabeled, funarg, funarg$1);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var add_vertex = include.add_vertex;
  var add_edge_e = include.add_edge_e;
  var add_edge = include.add_edge;
  var add_vertex$1 = function (g, v) {
    Curry._2(add_vertex, g, v);
    
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  var add_edge_e$1 = function (g, e) {
    Curry._2(add_edge_e, g, e);
    
  };
  var add_edge$1 = function (g, v1, v2) {
    Curry._3(add_edge, g, v1, v2);
    
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g)) {
      return ;
    }
    Curry._2(HM.remove, v, g);
    var remove = function (v) {
      return Curry._1(S.filter, (function (param) {
                    return !Curry._2(V.equal, v, param[0]);
                  }));
    };
    return Curry._2(HM.iter, (function (k, s) {
                  Curry._3(HM.add, k, Curry._1(remove(v), s), g);
                  
                }), g);
  };
  var include_VE = include.VE;
  var include_E = include.E;
  var include_mem_edge = include.mem_edge;
  var include_mem_edge_e = include.mem_edge_e;
  var include_Found = include.Found;
  var include_find_edge = include.find_edge;
  var include_find_all_edges = include.find_all_edges;
  var include_unsafe_remove_edge = include.unsafe_remove_edge;
  var include_unsafe_remove_edge_e = include.unsafe_remove_edge_e;
  var include_iter_succ = include.iter_succ;
  var include_fold_succ = include.fold_succ;
  var include_iter_succ_e = include.iter_succ_e;
  var include_fold_succ_e = include.fold_succ_e;
  var include_succ = include.succ;
  var include_succ_e = include.succ_e;
  var include_map_vertex = include.map_vertex;
  var include_I = include.I;
  var include_PV = include.PV;
  var include_PE = include.PE;
  var include_iter_edges = include.iter_edges;
  var include_fold_edges = include.fold_edges;
  var include_iter_edges_e = include.iter_edges_e;
  var include_fold_edges_e = include.fold_edges_e;
  var include_iter_pred = include.iter_pred;
  var include_fold_pred = include.fold_pred;
  var include_pred = include.pred;
  var include_in_degree = include.in_degree;
  var include_iter_pred_e = include.iter_pred_e;
  var include_fold_pred_e = include.fold_pred_e;
  var include_pred_e = include.pred_e;
  var include_is_directed = include.is_directed;
  var include_empty = include.empty;
  var include_create = include.create;
  var include_is_empty = include.is_empty;
  var include_copy = include.copy;
  var include_clear = include.clear;
  var include_nb_vertex = include.nb_vertex;
  var include_nb_edges = include.nb_edges;
  var include_out_degree = include.out_degree;
  var include_mem_vertex = include.mem_vertex;
  var include_unsafe_add_vertex = include.unsafe_add_vertex;
  var include_unsafe_add_edge = include.unsafe_add_edge;
  var include_iter_vertex = include.iter_vertex;
  var include_fold_vertex = include.fold_vertex;
  var V$1 = V;
  var HM$1 = HM;
  var E = include_E;
  var unsafe_remove_edge = include_unsafe_remove_edge;
  var unsafe_remove_edge_e = include_unsafe_remove_edge_e;
  var unsafe_add_edge = include_unsafe_add_edge;
  var remove_edge$2 = remove_edge$1;
  var remove_edge_e$2 = remove_edge_e$1;
  var add_edge_e$2 = add_edge_e$1;
  var include$1 = Blocks.Graph({
        V: {
          compare: V$1.compare,
          hash: V$1.hash,
          equal: V$1.equal,
          create: V$1.create,
          label: V$1.label
        },
        E: {
          compare: E.compare,
          src: E.src,
          dst: E.dst,
          create: E.create,
          label: E.label
        },
        is_directed: include_is_directed,
        is_empty: include_is_empty,
        nb_vertex: include_nb_vertex,
        nb_edges: include_nb_edges,
        out_degree: include_out_degree,
        in_degree: include_in_degree,
        mem_vertex: include_mem_vertex,
        mem_edge: include_mem_edge,
        mem_edge_e: include_mem_edge_e,
        find_edge: include_find_edge,
        find_all_edges: include_find_all_edges,
        succ: include_succ,
        pred: include_pred,
        succ_e: include_succ_e,
        pred_e: include_pred_e,
        iter_vertex: include_iter_vertex,
        fold_vertex: include_fold_vertex,
        iter_edges: include_iter_edges,
        fold_edges: include_fold_edges,
        iter_edges_e: include_iter_edges_e,
        fold_edges_e: include_fold_edges_e,
        map_vertex: include_map_vertex,
        iter_succ: include_iter_succ,
        iter_pred: include_iter_pred,
        fold_succ: include_fold_succ,
        fold_pred: include_fold_pred,
        iter_succ_e: include_iter_succ_e,
        fold_succ_e: include_fold_succ_e,
        iter_pred_e: include_iter_pred_e,
        fold_pred_e: include_fold_pred_e,
        create: include_create,
        clear: include_clear,
        copy: include_copy,
        add_vertex: add_vertex$1,
        remove_vertex: remove_vertex
      });
  var mem_edge_e = include$1.mem_edge_e;
  var add_edge_e$3 = function (g, e) {
    var v2 = e[2];
    var v1 = e[0];
    if (Curry._2(mem_edge_e, g, e)) {
      return ;
    }
    Curry._2(add_edge_e$2, g, e);
    if (!(Curry._2(HM$1.mem, v1, g) && Curry._2(HM$1.mem, v2, g))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              271,
              8
            ],
            Error: new Error()
          };
    }
    Curry._3(unsafe_add_edge, g, v2, [
          v1,
          e[1]
        ]);
    
  };
  var add_edge$2 = function (g, v1, v2) {
    return add_edge_e$3(g, [
                v1,
                funarg$1.$$default,
                v2
              ]);
  };
  var remove_edge$3 = function (g, v1, v2) {
    Curry._3(remove_edge$2, g, v1, v2);
    if (!(Curry._2(HM$1.mem, v1, g) && Curry._2(HM$1.mem, v2, g))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              279,
              6
            ],
            Error: new Error()
          };
    }
    Curry._3(unsafe_remove_edge, g, v2, v1);
    
  };
  var remove_edge_e$3 = function (g, e) {
    var v2 = e[2];
    var v1 = e[0];
    Curry._2(remove_edge_e$2, g, e);
    if (!(Curry._2(HM$1.mem, v1, g) && Curry._2(HM$1.mem, v2, g))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              284,
              6
            ],
            Error: new Error()
          };
    }
    Curry._2(unsafe_remove_edge_e, g, [
          v2,
          e[1],
          v1
        ]);
    
  };
  return {
          V: include$1.V,
          E: include$1.E,
          is_directed: include$1.is_directed,
          is_empty: include$1.is_empty,
          nb_vertex: include$1.nb_vertex,
          nb_edges: include$1.nb_edges,
          out_degree: include$1.out_degree,
          in_degree: include$1.in_degree,
          mem_vertex: include$1.mem_vertex,
          mem_edge: include$1.mem_edge,
          mem_edge_e: mem_edge_e,
          find_edge: include$1.find_edge,
          find_all_edges: include$1.find_all_edges,
          succ: include$1.succ,
          pred: include$1.pred,
          succ_e: include$1.succ_e,
          pred_e: include$1.pred_e,
          iter_vertex: include$1.iter_vertex,
          fold_vertex: include$1.fold_vertex,
          iter_edges: include$1.iter_edges,
          fold_edges: include$1.fold_edges,
          iter_edges_e: include$1.iter_edges_e,
          fold_edges_e: include$1.fold_edges_e,
          map_vertex: include$1.map_vertex,
          iter_succ: include$1.iter_succ,
          iter_pred: include$1.iter_pred,
          fold_succ: include$1.fold_succ,
          fold_pred: include$1.fold_pred,
          iter_succ_e: include$1.iter_succ_e,
          fold_succ_e: include$1.fold_succ_e,
          iter_pred_e: include$1.iter_pred_e,
          fold_pred_e: include$1.fold_pred_e,
          create: include$1.create,
          clear: include$1.clear,
          copy: include$1.copy,
          add_vertex: include$1.add_vertex,
          remove_vertex: include$1.remove_vertex,
          add_edge: add_edge$2,
          add_edge_e: add_edge_e$3,
          remove_edge: remove_edge$3,
          remove_edge_e: remove_edge_e$3
        };
}

function Graph_AbstractLabeled(funarg, funarg$1) {
  var compare = function (x, y) {
    return Caml.caml_int_compare(x.tag, y.tag);
  };
  var hash = function (x) {
    return x.tag;
  };
  var equal = function (x, y) {
    return x.tag === y.tag;
  };
  var label = function (x) {
    return x.label;
  };
  var create = function (l) {
    if (Blocks.cpt_vertex.contents === (Blocks.first_value_for_cpt_vertex - 1 | 0)) {
      Pervasives.invalid_arg("Too much vertices");
    }
    Blocks.cpt_vertex.contents = Blocks.cpt_vertex.contents + 1 | 0;
    return {
            tag: Blocks.cpt_vertex.contents,
            label: l,
            mark: 0
          };
  };
  var include = Curry._2(I.Digraph.AbstractLabeled, {
        compare: compare,
        hash: hash,
        equal: equal,
        create: create,
        label: label
      }, funarg$1);
  var G = include.G;
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var unsafe_add_edge = include.unsafe_add_edge;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var iter_vertex = include.iter_vertex;
  var add_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      g.size = g.size + 1 | 0;
      Curry._2(G.unsafe_add_vertex, g.edges, v);
      return ;
    }
    
  };
  var add_edge_e = function (g, param) {
    var v2 = param[2];
    var v1 = param[0];
    add_vertex(g, v1);
    add_vertex(g, v2);
    Curry._3(unsafe_add_edge, g.edges, v1, [
          v2,
          param[1]
        ]);
    
  };
  var add_edge = function (g, v1, v2) {
    return add_edge_e(g, [
                v1,
                funarg$1.$$default,
                v2
              ]);
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      return ;
    }
    var remove = function (s) {
      return Curry._3(S.fold, (function (e, s) {
                    if (Curry._2(V.equal, v, e[0])) {
                      return s;
                    } else {
                      return Curry._2(S.add, e, s);
                    }
                  }), s, S.empty);
    };
    var e = g.edges;
    Curry._2(HM.remove, v, e);
    Curry._2(HM.iter, (function (k, s) {
            Curry._3(HM.add, k, remove(s), e);
            
          }), e);
    g.size = g.size - 1 | 0;
    
  };
  var get = function (v) {
    return v.mark;
  };
  var set = function (v, m) {
    v.mark = m;
    
  };
  var clear = function (g) {
    return Curry._2(iter_vertex, (function (v) {
                  v.mark = 0;
                  
                }), g);
  };
  var Mark = {
    get: get,
    set: set,
    clear: clear
  };
  var remove_edge$1 = function (g, v1, v2) {
    Curry._3(remove_edge, g, v1, v2);
    
  };
  var remove_edge_e$1 = function (g, e) {
    Curry._2(remove_edge_e, g, e);
    
  };
  var include_I = include.I;
  var include_PV = include.PV;
  var include_PE = include.PE;
  var include_iter_edges = include.iter_edges;
  var include_fold_edges = include.fold_edges;
  var include_iter_edges_e = include.iter_edges_e;
  var include_fold_edges_e = include.fold_edges_e;
  var include_create = include.create;
  var include_clear = include.clear;
  var include_iter_pred = include.iter_pred;
  var include_fold_pred = include.fold_pred;
  var include_pred = include.pred;
  var include_iter_pred_e = include.iter_pred_e;
  var include_fold_pred_e = include.fold_pred_e;
  var include_pred_e = include.pred_e;
  var include_is_empty = include.is_empty;
  var include_nb_vertex = include.nb_vertex;
  var include_E = include.E;
  var include_unsafe_remove_edge = include.unsafe_remove_edge;
  var include_unsafe_remove_edge_e = include.unsafe_remove_edge_e;
  var include_is_directed = include.is_directed;
  var include_out_degree = include.out_degree;
  var include_in_degree = include.in_degree;
  var include_nb_edges = include.nb_edges;
  var include_succ = include.succ;
  var include_mem_vertex = include.mem_vertex;
  var include_mem_edge = include.mem_edge;
  var include_mem_edge_e = include.mem_edge_e;
  var include_find_edge = include.find_edge;
  var include_find_all_edges = include.find_all_edges;
  var include_fold_vertex = include.fold_vertex;
  var include_iter_succ = include.iter_succ;
  var include_fold_succ = include.fold_succ;
  var include_succ_e = include.succ_e;
  var include_iter_succ_e = include.iter_succ_e;
  var include_fold_succ_e = include.fold_succ_e;
  var include_map_vertex = include.map_vertex;
  var include_copy = include.copy;
  var iter_edges = include_iter_edges;
  var fold_edges = include_fold_edges;
  var iter_edges_e = include_iter_edges_e;
  var fold_edges_e = include_fold_edges_e;
  var create$1 = include_create;
  var clear$1 = include_clear;
  var iter_pred = include_iter_pred;
  var fold_pred = include_fold_pred;
  var pred = include_pred;
  var iter_pred_e = include_iter_pred_e;
  var fold_pred_e = include_fold_pred_e;
  var pred_e = include_pred_e;
  var is_empty = include_is_empty;
  var nb_vertex = include_nb_vertex;
  var V$1 = V;
  var E = include_E;
  var HM$1 = HM;
  var unsafe_add_edge$1 = unsafe_add_edge;
  var unsafe_remove_edge = include_unsafe_remove_edge;
  var unsafe_remove_edge_e = include_unsafe_remove_edge_e;
  var is_directed = include_is_directed;
  var out_degree = include_out_degree;
  var in_degree = include_in_degree;
  var nb_edges = include_nb_edges;
  var succ = include_succ;
  var mem_vertex = include_mem_vertex;
  var mem_edge = include_mem_edge;
  var mem_edge_e = include_mem_edge_e;
  var find_edge = include_find_edge;
  var find_all_edges = include_find_all_edges;
  var iter_vertex$1 = iter_vertex;
  var fold_vertex = include_fold_vertex;
  var iter_succ = include_iter_succ;
  var fold_succ = include_fold_succ;
  var succ_e = include_succ_e;
  var iter_succ_e = include_iter_succ_e;
  var fold_succ_e = include_fold_succ_e;
  var map_vertex = include_map_vertex;
  var copy = include_copy;
  var add_vertex$1 = add_vertex;
  var add_edge_e$1 = add_edge_e;
  var remove_vertex$1 = remove_vertex;
  var remove_edge$2 = remove_edge$1;
  var remove_edge_e$2 = remove_edge_e$1;
  var G_G = G;
  var G_I = include_I;
  var G_PV = include_PV;
  var G_PE = include_PE;
  var G_S = S;
  var G_add_edge = add_edge;
  var G_Mark = Mark;
  var include$1 = Blocks.Graph({
        V: V$1,
        E: E,
        is_directed: is_directed,
        is_empty: is_empty,
        nb_vertex: nb_vertex,
        nb_edges: nb_edges,
        out_degree: out_degree,
        in_degree: in_degree,
        mem_vertex: mem_vertex,
        mem_edge: mem_edge,
        mem_edge_e: mem_edge_e,
        find_edge: find_edge,
        find_all_edges: find_all_edges,
        succ: succ,
        pred: pred,
        succ_e: succ_e,
        pred_e: pred_e,
        iter_vertex: iter_vertex$1,
        fold_vertex: fold_vertex,
        iter_edges: iter_edges,
        fold_edges: fold_edges,
        iter_edges_e: iter_edges_e,
        fold_edges_e: fold_edges_e,
        map_vertex: map_vertex,
        iter_succ: iter_succ,
        iter_pred: iter_pred,
        fold_succ: fold_succ,
        fold_pred: fold_pred,
        iter_succ_e: iter_succ_e,
        fold_succ_e: fold_succ_e,
        iter_pred_e: iter_pred_e,
        fold_pred_e: fold_pred_e,
        create: create$1,
        clear: clear$1,
        copy: copy,
        add_vertex: add_vertex$1,
        remove_vertex: remove_vertex$1
      });
  var add_edge_e$2 = function (g, e) {
    var v2 = e[2];
    var v1 = e[0];
    Curry._2(add_edge_e$1, g, e);
    if (!(Curry._2(HM$1.mem, v1, g.edges) && Curry._2(HM$1.mem, v2, g.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              330,
              6
            ],
            Error: new Error()
          };
    }
    Curry._3(unsafe_add_edge$1, g.edges, v2, [
          v1,
          e[1]
        ]);
    
  };
  var add_edge$1 = function (g, v1, v2) {
    return add_edge_e$2(g, [
                v1,
                funarg$1.$$default,
                v2
              ]);
  };
  var remove_edge$3 = function (g, v1, v2) {
    Curry._3(remove_edge$2, g, v1, v2);
    if (!(Curry._2(HM$1.mem, v1, g.edges) && Curry._2(HM$1.mem, v2, g.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              337,
              6
            ],
            Error: new Error()
          };
    }
    Curry._3(unsafe_remove_edge, g.edges, v2, v1);
    
  };
  var remove_edge_e$3 = function (g, e) {
    var v2 = e[2];
    var v1 = e[0];
    Curry._2(remove_edge_e$2, g, e);
    if (!(Curry._2(HM$1.mem, v1, g.edges) && Curry._2(HM$1.mem, v2, g.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "imperative.ml",
              342,
              6
            ],
            Error: new Error()
          };
    }
    Curry._2(unsafe_remove_edge_e, g.edges, [
          v2,
          e[1],
          v1
        ]);
    
  };
  var $$let = G_Mark;
  return {
          V: include$1.V,
          E: include$1.E,
          is_directed: include$1.is_directed,
          is_empty: include$1.is_empty,
          nb_vertex: include$1.nb_vertex,
          nb_edges: include$1.nb_edges,
          out_degree: include$1.out_degree,
          in_degree: include$1.in_degree,
          mem_vertex: include$1.mem_vertex,
          mem_edge: include$1.mem_edge,
          mem_edge_e: include$1.mem_edge_e,
          find_edge: include$1.find_edge,
          find_all_edges: include$1.find_all_edges,
          succ: include$1.succ,
          pred: include$1.pred,
          succ_e: include$1.succ_e,
          pred_e: include$1.pred_e,
          iter_vertex: include$1.iter_vertex,
          fold_vertex: include$1.fold_vertex,
          iter_edges: include$1.iter_edges,
          fold_edges: include$1.fold_edges,
          iter_edges_e: include$1.iter_edges_e,
          fold_edges_e: include$1.fold_edges_e,
          map_vertex: include$1.map_vertex,
          iter_succ: include$1.iter_succ,
          iter_pred: include$1.iter_pred,
          fold_succ: include$1.fold_succ,
          fold_pred: include$1.fold_pred,
          iter_succ_e: include$1.iter_succ_e,
          fold_succ_e: include$1.fold_succ_e,
          iter_pred_e: include$1.iter_pred_e,
          fold_pred_e: include$1.fold_pred_e,
          create: include$1.create,
          clear: include$1.clear,
          copy: include$1.copy,
          add_vertex: include$1.add_vertex,
          remove_vertex: include$1.remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e$2,
          remove_edge: remove_edge$3,
          remove_edge_e: remove_edge_e$3,
          Mark: {
            clear: $$let.clear,
            get: $$let.get,
            set: $$let.set
          }
        };
}

var Graph = {
  Concrete: Graph_Concrete,
  Abstract: Graph_Abstract,
  ConcreteLabeled: Graph_ConcreteLabeled,
  AbstractLabeled: Graph_AbstractLabeled
};

var Matrix_Digraph = {
  V: V,
  E: {
    compare: compare$1,
    src: src,
    dst: dst,
    create: create$1,
    label: label$1
  },
  is_directed: true,
  is_empty: is_empty,
  nb_vertex: nb_vertex,
  nb_edges: nb_edges,
  out_degree: out_degree,
  in_degree: in_degree,
  mem_vertex: mem_vertex,
  mem_edge: mem_edge,
  mem_edge_e: mem_edge_e,
  find_edge: find_edge,
  find_all_edges: find_all_edges,
  succ: succ,
  pred: pred,
  succ_e: succ_e,
  pred_e: pred_e,
  iter_vertex: iter_vertex,
  fold_vertex: fold_vertex,
  iter_edges: iter_edges,
  fold_edges: fold_edges,
  iter_edges_e: iter_edges_e,
  fold_edges_e: fold_edges_e,
  map_vertex: map_vertex,
  iter_succ: iter_succ,
  iter_pred: iter_pred,
  fold_succ: fold_succ,
  fold_pred: fold_pred,
  iter_succ_e: iter_succ_e,
  fold_succ_e: fold_succ_e,
  iter_pred_e: iter_pred_e,
  fold_pred_e: fold_pred_e,
  create: create$2,
  clear: clear,
  copy: copy,
  add_vertex: add_vertex,
  remove_vertex: remove_vertex,
  add_edge: add_edge,
  add_edge_e: add_edge_e,
  remove_edge: remove_edge,
  remove_edge_e: remove_edge_e,
  make: make
};

var Matrix_Graph = {
  V: include.V,
  E: include.E,
  is_directed: include.is_directed,
  is_empty: include.is_empty,
  nb_vertex: include.nb_vertex,
  nb_edges: include.nb_edges,
  out_degree: include.out_degree,
  in_degree: include.in_degree,
  mem_vertex: include.mem_vertex,
  mem_edge: include.mem_edge,
  mem_edge_e: include.mem_edge_e,
  find_edge: include.find_edge,
  find_all_edges: include.find_all_edges,
  succ: include.succ,
  pred: include.pred,
  succ_e: include.succ_e,
  pred_e: include.pred_e,
  iter_vertex: include.iter_vertex,
  fold_vertex: include.fold_vertex,
  iter_edges: include.iter_edges,
  fold_edges: include.fold_edges,
  iter_edges_e: include.iter_edges_e,
  fold_edges_e: include.fold_edges_e,
  map_vertex: include.map_vertex,
  iter_succ: include.iter_succ,
  iter_pred: include.iter_pred,
  fold_succ: include.fold_succ,
  fold_pred: include.fold_pred,
  iter_succ_e: include.iter_succ_e,
  fold_succ_e: include.fold_succ_e,
  iter_pred_e: include.iter_pred_e,
  fold_pred_e: include.fold_pred_e,
  create: include.create,
  clear: include.clear,
  copy: include.copy,
  add_vertex: include.add_vertex,
  remove_vertex: include.remove_vertex,
  add_edge: add_edge$1,
  add_edge_e: add_edge_e$1,
  remove_edge: remove_edge$1,
  remove_edge_e: remove_edge_e$1,
  make: make
};

var Matrix = {
  Digraph: Matrix_Digraph,
  Graph: Matrix_Graph
};

exports.Digraph = Digraph;
exports.Graph = Graph;
exports.Matrix = Matrix;
/* I Not a pure module */
