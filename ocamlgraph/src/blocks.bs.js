// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("rescript/lib/js/map.js");
var $$Set = require("rescript/lib/js/set.js");
var Caml = require("rescript/lib/js/caml.js");
var Util = require("./util.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Hashtbl = require("rescript/lib/js/hashtbl.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var cpt_vertex = {
  contents: 0
};

function max_cpt(c1, c2) {
  return Caml.caml_int_max(c1 + Pervasives.min_int | 0, c2 + Pervasives.min_int | 0) - Pervasives.min_int | 0;
}

function after_unserialization(serialized_cpt_vertex) {
  cpt_vertex.contents = max_cpt(serialized_cpt_vertex, cpt_vertex.contents);
  
}

function Make_Hashtbl(X) {
  var include = Hashtbl.Make({
        equal: X.equal,
        hash: X.hash
      });
  var create = include.create;
  var add = include.add;
  var remove = include.remove;
  var find = include.find;
  var replace = include.replace;
  var mem = include.mem;
  var iter = include.iter;
  var length = include.length;
  var create_from = function (h) {
    return Curry._1(create, Curry._1(length, h));
  };
  var create$1 = function (sizeOpt, param) {
    return Curry._1(create, sizeOpt !== undefined ? sizeOpt : 97);
  };
  var is_empty = function (h) {
    return Curry._1(length, h) === 0;
  };
  var find_and_raise = function (k, h, s) {
    try {
      return Curry._2(find, h, k);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return Pervasives.invalid_arg(s);
      }
      throw exn;
    }
  };
  var map = function (f, h) {
    var h$p = Curry._1(create, Curry._1(length, h));
    Curry._2(iter, (function (k, v) {
            var match = Curry._2(f, k, v);
            return Curry._3(add, h$p, match[0], match[1]);
          }), h);
    return h$p;
  };
  var add$1 = function (k, v, h) {
    Curry._3(replace, h, k, v);
    return h;
  };
  var remove$1 = function (k, h) {
    Curry._2(remove, h, k);
    return h;
  };
  var mem$1 = function (k, h) {
    return Curry._2(mem, h, k);
  };
  var find$1 = function (k, h) {
    return Curry._2(find, h, k);
  };
  return {
          clear: include.clear,
          reset: include.reset,
          copy: include.copy,
          find_opt: include.find_opt,
          find_all: include.find_all,
          replace: replace,
          iter: iter,
          filter_map_inplace: include.filter_map_inplace,
          fold: include.fold,
          length: length,
          stats: include.stats,
          empty: undefined,
          create_from: create_from,
          create: create$1,
          is_empty: is_empty,
          find_and_raise: find_and_raise,
          map: map,
          add: add$1,
          remove: remove$1,
          mem: mem$1,
          find: find$1
        };
}

function Make_Map(X) {
  var include = $$Map.Make(X);
  var empty = include.empty;
  var add = include.add;
  var fold = include.fold;
  var find = include.find;
  var is_empty = function (m) {
    return Caml_obj.caml_equal(m, empty);
  };
  var create = function (param, param$1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "blocks.ml",
            103,
            26
          ],
          Error: new Error()
        };
  };
  var create_from = function (param) {
    return empty;
  };
  var copy = function (m) {
    return m;
  };
  var map = function (f, m) {
    return Curry._3(fold, (function (k, v, m) {
                  var match = Curry._2(f, k, v);
                  return Curry._3(add, match[0], match[1], m);
                }), m, empty);
  };
  var find_and_raise = function (k, h, s) {
    try {
      return Curry._2(find, k, h);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return Pervasives.invalid_arg(s);
      }
      throw exn;
    }
  };
  var clear = function (param) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "blocks.ml",
            110,
            16
          ],
          Error: new Error()
        };
  };
  return {
          empty: empty,
          mem: include.mem,
          add: add,
          update: include.update,
          singleton: include.singleton,
          remove: include.remove,
          merge: include.merge,
          union: include.union,
          compare: include.compare,
          equal: include.equal,
          iter: include.iter,
          fold: fold,
          for_all: include.for_all,
          exists: include.exists,
          filter: include.filter,
          partition: include.partition,
          cardinal: include.cardinal,
          bindings: include.bindings,
          min_binding: include.min_binding,
          min_binding_opt: include.min_binding_opt,
          max_binding: include.max_binding,
          max_binding_opt: include.max_binding_opt,
          choose: include.choose,
          choose_opt: include.choose_opt,
          split: include.split,
          find: find,
          find_opt: include.find_opt,
          find_first: include.find_first,
          find_first_opt: include.find_first_opt,
          find_last: include.find_last,
          find_last_opt: include.find_last_opt,
          mapi: include.mapi,
          is_empty: is_empty,
          create: create,
          create_from: create_from,
          copy: copy,
          map: map,
          find_and_raise: find_and_raise,
          clear: clear
        };
}

function Minimal(S, HM) {
  var nb_vertex = function (g) {
    return Curry._3(HM.fold, (function (param, param$1) {
                  return function (prim) {
                    return prim + 1 | 0;
                  };
                }), g, 0);
  };
  var nb_edges = function (g) {
    return Curry._3(HM.fold, (function (param, s, n) {
                  return n + Curry._1(S.cardinal, s) | 0;
                }), g, 0);
  };
  var out_degree = function (g, v) {
    var tmp;
    try {
      tmp = Curry._2(HM.find, v, g);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        tmp = Pervasives.invalid_arg("[ocamlgraph] out_degree");
      } else {
        throw exn;
      }
    }
    return Curry._1(S.cardinal, tmp);
  };
  var mem_vertex = function (g, v) {
    return Curry._2(HM.mem, v, g);
  };
  var unsafe_add_vertex = function (g, v) {
    return Curry._3(HM.add, v, S.empty, g);
  };
  var unsafe_add_edge = function (g, v1, v2) {
    return Curry._3(HM.add, v1, Curry._2(S.add, v2, Curry._2(HM.find, v1, g)), g);
  };
  var add_vertex = function (g, v) {
    if (Curry._2(HM.mem, v, g)) {
      return g;
    } else {
      return Curry._3(HM.add, v, S.empty, g);
    }
  };
  var iter_vertex = function (f) {
    return Curry._1(HM.iter, (function (v, param) {
                  return Curry._1(f, v);
                }));
  };
  var fold_vertex = function (f) {
    return Curry._1(HM.fold, (function (v, param) {
                  return Curry._1(f, v);
                }));
  };
  return {
          is_directed: true,
          empty: HM.empty,
          create: HM.create,
          is_empty: HM.is_empty,
          copy: HM.copy,
          clear: HM.clear,
          nb_vertex: nb_vertex,
          nb_edges: nb_edges,
          out_degree: out_degree,
          mem_vertex: mem_vertex,
          unsafe_add_vertex: unsafe_add_vertex,
          unsafe_add_edge: unsafe_add_edge,
          add_vertex: add_vertex,
          iter_vertex: iter_vertex,
          fold_vertex: fold_vertex
        };
}

function Pred(S) {
  var iter_pred = function (f, g, v) {
    if (!Curry._2(S.mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] iter_pred");
    }
    return Curry._2(S.iter_edges, (function (v1, v2) {
                  if (Curry._2(S.PV.equal, v, v2)) {
                    return Curry._1(f, v1);
                  }
                  
                }), g);
  };
  var fold_pred = function (f, g, v) {
    if (!Curry._2(S.mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] fold_pred");
    }
    return Curry._2(S.fold_edges, (function (v1, v2, a) {
                  if (Curry._2(S.PV.equal, v, v2)) {
                    return Curry._2(f, v1, a);
                  } else {
                    return a;
                  }
                }), g);
  };
  var pred = function (g, v) {
    return Curry._1(fold_pred((function (v, l) {
                      return {
                              hd: v,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var in_degree = function (g, v) {
    if (!Curry._2(S.mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] in_degree");
    }
    return Curry._1(fold_pred((function (param, n) {
                      return n + 1 | 0;
                    }), g, v), 0);
  };
  var iter_pred_e = function (f, g, v) {
    if (!Curry._2(S.mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
    }
    return Curry._2(S.iter_edges_e, (function (e) {
                  if (Curry._2(S.PV.equal, v, Curry._1(S.PE.dst, e))) {
                    return Curry._1(f, e);
                  }
                  
                }), g);
  };
  var fold_pred_e = function (f, g, v) {
    if (!Curry._2(S.mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
    }
    return Curry._2(S.fold_edges_e, (function (e, a) {
                  if (Curry._2(S.PV.equal, v, Curry._1(S.PE.dst, e))) {
                    return Curry._2(f, e, a);
                  } else {
                    return a;
                  }
                }), g);
  };
  var pred_e = function (g, v) {
    return Curry._1(fold_pred_e((function (v, l) {
                      return {
                              hd: v,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  return {
          iter_pred: iter_pred,
          fold_pred: fold_pred,
          pred: pred,
          in_degree: in_degree,
          iter_pred_e: iter_pred_e,
          fold_pred_e: fold_pred_e,
          pred_e: pred_e
        };
}

function Unlabeled(V, HM) {
  var S = $$Set.Make(V);
  var include = Util.OTProduct(V, V);
  var compare = include.compare;
  var src = function (prim) {
    return prim[0];
  };
  var dst = function (prim) {
    return prim[1];
  };
  var label = function (param) {
    
  };
  var create = function (v1, param, v2) {
    return [
            v1,
            v2
          ];
  };
  var E = {
    compare: compare,
    src: src,
    dst: dst,
    label: label,
    create: create
  };
  var mem_edge = function (g, v1, v2) {
    try {
      return Curry._2(S.mem, v2, Curry._2(HM.find, v1, g));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return false;
      }
      throw exn;
    }
  };
  var mem_edge_e = function (g, param) {
    return mem_edge(g, param[0], param[1]);
  };
  var find_edge = function (g, v1, v2) {
    if (mem_edge(g, v1, v2)) {
      return [
              v1,
              v2
            ];
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
  var find_all_edges = function (g, v1, v2) {
    try {
      return {
              hd: find_edge(g, v1, v2),
              tl: /* [] */0
            };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return /* [] */0;
      }
      throw exn;
    }
  };
  var unsafe_remove_edge = function (g, v1, v2) {
    return Curry._3(HM.add, v1, Curry._2(S.remove, v2, Curry._2(HM.find, v1, g)), g);
  };
  var unsafe_remove_edge_e = function (g, param) {
    return unsafe_remove_edge(g, param[0], param[1]);
  };
  var remove_edge = function (g, v1, v2) {
    if (!Curry._2(HM.mem, v2, g)) {
      Pervasives.invalid_arg("[ocamlgraph] remove_edge");
    }
    return Curry._3(HM.add, v1, Curry._2(S.remove, v2, Curry._3(HM.find_and_raise, v1, g, "[ocamlgraph] remove_edge")), g);
  };
  var remove_edge_e = function (g, param) {
    return remove_edge(g, param[0], param[1]);
  };
  var iter_succ = function (f, g, v) {
    return Curry._2(S.iter, f, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ"));
  };
  var fold_succ = function (f, g, v) {
    return Curry._2(S.fold, f, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ"));
  };
  var iter_succ_e = function (f, g, v) {
    return iter_succ((function (v2) {
                  return Curry._1(f, [
                              v,
                              v2
                            ]);
                }), g, v);
  };
  var fold_succ_e = function (f, g, v) {
    return fold_succ((function (v2) {
                  return Curry._1(f, [
                              v,
                              v2
                            ]);
                }), g, v);
  };
  var succ = function (g, v) {
    return Curry._1(S.elements, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] succ"));
  };
  var succ_e = function (g, v) {
    return Curry._1(fold_succ_e((function (e, l) {
                      return {
                              hd: e,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var map_vertex = function (f) {
    return Curry._1(HM.map, (function (v, s) {
                  return [
                          Curry._1(f, v),
                          Curry._3(S.fold, (function (v, s) {
                                  return Curry._2(S.add, Curry._1(f, v), s);
                                }), s, S.empty)
                        ];
                }));
  };
  var PE;
  var iter_edges = function (f) {
    return Curry._1(HM.iter, (function (v) {
                  return Curry._1(S.iter, Curry._1(f, v));
                }));
  };
  var fold_edges = function (f) {
    return Curry._1(HM.fold, (function (v) {
                  return Curry._1(S.fold, Curry._1(f, v));
                }));
  };
  var iter_edges_e = function (f) {
    return Curry._1(HM.iter, (function (v) {
                  return Curry._1(S.iter, (function (param) {
                                return Curry._1(f, [
                                            v,
                                            param
                                          ]);
                              }));
                }));
  };
  var fold_edges_e = function (f) {
    return Curry._1(HM.fold, (function (v) {
                  return Curry._1(S.fold, (function (param, param$1) {
                                return Curry._2(f, [
                                            v,
                                            param
                                          ], param$1);
                              }));
                }));
  };
  var I = {
    PV: V,
    PE: PE,
    iter_edges: iter_edges,
    fold_edges: fold_edges,
    iter_edges_e: iter_edges_e,
    fold_edges_e: fold_edges_e
  };
  var mem_vertex = HM.mem;
  var S_PE = {
    compare: compare,
    src: src,
    dst: dst,
    create: create,
    label: label
  };
  var iter_pred = function (f, g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] iter_pred");
    }
    var f$1 = function (v1, v2) {
      if (Curry._2(V.equal, v, v2)) {
        return Curry._1(f, v1);
      }
      
    };
    return Curry._1(Curry._1(HM.iter, (function (v) {
                      return Curry._1(S.iter, Curry._1(f$1, v));
                    })), g);
  };
  var fold_pred = function (f, g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] fold_pred");
    }
    var f$1 = function (v1, v2, a) {
      if (Curry._2(V.equal, v, v2)) {
        return Curry._2(f, v1, a);
      } else {
        return a;
      }
    };
    return Curry._1(Curry._1(HM.fold, (function (v) {
                      return Curry._1(S.fold, Curry._1(f$1, v));
                    })), g);
  };
  var pred = function (g, v) {
    return Curry._1(fold_pred((function (v, l) {
                      return {
                              hd: v,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var in_degree = function (g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] in_degree");
    }
    return Curry._1(fold_pred((function (param, n) {
                      return n + 1 | 0;
                    }), g, v), 0);
  };
  var iter_pred_e = function (f, g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
    }
    return Curry._1(iter_edges_e(function (e) {
                    if (Curry._2(V.equal, v, Curry._1(S_PE.dst, e))) {
                      return Curry._1(f, e);
                    }
                    
                  }), g);
  };
  var fold_pred_e = function (f, g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
    }
    return Curry._1(fold_edges_e(function (e, a) {
                    if (Curry._2(V.equal, v, Curry._1(S_PE.dst, e))) {
                      return Curry._2(f, e, a);
                    } else {
                      return a;
                    }
                  }), g);
  };
  var pred_e = function (g, v) {
    return Curry._1(fold_pred_e((function (v, l) {
                      return {
                              hd: v,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  return {
          S: S,
          E: E,
          mem_edge: mem_edge,
          mem_edge_e: mem_edge_e,
          find_edge: find_edge,
          find_all_edges: find_all_edges,
          unsafe_remove_edge: unsafe_remove_edge,
          unsafe_remove_edge_e: unsafe_remove_edge_e,
          remove_edge: remove_edge,
          remove_edge_e: remove_edge_e,
          iter_succ: iter_succ,
          fold_succ: fold_succ,
          iter_succ_e: iter_succ_e,
          fold_succ_e: fold_succ_e,
          succ: succ,
          succ_e: succ_e,
          map_vertex: map_vertex,
          I: I,
          PV: V,
          PE: PE,
          iter_edges: iter_edges,
          fold_edges: fold_edges,
          iter_edges_e: iter_edges_e,
          fold_edges_e: fold_edges_e,
          iter_pred: iter_pred,
          fold_pred: fold_pred,
          pred: pred,
          in_degree: in_degree,
          iter_pred_e: iter_pred_e,
          fold_pred_e: fold_pred_e,
          pred_e: pred_e
        };
}

function Labeled(V, E, HM) {
  var VE = Util.OTProduct(V, E);
  var S = $$Set.Make(VE);
  var src = function (param) {
    return param[0];
  };
  var dst = function (param) {
    return param[2];
  };
  var label = function (param) {
    return param[1];
  };
  var create = function (v1, l, v2) {
    return [
            v1,
            l,
            v2
          ];
  };
  var C = Util.OTProduct(V, VE);
  var compare = function (param, param$1) {
    return Curry._2(C.compare, [
                param[0],
                [
                  param[2],
                  param[1]
                ]
              ], [
                param$1[0],
                [
                  param$1[2],
                  param$1[1]
                ]
              ]);
  };
  var E$1 = {
    src: src,
    dst: dst,
    label: label,
    create: create,
    C: C,
    compare: compare
  };
  var mem_edge = function (g, v1, v2) {
    try {
      return Curry._2(S.exists, (function (param) {
                    return Curry._2(V.equal, v2, param[0]);
                  }), Curry._2(HM.find, v1, g));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return false;
      }
      throw exn;
    }
  };
  var mem_edge_e = function (g, param) {
    try {
      var ve_0 = param[2];
      var ve_1 = param[1];
      var ve = [
        ve_0,
        ve_1
      ];
      return Curry._2(S.exists, (function (ve$p) {
                    return Curry._2(VE.compare, ve, ve$p) === 0;
                  }), Curry._2(HM.find, param[0], g));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return false;
      }
      throw exn;
    }
  };
  var Found = /* @__PURE__ */Caml_exceptions.create("Blocks.Labeled(V)(E)(HM).Found");
  var find_edge = function (g, v1, v2) {
    try {
      Curry._2(S.iter, (function (param) {
              var v2$p = param[0];
              if (!Curry._2(V.equal, v2, v2$p)) {
                return ;
              }
              throw {
                    RE_EXN_ID: Found,
                    _1: [
                      v1,
                      param[1],
                      v2$p
                    ],
                    Error: new Error()
                  };
            }), Curry._2(HM.find, v1, g));
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === Found) {
        return e._1;
      }
      throw e;
    }
  };
  var find_all_edges = function (g, v1, v2) {
    try {
      return Curry._3(S.fold, (function (param, acc) {
                    var v2$p = param[0];
                    if (Curry._2(V.equal, v2, v2$p)) {
                      return {
                              hd: [
                                v1,
                                param[1],
                                v2$p
                              ],
                              tl: acc
                            };
                    } else {
                      return acc;
                    }
                  }), Curry._2(HM.find, v1, g), /* [] */0);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return /* [] */0;
      }
      throw exn;
    }
  };
  var unsafe_remove_edge = function (g, v1, v2) {
    return Curry._3(HM.add, v1, Curry._2(S.filter, (function (param) {
                      return !Curry._2(V.equal, v2, param[0]);
                    }), Curry._2(HM.find, v1, g)), g);
  };
  var unsafe_remove_edge_e = function (g, param) {
    var v1 = param[0];
    return Curry._3(HM.add, v1, Curry._2(S.remove, [
                    param[2],
                    param[1]
                  ], Curry._2(HM.find, v1, g)), g);
  };
  var remove_edge = function (g, v1, v2) {
    if (!Curry._2(HM.mem, v2, g)) {
      Pervasives.invalid_arg("[ocamlgraph] remove_edge");
    }
    return Curry._3(HM.add, v1, Curry._2(S.filter, (function (param) {
                      return !Curry._2(V.equal, v2, param[0]);
                    }), Curry._3(HM.find_and_raise, v1, g, "[ocamlgraph] remove_edge")), g);
  };
  var remove_edge_e = function (g, param) {
    var v2 = param[2];
    var v1 = param[0];
    if (!Curry._2(HM.mem, v2, g)) {
      Pervasives.invalid_arg("[ocamlgraph] remove_edge_e");
    }
    return Curry._3(HM.add, v1, Curry._2(S.remove, [
                    v2,
                    param[1]
                  ], Curry._3(HM.find_and_raise, v1, g, "[ocamlgraph] remove_edge_e")), g);
  };
  var iter_succ = function (f, g, v) {
    return Curry._2(S.iter, (function (param) {
                  return Curry._1(f, param[0]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ"));
  };
  var fold_succ = function (f, g, v) {
    return Curry._2(S.fold, (function (param) {
                  return Curry._1(f, param[0]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ"));
  };
  var iter_succ_e = function (f, g, v) {
    return Curry._2(S.iter, (function (param) {
                  return Curry._1(f, [
                              v,
                              param[1],
                              param[0]
                            ]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ_e"));
  };
  var fold_succ_e = function (f, g, v) {
    return Curry._2(S.fold, (function (param) {
                  return Curry._1(f, [
                              v,
                              param[1],
                              param[0]
                            ]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ_e"));
  };
  var succ = function (g, v) {
    return Curry._1(fold_succ((function (w, l) {
                      return {
                              hd: w,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var succ_e = function (g, v) {
    return Curry._1(fold_succ_e((function (e, l) {
                      return {
                              hd: e,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var map_vertex = function (f) {
    return Curry._1(HM.map, (function (v, s) {
                  return [
                          Curry._1(f, v),
                          Curry._3(S.fold, (function (param, s) {
                                  return Curry._2(S.add, [
                                              Curry._1(f, param[0]),
                                              param[1]
                                            ], s);
                                }), s, S.empty)
                        ];
                }));
  };
  var PE;
  var iter_edges = function (f) {
    return Curry._1(HM.iter, (function (v) {
                  return Curry._1(S.iter, (function (param) {
                                return Curry._2(f, v, param[0]);
                              }));
                }));
  };
  var fold_edges = function (f) {
    return Curry._1(HM.fold, (function (v) {
                  return Curry._1(S.fold, (function (param) {
                                return Curry._2(f, v, param[0]);
                              }));
                }));
  };
  var iter_edges_e = function (f) {
    return Curry._1(HM.iter, (function (v) {
                  return Curry._1(S.iter, (function (param) {
                                return Curry._1(f, [
                                            v,
                                            param[1],
                                            param[0]
                                          ]);
                              }));
                }));
  };
  var fold_edges_e = function (f) {
    return Curry._1(HM.fold, (function (v) {
                  return Curry._1(S.fold, (function (param) {
                                return Curry._1(f, [
                                            v,
                                            param[1],
                                            param[0]
                                          ]);
                              }));
                }));
  };
  var I = {
    PV: V,
    PE: PE,
    iter_edges: iter_edges,
    fold_edges: fold_edges,
    iter_edges_e: iter_edges_e,
    fold_edges_e: fold_edges_e
  };
  var mem_vertex = HM.mem;
  var S_PE = {
    compare: compare,
    src: src,
    dst: dst,
    create: create,
    label: label
  };
  var iter_pred = function (f, g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] iter_pred");
    }
    return Curry._1(iter_edges(function (v1, v2) {
                    if (Curry._2(V.equal, v, v2)) {
                      return Curry._1(f, v1);
                    }
                    
                  }), g);
  };
  var fold_pred = function (f, g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] fold_pred");
    }
    return Curry._1(fold_edges(function (v1, v2, a) {
                    if (Curry._2(V.equal, v, v2)) {
                      return Curry._2(f, v1, a);
                    } else {
                      return a;
                    }
                  }), g);
  };
  var pred = function (g, v) {
    return Curry._1(fold_pred((function (v, l) {
                      return {
                              hd: v,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var in_degree = function (g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] in_degree");
    }
    return Curry._1(fold_pred((function (param, n) {
                      return n + 1 | 0;
                    }), g, v), 0);
  };
  var iter_pred_e = function (f, g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
    }
    return Curry._1(iter_edges_e(function (e) {
                    if (Curry._2(V.equal, v, Curry._1(S_PE.dst, e))) {
                      return Curry._1(f, e);
                    }
                    
                  }), g);
  };
  var fold_pred_e = function (f, g, v) {
    if (!Curry._2(mem_vertex, v, g)) {
      Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
    }
    return Curry._1(fold_edges_e(function (e, a) {
                    if (Curry._2(V.equal, v, Curry._1(S_PE.dst, e))) {
                      return Curry._2(f, e, a);
                    } else {
                      return a;
                    }
                  }), g);
  };
  var pred_e = function (g, v) {
    return Curry._1(fold_pred_e((function (v, l) {
                      return {
                              hd: v,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  return {
          VE: VE,
          S: S,
          E: E$1,
          mem_edge: mem_edge,
          mem_edge_e: mem_edge_e,
          Found: Found,
          find_edge: find_edge,
          find_all_edges: find_all_edges,
          unsafe_remove_edge: unsafe_remove_edge,
          unsafe_remove_edge_e: unsafe_remove_edge_e,
          remove_edge: remove_edge,
          remove_edge_e: remove_edge_e,
          iter_succ: iter_succ,
          fold_succ: fold_succ,
          iter_succ_e: iter_succ_e,
          fold_succ_e: fold_succ_e,
          succ: succ,
          succ_e: succ_e,
          map_vertex: map_vertex,
          I: I,
          PV: V,
          PE: PE,
          iter_edges: iter_edges,
          fold_edges: fold_edges,
          iter_edges_e: iter_edges_e,
          fold_edges_e: fold_edges_e,
          iter_pred: iter_pred,
          fold_pred: fold_pred,
          pred: pred,
          in_degree: in_degree,
          iter_pred_e: iter_pred_e,
          fold_pred_e: fold_pred_e,
          pred_e: pred_e
        };
}

function ConcreteVertex(F, V) {
  var label = function (v) {
    return v;
  };
  var create = function (v) {
    return v;
  };
  var V_compare = V.compare;
  var V_hash = V.hash;
  var V_equal = V.equal;
  var V$1 = {
    compare: V_compare,
    hash: V_hash,
    equal: V_equal,
    label: label,
    create: create
  };
  var HM = Curry._1(F, V$1);
  return {
          V: V$1,
          HM: HM
        };
}

function Make_Abstract(G) {
  var PV = G.V;
  var PE = G.E;
  var iter_edges = function (f, g) {
    return Curry._2(G.iter_edges, f, g.edges);
  };
  var fold_edges = function (f, g) {
    return Curry._2(G.fold_edges, f, g.edges);
  };
  var iter_edges_e = function (f, g) {
    return Curry._2(G.iter_edges_e, f, g.edges);
  };
  var fold_edges_e = function (f, g) {
    return Curry._2(G.fold_edges_e, f, g.edges);
  };
  var mem_vertex = function (v, g) {
    return Curry._2(G.mem_vertex, g.edges, v);
  };
  var create = function (size, param) {
    return {
            edges: Curry._2(G.create, size, undefined),
            size: 0
          };
  };
  var clear = function (g) {
    Curry._1(G.clear, g.edges);
    g.size = 0;
    
  };
  var I = {
    PV: PV,
    PE: PE,
    iter_edges: iter_edges,
    fold_edges: fold_edges,
    iter_edges_e: iter_edges_e,
    fold_edges_e: fold_edges_e,
    mem_vertex: mem_vertex,
    create: create,
    clear: clear
  };
  var iter_pred = function (f, g, v) {
    if (!Curry._2(G.mem_vertex, g.edges, v)) {
      Pervasives.invalid_arg("[ocamlgraph] iter_pred");
    }
    return Curry._2(G.iter_edges, (function (v1, v2) {
                  if (Curry._2(PV.equal, v, v2)) {
                    return Curry._1(f, v1);
                  }
                  
                }), g.edges);
  };
  var fold_pred = function (f, g, v) {
    if (!Curry._2(G.mem_vertex, g.edges, v)) {
      Pervasives.invalid_arg("[ocamlgraph] fold_pred");
    }
    return Curry._2(G.fold_edges, (function (v1, v2, a) {
                  if (Curry._2(PV.equal, v, v2)) {
                    return Curry._2(f, v1, a);
                  } else {
                    return a;
                  }
                }), g.edges);
  };
  var pred = function (g, v) {
    return Curry._1(fold_pred((function (v, l) {
                      return {
                              hd: v,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var iter_pred_e = function (f, g, v) {
    if (!Curry._2(G.mem_vertex, g.edges, v)) {
      Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
    }
    return Curry._2(G.iter_edges_e, (function (e) {
                  if (Curry._2(PV.equal, v, Curry._1(PE.dst, e))) {
                    return Curry._1(f, e);
                  }
                  
                }), g.edges);
  };
  var fold_pred_e = function (f, g, v) {
    if (!Curry._2(G.mem_vertex, g.edges, v)) {
      Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
    }
    return Curry._2(G.fold_edges_e, (function (e, a) {
                  if (Curry._2(PV.equal, v, Curry._1(PE.dst, e))) {
                    return Curry._2(f, e, a);
                  } else {
                    return a;
                  }
                }), g.edges);
  };
  var pred_e = function (g, v) {
    return Curry._1(fold_pred_e((function (v, l) {
                      return {
                              hd: v,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var is_empty = function (g) {
    return g.size === 0;
  };
  var nb_vertex = function (g) {
    return g.size;
  };
  var V = G.V;
  var HM = G.HM;
  var remove_edge = function (g) {
    return Curry._1(G.remove_edge, g.edges);
  };
  var remove_edge_e = function (g) {
    return Curry._1(G.remove_edge_e, g.edges);
  };
  var out_degree = function (g) {
    return Curry._1(G.out_degree, g.edges);
  };
  var in_degree = function (g) {
    return Curry._1(G.in_degree, g.edges);
  };
  var nb_edges = function (g) {
    return Curry._1(G.nb_edges, g.edges);
  };
  var succ = function (g) {
    return Curry._1(G.succ, g.edges);
  };
  var mem_vertex$1 = function (g) {
    return Curry._1(G.mem_vertex, g.edges);
  };
  var mem_edge = function (g) {
    return Curry._1(G.mem_edge, g.edges);
  };
  var mem_edge_e = function (g) {
    return Curry._1(G.mem_edge_e, g.edges);
  };
  var find_edge = function (g) {
    return Curry._1(G.find_edge, g.edges);
  };
  var find_all_edges = function (g) {
    return Curry._1(G.find_all_edges, g.edges);
  };
  var iter_vertex = function (f, g) {
    return Curry._2(G.iter_vertex, f, g.edges);
  };
  var fold_vertex = function (f, g) {
    return Curry._2(G.fold_vertex, f, g.edges);
  };
  var iter_succ = function (f, g) {
    return Curry._2(G.iter_succ, f, g.edges);
  };
  var fold_succ = function (f, g) {
    return Curry._2(G.fold_succ, f, g.edges);
  };
  var succ_e = function (g) {
    return Curry._1(G.succ_e, g.edges);
  };
  var iter_succ_e = function (f, g) {
    return Curry._2(G.iter_succ_e, f, g.edges);
  };
  var fold_succ_e = function (f, g) {
    return Curry._2(G.fold_succ_e, f, g.edges);
  };
  var map_vertex = function (f, g) {
    return {
            edges: Curry._2(G.map_vertex, f, g.edges),
            size: g.size
          };
  };
  var copy = function (g) {
    var h = Curry._2(HM.create, undefined, undefined);
    var vertex = function (v) {
      try {
        return Curry._2(HM.find, v, h);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          var v$p = Curry._1(V.create, Curry._1(V.label, v));
          var h$p = Curry._3(HM.add, v, v$p, h);
          if (h !== h$p) {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "blocks.ml",
                    474,
                    8
                  ],
                  Error: new Error()
                };
          }
          return v$p;
        }
        throw exn;
      }
    };
    return map_vertex(vertex, g);
  };
  return {
          I: I,
          PV: PV,
          PE: PE,
          iter_edges: iter_edges,
          fold_edges: fold_edges,
          iter_edges_e: iter_edges_e,
          fold_edges_e: fold_edges_e,
          create: create,
          clear: clear,
          iter_pred: iter_pred,
          fold_pred: fold_pred,
          pred: pred,
          iter_pred_e: iter_pred_e,
          fold_pred_e: fold_pred_e,
          pred_e: pred_e,
          is_empty: is_empty,
          nb_vertex: nb_vertex,
          V: V,
          E: G.E,
          HM: HM,
          S: G.S,
          unsafe_add_edge: G.unsafe_add_edge,
          unsafe_remove_edge: G.unsafe_remove_edge,
          unsafe_remove_edge_e: G.unsafe_remove_edge_e,
          is_directed: G.is_directed,
          remove_edge: remove_edge,
          remove_edge_e: remove_edge_e,
          out_degree: out_degree,
          in_degree: in_degree,
          nb_edges: nb_edges,
          succ: succ,
          mem_vertex: mem_vertex$1,
          mem_edge: mem_edge,
          mem_edge_e: mem_edge_e,
          find_edge: find_edge,
          find_all_edges: find_all_edges,
          iter_vertex: iter_vertex,
          fold_vertex: fold_vertex,
          iter_succ: iter_succ,
          fold_succ: fold_succ,
          succ_e: succ_e,
          iter_succ_e: iter_succ_e,
          fold_succ_e: fold_succ_e,
          map_vertex: map_vertex,
          copy: copy
        };
}

function BidirectionalMinimal(S, HM) {
  var nb_vertex = function (g) {
    return Curry._3(HM.fold, (function (param, param$1) {
                  return function (prim) {
                    return prim + 1 | 0;
                  };
                }), g, 0);
  };
  var nb_edges = function (g) {
    return Curry._3(HM.fold, (function (param, param$1, n) {
                  return n + Curry._1(S.cardinal, param$1[1]) | 0;
                }), g, 0);
  };
  var out_degree = function (g, v) {
    var tmp;
    try {
      tmp = Curry._2(HM.find, v, g);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        tmp = Pervasives.invalid_arg("[ocamlgraph] out_degree");
      } else {
        throw exn;
      }
    }
    return Curry._1(S.cardinal, tmp[1]);
  };
  var mem_vertex = function (g, v) {
    return Curry._2(HM.mem, v, g);
  };
  var unsafe_add_vertex = function (g, v) {
    return Curry._3(HM.add, v, [
                S.empty,
                S.empty
              ], g);
  };
  var add_vertex = function (g, v) {
    if (Curry._2(HM.mem, v, g)) {
      return g;
    } else {
      return unsafe_add_vertex(g, v);
    }
  };
  var iter_vertex = function (f) {
    return Curry._1(HM.iter, (function (v, param) {
                  return Curry._1(f, v);
                }));
  };
  var fold_vertex = function (f) {
    return Curry._1(HM.fold, (function (v, param) {
                  return Curry._1(f, v);
                }));
  };
  return {
          is_directed: true,
          empty: HM.empty,
          create: HM.create,
          clear: HM.clear,
          is_empty: HM.is_empty,
          copy: HM.copy,
          nb_vertex: nb_vertex,
          nb_edges: nb_edges,
          out_degree: out_degree,
          mem_vertex: mem_vertex,
          unsafe_add_vertex: unsafe_add_vertex,
          add_vertex: add_vertex,
          iter_vertex: iter_vertex,
          fold_vertex: fold_vertex
        };
}

function BidirectionalUnlabeled(V, HM) {
  var S = $$Set.Make(V);
  var include = Util.OTProduct(V, V);
  var src = function (prim) {
    return prim[0];
  };
  var dst = function (prim) {
    return prim[1];
  };
  var label = function (param) {
    
  };
  var create = function (v1, param, v2) {
    return [
            v1,
            v2
          ];
  };
  var E_compare = include.compare;
  var E = {
    compare: E_compare,
    src: src,
    dst: dst,
    label: label,
    create: create
  };
  var mem_edge = function (g, v1, v2) {
    try {
      return Curry._2(S.mem, v2, Curry._2(HM.find, v1, g)[1]);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return false;
      }
      throw exn;
    }
  };
  var mem_edge_e = function (g, param) {
    return mem_edge(g, param[0], param[1]);
  };
  var find_edge = function (g, v1, v2) {
    if (mem_edge(g, v1, v2)) {
      return [
              v1,
              v2
            ];
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
  var find_all_edges = function (g, v1, v2) {
    try {
      return {
              hd: find_edge(g, v1, v2),
              tl: /* [] */0
            };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return /* [] */0;
      }
      throw exn;
    }
  };
  var unsafe_remove_edge = function (g, v1, v2) {
    var match = Curry._2(HM.find, v1, g);
    var g$1 = Curry._3(HM.add, v1, [
          match[0],
          Curry._2(S.remove, v2, match[1])
        ], g);
    var match$1 = Curry._2(HM.find, v2, g$1);
    return Curry._3(HM.add, v2, [
                Curry._2(S.remove, v1, match$1[0]),
                match$1[1]
              ], g$1);
  };
  var unsafe_remove_edge_e = function (g, param) {
    return unsafe_remove_edge(g, param[0], param[1]);
  };
  var remove_edge = function (g, v1, v2) {
    if (!(Curry._2(HM.mem, v2, g) && Curry._2(HM.mem, v1, g))) {
      Pervasives.invalid_arg("[ocamlgraph] remove_edge");
    }
    return unsafe_remove_edge(g, v1, v2);
  };
  var remove_edge_e = function (g, param) {
    return remove_edge(g, param[0], param[1]);
  };
  var iter_succ = function (f, g, v) {
    return Curry._2(S.iter, f, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ")[1]);
  };
  var fold_succ = function (f, g, v) {
    return Curry._2(S.fold, f, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ")[1]);
  };
  var iter_succ_e = function (f, g, v) {
    return iter_succ((function (v2) {
                  return Curry._1(f, [
                              v,
                              v2
                            ]);
                }), g, v);
  };
  var fold_succ_e = function (f, g, v) {
    return fold_succ((function (v2) {
                  return Curry._1(f, [
                              v,
                              v2
                            ]);
                }), g, v);
  };
  var succ = function (g, v) {
    return Curry._1(S.elements, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] succ")[1]);
  };
  var succ_e = function (g, v) {
    return Curry._1(fold_succ_e((function (e, l) {
                      return {
                              hd: e,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var map_vertex = function (f) {
    return Curry._1(HM.map, (function (v, param) {
                  return [
                          Curry._1(f, v),
                          [
                            Curry._3(S.fold, (function (v, s) {
                                    return Curry._2(S.add, Curry._1(f, v), s);
                                  }), param[0], S.empty),
                            Curry._3(S.fold, (function (v, s) {
                                    return Curry._2(S.add, Curry._1(f, v), s);
                                  }), param[1], S.empty)
                          ]
                        ];
                }));
  };
  var PE;
  var iter_edges = function (f) {
    return Curry._1(HM.iter, (function (v, param) {
                  return Curry._2(S.iter, Curry._1(f, v), param[1]);
                }));
  };
  var fold_edges = function (f) {
    return Curry._1(HM.fold, (function (v, param) {
                  return Curry._2(S.fold, Curry._1(f, v), param[1]);
                }));
  };
  var iter_edges_e = function (f) {
    return iter_edges(function (v1, v2) {
                return Curry._1(f, [
                            v1,
                            v2
                          ]);
              });
  };
  var fold_edges_e = function (f) {
    return fold_edges(function (v1, v2, a) {
                return Curry._2(f, [
                            v1,
                            v2
                          ], a);
              });
  };
  var I = {
    PV: V,
    PE: PE,
    iter_edges: iter_edges,
    fold_edges: fold_edges,
    iter_edges_e: iter_edges_e,
    fold_edges_e: fold_edges_e
  };
  var iter_pred = function (f, g, v) {
    return Curry._2(S.iter, f, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_pred")[0]);
  };
  var fold_pred = function (f, g, v) {
    return Curry._2(S.fold, f, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_pred")[0]);
  };
  var pred = function (g, v) {
    return Curry._1(S.elements, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] pred")[0]);
  };
  var in_degree = function (g, v) {
    var tmp;
    try {
      tmp = Curry._2(HM.find, v, g);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        tmp = Pervasives.invalid_arg("[ocamlgraph] in_degree");
      } else {
        throw exn;
      }
    }
    return Curry._1(S.cardinal, tmp[0]);
  };
  var iter_pred_e = function (f, g, v) {
    return iter_pred((function (v2) {
                  return Curry._1(f, [
                              v2,
                              v
                            ]);
                }), g, v);
  };
  var fold_pred_e = function (f, g, v) {
    return fold_pred((function (v2) {
                  return Curry._1(f, [
                              v2,
                              v
                            ]);
                }), g, v);
  };
  var pred_e = function (g, v) {
    return Curry._1(fold_pred_e((function (e, l) {
                      return {
                              hd: e,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  return {
          S: S,
          E: E,
          mem_edge: mem_edge,
          mem_edge_e: mem_edge_e,
          find_edge: find_edge,
          find_all_edges: find_all_edges,
          unsafe_remove_edge: unsafe_remove_edge,
          unsafe_remove_edge_e: unsafe_remove_edge_e,
          remove_edge: remove_edge,
          remove_edge_e: remove_edge_e,
          iter_succ: iter_succ,
          fold_succ: fold_succ,
          iter_succ_e: iter_succ_e,
          fold_succ_e: fold_succ_e,
          succ: succ,
          succ_e: succ_e,
          map_vertex: map_vertex,
          I: I,
          PV: V,
          PE: PE,
          iter_edges: iter_edges,
          fold_edges: fold_edges,
          iter_edges_e: iter_edges_e,
          fold_edges_e: fold_edges_e,
          iter_pred: iter_pred,
          fold_pred: fold_pred,
          pred: pred,
          in_degree: in_degree,
          iter_pred_e: iter_pred_e,
          fold_pred_e: fold_pred_e,
          pred_e: pred_e
        };
}

function BidirectionalLabeled(V, E, HM) {
  var VE = Util.OTProduct(V, E);
  var S = $$Set.Make(VE);
  var src = function (param) {
    return param[0];
  };
  var dst = function (param) {
    return param[2];
  };
  var label = function (param) {
    return param[1];
  };
  var create = function (v1, l, v2) {
    return [
            v1,
            l,
            v2
          ];
  };
  var C = Util.OTProduct(V, VE);
  var compare = function (param, param$1) {
    return Curry._2(C.compare, [
                param[0],
                [
                  param[2],
                  param[1]
                ]
              ], [
                param$1[0],
                [
                  param$1[2],
                  param$1[1]
                ]
              ]);
  };
  var E$1 = {
    src: src,
    dst: dst,
    label: label,
    create: create,
    C: C,
    compare: compare
  };
  var mem_edge = function (g, v1, v2) {
    try {
      return Curry._2(S.exists, (function (param) {
                    return Curry._2(V.equal, v2, param[0]);
                  }), Curry._2(HM.find, v1, g)[1]);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return false;
      }
      throw exn;
    }
  };
  var mem_edge_e = function (g, param) {
    try {
      var ve_0 = param[2];
      var ve_1 = param[1];
      var ve = [
        ve_0,
        ve_1
      ];
      return Curry._2(S.exists, (function (ve$p) {
                    return Curry._2(VE.compare, ve, ve$p) === 0;
                  }), Curry._2(HM.find, param[0], g)[1]);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return false;
      }
      throw exn;
    }
  };
  var Found = /* @__PURE__ */Caml_exceptions.create("Blocks.BidirectionalLabeled(V)(E)(HM).Found");
  var find_edge = function (g, v1, v2) {
    try {
      Curry._2(S.iter, (function (param) {
              var v2$p = param[0];
              if (!Curry._2(V.equal, v2, v2$p)) {
                return ;
              }
              throw {
                    RE_EXN_ID: Found,
                    _1: [
                      v1,
                      param[1],
                      v2$p
                    ],
                    Error: new Error()
                  };
            }), Curry._2(HM.find, v1, g)[1]);
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === Found) {
        return e._1;
      }
      throw e;
    }
  };
  var find_all_edges = function (g, v1, v2) {
    try {
      return Curry._3(S.fold, (function (param, acc) {
                    var v2$p = param[0];
                    if (Curry._2(V.equal, v2, v2$p)) {
                      return {
                              hd: [
                                v1,
                                param[1],
                                v2$p
                              ],
                              tl: acc
                            };
                    } else {
                      return acc;
                    }
                  }), Curry._2(HM.find, v1, g)[1], /* [] */0);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return /* [] */0;
      }
      throw exn;
    }
  };
  var unsafe_remove_edge = function (g, v1, v2) {
    var match = Curry._2(HM.find, v1, g);
    var del = function (v, set) {
      return Curry._2(S.filter, (function (param) {
                    return !Curry._2(V.equal, v, param[0]);
                  }), set);
    };
    var g$1 = Curry._3(HM.add, v1, [
          match[0],
          del(v2, match[1])
        ], g);
    var match$1 = Curry._2(HM.find, v2, g$1);
    return Curry._3(HM.add, v2, [
                del(v1, match$1[0]),
                match$1[1]
              ], g$1);
  };
  var unsafe_remove_edge_e = function (g, param) {
    var v2 = param[2];
    var l = param[1];
    var v1 = param[0];
    var match = Curry._2(HM.find, v1, g);
    var g$1 = Curry._3(HM.add, v1, [
          match[0],
          Curry._2(S.remove, [
                v2,
                l
              ], match[1])
        ], g);
    var match$1 = Curry._2(HM.find, v2, g$1);
    return Curry._3(HM.add, v2, [
                Curry._2(S.remove, [
                      v1,
                      l
                    ], match$1[0]),
                match$1[1]
              ], g$1);
  };
  var remove_edge = function (g, v1, v2) {
    var match = Curry._3(HM.find_and_raise, v1, g, "[ocamlgraph] remove_edge");
    var del = function (v, set) {
      return Curry._2(S.filter, (function (param) {
                    return !Curry._2(V.equal, v, param[0]);
                  }), set);
    };
    var g$1 = Curry._3(HM.add, v1, [
          match[0],
          del(v2, match[1])
        ], g);
    var match$1 = Curry._3(HM.find_and_raise, v2, g$1, "[ocamlgraph] remove_edge");
    return Curry._3(HM.add, v2, [
                del(v1, match$1[0]),
                match$1[1]
              ], g$1);
  };
  var remove_edge_e = function (g, param) {
    var v2 = param[2];
    var l = param[1];
    var v1 = param[0];
    var match = Curry._3(HM.find_and_raise, v1, g, "[ocamlgraph] remove_edge_e");
    var g$1 = Curry._3(HM.add, v1, [
          match[0],
          Curry._2(S.remove, [
                v2,
                l
              ], match[1])
        ], g);
    var match$1 = Curry._3(HM.find_and_raise, v2, g$1, "[ocamlgraph] remove_edge_e");
    return Curry._3(HM.add, v2, [
                Curry._2(S.remove, [
                      v1,
                      l
                    ], match$1[0]),
                match$1[1]
              ], g$1);
  };
  var iter_succ = function (f, g, v) {
    return Curry._2(S.iter, (function (param) {
                  return Curry._1(f, param[0]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ")[1]);
  };
  var fold_succ = function (f, g, v) {
    return Curry._2(S.fold, (function (param) {
                  return Curry._1(f, param[0]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ")[1]);
  };
  var iter_succ_e = function (f, g, v) {
    return Curry._2(S.iter, (function (param) {
                  return Curry._1(f, [
                              v,
                              param[1],
                              param[0]
                            ]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ_e")[1]);
  };
  var fold_succ_e = function (f, g, v) {
    return Curry._2(S.fold, (function (param) {
                  return Curry._1(f, [
                              v,
                              param[1],
                              param[0]
                            ]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ_e")[1]);
  };
  var succ = function (g, v) {
    return Curry._1(fold_succ((function (w, l) {
                      return {
                              hd: w,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var succ_e = function (g, v) {
    return Curry._1(fold_succ_e((function (e, l) {
                      return {
                              hd: e,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var map_vertex = function (f) {
    return Curry._1(HM.map, (function (v, param) {
                  return [
                          Curry._1(f, v),
                          [
                            Curry._3(S.fold, (function (param, s) {
                                    return Curry._2(S.add, [
                                                Curry._1(f, param[0]),
                                                param[1]
                                              ], s);
                                  }), param[0], S.empty),
                            Curry._3(S.fold, (function (param, s) {
                                    return Curry._2(S.add, [
                                                Curry._1(f, param[0]),
                                                param[1]
                                              ], s);
                                  }), param[1], S.empty)
                          ]
                        ];
                }));
  };
  var PE;
  var iter_edges = function (f) {
    return Curry._1(HM.iter, (function (v, param) {
                  return Curry._2(S.iter, (function (param) {
                                return Curry._2(f, v, param[0]);
                              }), param[1]);
                }));
  };
  var fold_edges = function (f) {
    return Curry._1(HM.fold, (function (v, param) {
                  return Curry._2(S.fold, (function (param) {
                                return Curry._2(f, v, param[0]);
                              }), param[1]);
                }));
  };
  var iter_edges_e = function (f) {
    return Curry._1(HM.iter, (function (v, param) {
                  return Curry._2(S.iter, (function (param) {
                                return Curry._1(f, [
                                            v,
                                            param[1],
                                            param[0]
                                          ]);
                              }), param[1]);
                }));
  };
  var fold_edges_e = function (f) {
    return Curry._1(HM.fold, (function (v, param) {
                  return Curry._2(S.fold, (function (param) {
                                return Curry._1(f, [
                                            v,
                                            param[1],
                                            param[0]
                                          ]);
                              }), param[1]);
                }));
  };
  var I = {
    PV: V,
    PE: PE,
    iter_edges: iter_edges,
    fold_edges: fold_edges,
    iter_edges_e: iter_edges_e,
    fold_edges_e: fold_edges_e
  };
  var iter_pred = function (f, g, v) {
    return Curry._2(S.iter, (function (param) {
                  return Curry._1(f, param[0]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_pred")[0]);
  };
  var fold_pred = function (f, g, v) {
    return Curry._2(S.fold, (function (param) {
                  return Curry._1(f, param[0]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_pred")[0]);
  };
  var in_degree = function (g, v) {
    var tmp;
    try {
      tmp = Curry._2(HM.find, v, g);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        tmp = Pervasives.invalid_arg("[ocamlgraph] in_degree");
      } else {
        throw exn;
      }
    }
    return Curry._1(S.cardinal, tmp[0]);
  };
  var iter_pred_e = function (f, g, v) {
    return Curry._2(S.iter, (function (param) {
                  return Curry._1(f, [
                              param[0],
                              param[1],
                              v
                            ]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_pred_e")[0]);
  };
  var fold_pred_e = function (f, g, v) {
    return Curry._2(S.fold, (function (param) {
                  return Curry._1(f, [
                              param[0],
                              param[1],
                              v
                            ]);
                }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_pred_e")[0]);
  };
  var pred = function (g, v) {
    return Curry._1(fold_pred((function (w, l) {
                      return {
                              hd: w,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  var pred_e = function (g, v) {
    return Curry._1(fold_pred_e((function (e, l) {
                      return {
                              hd: e,
                              tl: l
                            };
                    }), g, v), /* [] */0);
  };
  return {
          VE: VE,
          S: S,
          E: E$1,
          mem_edge: mem_edge,
          mem_edge_e: mem_edge_e,
          Found: Found,
          find_edge: find_edge,
          find_all_edges: find_all_edges,
          unsafe_remove_edge: unsafe_remove_edge,
          unsafe_remove_edge_e: unsafe_remove_edge_e,
          remove_edge: remove_edge,
          remove_edge_e: remove_edge_e,
          iter_succ: iter_succ,
          fold_succ: fold_succ,
          iter_succ_e: iter_succ_e,
          fold_succ_e: fold_succ_e,
          succ: succ,
          succ_e: succ_e,
          map_vertex: map_vertex,
          I: I,
          PV: V,
          PE: PE,
          iter_edges: iter_edges,
          fold_edges: fold_edges,
          iter_edges_e: iter_edges_e,
          fold_edges_e: fold_edges_e,
          iter_pred: iter_pred,
          fold_pred: fold_pred,
          in_degree: in_degree,
          iter_pred_e: iter_pred_e,
          fold_pred_e: fold_pred_e,
          pred: pred,
          pred_e: pred_e
        };
}

function Make(F) {
  var Concrete = function (V) {
    var label = function (v) {
      return v;
    };
    var create = function (v) {
      return v;
    };
    var V_compare = V.compare;
    var V_hash = V.hash;
    var V_equal = V.equal;
    var V$1 = {
      compare: V_compare,
      hash: V_hash,
      equal: V_equal,
      label: label,
      create: create
    };
    var HM = Curry._1(F, V$1);
    var V$2 = V$1;
    var HM$1 = HM;
    var S = $$Set.Make(V$2);
    var include = Util.OTProduct(V$2, V$2);
    var compare = include.compare;
    var src = function (prim) {
      return prim[0];
    };
    var dst = function (prim) {
      return prim[1];
    };
    var label$1 = function (param) {
      
    };
    var create$1 = function (v1, param, v2) {
      return [
              v1,
              v2
            ];
    };
    var E = {
      compare: compare,
      src: src,
      dst: dst,
      label: label$1,
      create: create$1
    };
    var mem_edge = function (g, v1, v2) {
      try {
        return Curry._2(S.mem, v2, Curry._2(HM$1.find, v1, g));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var mem_edge_e = function (g, param) {
      return mem_edge(g, param[0], param[1]);
    };
    var find_edge = function (g, v1, v2) {
      if (mem_edge(g, v1, v2)) {
        return [
                v1,
                v2
              ];
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    };
    var find_all_edges = function (g, v1, v2) {
      try {
        return {
                hd: find_edge(g, v1, v2),
                tl: /* [] */0
              };
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return /* [] */0;
        }
        throw exn;
      }
    };
    var unsafe_remove_edge = function (g, v1, v2) {
      return Curry._3(HM$1.add, v1, Curry._2(S.remove, v2, Curry._2(HM$1.find, v1, g)), g);
    };
    var unsafe_remove_edge_e = function (g, param) {
      return unsafe_remove_edge(g, param[0], param[1]);
    };
    var remove_edge = function (g, v1, v2) {
      if (!Curry._2(HM$1.mem, v2, g)) {
        Pervasives.invalid_arg("[ocamlgraph] remove_edge");
      }
      return Curry._3(HM$1.add, v1, Curry._2(S.remove, v2, Curry._3(HM$1.find_and_raise, v1, g, "[ocamlgraph] remove_edge")), g);
    };
    var remove_edge_e = function (g, param) {
      return remove_edge(g, param[0], param[1]);
    };
    var iter_succ = function (f, g, v) {
      return Curry._2(S.iter, f, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_succ"));
    };
    var fold_succ = function (f, g, v) {
      return Curry._2(S.fold, f, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_succ"));
    };
    var iter_succ_e = function (f, g, v) {
      return iter_succ((function (v2) {
                    return Curry._1(f, [
                                v,
                                v2
                              ]);
                  }), g, v);
    };
    var fold_succ_e = function (f, g, v) {
      return fold_succ((function (v2) {
                    return Curry._1(f, [
                                v,
                                v2
                              ]);
                  }), g, v);
    };
    var succ = function (g, v) {
      return Curry._1(S.elements, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] succ"));
    };
    var succ_e = function (g, v) {
      return Curry._1(fold_succ_e((function (e, l) {
                        return {
                                hd: e,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var map_vertex = function (f) {
      return Curry._1(HM$1.map, (function (v, s) {
                    return [
                            Curry._1(f, v),
                            Curry._3(S.fold, (function (v, s) {
                                    return Curry._2(S.add, Curry._1(f, v), s);
                                  }), s, S.empty)
                          ];
                  }));
    };
    var PE;
    var iter_edges = function (f) {
      return Curry._1(HM$1.iter, (function (v) {
                    return Curry._1(S.iter, Curry._1(f, v));
                  }));
    };
    var fold_edges = function (f) {
      return Curry._1(HM$1.fold, (function (v) {
                    return Curry._1(S.fold, Curry._1(f, v));
                  }));
    };
    var iter_edges_e = function (f) {
      return Curry._1(HM$1.iter, (function (v) {
                    return Curry._1(S.iter, (function (param) {
                                  return Curry._1(f, [
                                              v,
                                              param
                                            ]);
                                }));
                  }));
    };
    var fold_edges_e = function (f) {
      return Curry._1(HM$1.fold, (function (v) {
                    return Curry._1(S.fold, (function (param, param$1) {
                                  return Curry._2(f, [
                                              v,
                                              param
                                            ], param$1);
                                }));
                  }));
    };
    var I = {
      PV: V$2,
      PE: PE,
      iter_edges: iter_edges,
      fold_edges: fold_edges,
      iter_edges_e: iter_edges_e,
      fold_edges_e: fold_edges_e
    };
    var mem_vertex = HM$1.mem;
    var S_PE = {
      compare: compare,
      src: src,
      dst: dst,
      create: create$1,
      label: label$1
    };
    var iter_pred = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred");
      }
      return Curry._1(iter_edges(function (v1, v2) {
                      if (Curry._2(V$2.equal, v, v2)) {
                        return Curry._1(f, v1);
                      }
                      
                    }), g);
    };
    var fold_pred = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred");
      }
      return Curry._1(fold_edges(function (v1, v2, a) {
                      if (Curry._2(V$2.equal, v, v2)) {
                        return Curry._2(f, v1, a);
                      } else {
                        return a;
                      }
                    }), g);
    };
    var pred = function (g, v) {
      return Curry._1(fold_pred((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var in_degree = function (g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] in_degree");
      }
      return Curry._1(fold_pred((function (param, n) {
                        return n + 1 | 0;
                      }), g, v), 0);
    };
    var iter_pred_e = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
      }
      return Curry._1(iter_edges_e(function (e) {
                      if (Curry._2(V$2.equal, v, Curry._1(S_PE.dst, e))) {
                        return Curry._1(f, e);
                      }
                      
                    }), g);
    };
    var fold_pred_e = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
      }
      return Curry._1(fold_edges_e(function (e, a) {
                      if (Curry._2(V$2.equal, v, Curry._1(S_PE.dst, e))) {
                        return Curry._2(f, e, a);
                      } else {
                        return a;
                      }
                    }), g);
    };
    var pred_e = function (g, v) {
      return Curry._1(fold_pred_e((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var S$1 = S;
    var mem_edge$1 = mem_edge;
    var nb_vertex = function (g) {
      return Curry._3(HM$1.fold, (function (param, param$1) {
                    return function (prim) {
                      return prim + 1 | 0;
                    };
                  }), g, 0);
    };
    var nb_edges = function (g) {
      return Curry._3(HM$1.fold, (function (param, s, n) {
                    return n + Curry._1(S$1.cardinal, s) | 0;
                  }), g, 0);
    };
    var out_degree = function (g, v) {
      var tmp;
      try {
        tmp = Curry._2(HM$1.find, v, g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          tmp = Pervasives.invalid_arg("[ocamlgraph] out_degree");
        } else {
          throw exn;
        }
      }
      return Curry._1(S$1.cardinal, tmp);
    };
    var mem_vertex$1 = function (g, v) {
      return Curry._2(HM$1.mem, v, g);
    };
    var unsafe_add_vertex = function (g, v) {
      return Curry._3(HM$1.add, v, S$1.empty, g);
    };
    var unsafe_add_edge = function (g, v1, v2) {
      return Curry._3(HM$1.add, v1, Curry._2(S$1.add, v2, Curry._2(HM$1.find, v1, g)), g);
    };
    var add_vertex = function (g, v) {
      if (Curry._2(HM$1.mem, v, g)) {
        return g;
      } else {
        return Curry._3(HM$1.add, v, S$1.empty, g);
      }
    };
    var iter_vertex = function (f) {
      return Curry._1(HM$1.iter, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var fold_vertex = function (f) {
      return Curry._1(HM$1.fold, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var include_empty = HM$1.empty;
    var include_create = HM$1.create;
    var include_is_empty = HM$1.is_empty;
    var include_copy = HM$1.copy;
    var include_clear = HM$1.clear;
    var include$1 = {
      is_directed: true,
      empty: include_empty,
      create: include_create,
      is_empty: include_is_empty,
      copy: include_copy,
      clear: include_clear,
      nb_vertex: nb_vertex,
      nb_edges: nb_edges,
      out_degree: out_degree,
      mem_vertex: mem_vertex$1,
      unsafe_add_vertex: unsafe_add_vertex,
      unsafe_add_edge: unsafe_add_edge,
      add_vertex: add_vertex,
      iter_vertex: iter_vertex,
      fold_vertex: fold_vertex
    };
    var unsafe_add_edge$1 = unsafe_add_edge;
    var add_vertex$1 = add_vertex;
    var add_edge = function (g, v1, v2) {
      if (Curry._3(mem_edge$1, g, v1, v2)) {
        return g;
      }
      var g$1 = Curry._2(add_vertex$1, g, v1);
      var g$2 = Curry._2(add_vertex$1, g$1, v2);
      return Curry._3(unsafe_add_edge$1, g$2, v1, v2);
    };
    var add_edge_e = function (g, param) {
      return add_edge(g, param[0], param[1]);
    };
    return {
            V: V$2,
            HM: HM$1,
            S: S$1,
            E: E,
            mem_edge: mem_edge$1,
            mem_edge_e: mem_edge_e,
            find_edge: find_edge,
            find_all_edges: find_all_edges,
            unsafe_remove_edge: unsafe_remove_edge,
            unsafe_remove_edge_e: unsafe_remove_edge_e,
            remove_edge: remove_edge,
            remove_edge_e: remove_edge_e,
            iter_succ: iter_succ,
            fold_succ: fold_succ,
            iter_succ_e: iter_succ_e,
            fold_succ_e: fold_succ_e,
            succ: succ,
            succ_e: succ_e,
            map_vertex: map_vertex,
            I: I,
            PV: V$2,
            PE: PE,
            iter_edges: iter_edges,
            fold_edges: fold_edges,
            iter_edges_e: iter_edges_e,
            fold_edges_e: fold_edges_e,
            iter_pred: iter_pred,
            fold_pred: fold_pred,
            pred: pred,
            in_degree: in_degree,
            iter_pred_e: iter_pred_e,
            fold_pred_e: fold_pred_e,
            pred_e: pred_e,
            is_directed: include$1.is_directed,
            empty: include_empty,
            create: include_create,
            is_empty: include_is_empty,
            copy: include_copy,
            clear: include_clear,
            nb_vertex: nb_vertex,
            nb_edges: nb_edges,
            out_degree: out_degree,
            mem_vertex: mem_vertex$1,
            unsafe_add_vertex: unsafe_add_vertex,
            unsafe_add_edge: unsafe_add_edge$1,
            add_vertex: add_vertex$1,
            iter_vertex: iter_vertex,
            fold_vertex: fold_vertex,
            add_edge: add_edge,
            add_edge_e: add_edge_e
          };
  };
  var ConcreteBidirectional = function (V) {
    var label = function (v) {
      return v;
    };
    var create = function (v) {
      return v;
    };
    var V_compare = V.compare;
    var V_hash = V.hash;
    var V_equal = V.equal;
    var V$1 = {
      compare: V_compare,
      hash: V_hash,
      equal: V_equal,
      label: label,
      create: create
    };
    var HM = Curry._1(F, V$1);
    var V$2 = V$1;
    var HM$1 = HM;
    var S = $$Set.Make(V$2);
    var include = Util.OTProduct(V$2, V$2);
    var src = function (prim) {
      return prim[0];
    };
    var dst = function (prim) {
      return prim[1];
    };
    var label$1 = function (param) {
      
    };
    var create$1 = function (v1, param, v2) {
      return [
              v1,
              v2
            ];
    };
    var E_compare = include.compare;
    var E = {
      compare: E_compare,
      src: src,
      dst: dst,
      label: label$1,
      create: create$1
    };
    var mem_edge = function (g, v1, v2) {
      try {
        return Curry._2(S.mem, v2, Curry._2(HM$1.find, v1, g)[1]);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var mem_edge_e = function (g, param) {
      return mem_edge(g, param[0], param[1]);
    };
    var find_edge = function (g, v1, v2) {
      if (mem_edge(g, v1, v2)) {
        return [
                v1,
                v2
              ];
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    };
    var find_all_edges = function (g, v1, v2) {
      try {
        return {
                hd: find_edge(g, v1, v2),
                tl: /* [] */0
              };
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return /* [] */0;
        }
        throw exn;
      }
    };
    var unsafe_remove_edge = function (g, v1, v2) {
      var match = Curry._2(HM$1.find, v1, g);
      var g$1 = Curry._3(HM$1.add, v1, [
            match[0],
            Curry._2(S.remove, v2, match[1])
          ], g);
      var match$1 = Curry._2(HM$1.find, v2, g$1);
      return Curry._3(HM$1.add, v2, [
                  Curry._2(S.remove, v1, match$1[0]),
                  match$1[1]
                ], g$1);
    };
    var unsafe_remove_edge_e = function (g, param) {
      return unsafe_remove_edge(g, param[0], param[1]);
    };
    var remove_edge = function (g, v1, v2) {
      if (!(Curry._2(HM$1.mem, v2, g) && Curry._2(HM$1.mem, v1, g))) {
        Pervasives.invalid_arg("[ocamlgraph] remove_edge");
      }
      return unsafe_remove_edge(g, v1, v2);
    };
    var remove_edge_e = function (g, param) {
      return remove_edge(g, param[0], param[1]);
    };
    var iter_succ = function (f, g, v) {
      return Curry._2(S.iter, f, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_succ")[1]);
    };
    var fold_succ = function (f, g, v) {
      return Curry._2(S.fold, f, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_succ")[1]);
    };
    var iter_succ_e = function (f, g, v) {
      return iter_succ((function (v2) {
                    return Curry._1(f, [
                                v,
                                v2
                              ]);
                  }), g, v);
    };
    var fold_succ_e = function (f, g, v) {
      return fold_succ((function (v2) {
                    return Curry._1(f, [
                                v,
                                v2
                              ]);
                  }), g, v);
    };
    var succ = function (g, v) {
      return Curry._1(S.elements, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] succ")[1]);
    };
    var succ_e = function (g, v) {
      return Curry._1(fold_succ_e((function (e, l) {
                        return {
                                hd: e,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var map_vertex = function (f) {
      return Curry._1(HM$1.map, (function (v, param) {
                    return [
                            Curry._1(f, v),
                            [
                              Curry._3(S.fold, (function (v, s) {
                                      return Curry._2(S.add, Curry._1(f, v), s);
                                    }), param[0], S.empty),
                              Curry._3(S.fold, (function (v, s) {
                                      return Curry._2(S.add, Curry._1(f, v), s);
                                    }), param[1], S.empty)
                            ]
                          ];
                  }));
    };
    var PE;
    var iter_edges = function (f) {
      return Curry._1(HM$1.iter, (function (v, param) {
                    return Curry._2(S.iter, Curry._1(f, v), param[1]);
                  }));
    };
    var fold_edges = function (f) {
      return Curry._1(HM$1.fold, (function (v, param) {
                    return Curry._2(S.fold, Curry._1(f, v), param[1]);
                  }));
    };
    var iter_edges_e = function (f) {
      return iter_edges(function (v1, v2) {
                  return Curry._1(f, [
                              v1,
                              v2
                            ]);
                });
    };
    var fold_edges_e = function (f) {
      return fold_edges(function (v1, v2, a) {
                  return Curry._2(f, [
                              v1,
                              v2
                            ], a);
                });
    };
    var I = {
      PV: V$2,
      PE: PE,
      iter_edges: iter_edges,
      fold_edges: fold_edges,
      iter_edges_e: iter_edges_e,
      fold_edges_e: fold_edges_e
    };
    var iter_pred = function (f, g, v) {
      return Curry._2(S.iter, f, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_pred")[0]);
    };
    var fold_pred = function (f, g, v) {
      return Curry._2(S.fold, f, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_pred")[0]);
    };
    var pred = function (g, v) {
      return Curry._1(S.elements, Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] pred")[0]);
    };
    var in_degree = function (g, v) {
      var tmp;
      try {
        tmp = Curry._2(HM$1.find, v, g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          tmp = Pervasives.invalid_arg("[ocamlgraph] in_degree");
        } else {
          throw exn;
        }
      }
      return Curry._1(S.cardinal, tmp[0]);
    };
    var iter_pred_e = function (f, g, v) {
      return iter_pred((function (v2) {
                    return Curry._1(f, [
                                v2,
                                v
                              ]);
                  }), g, v);
    };
    var fold_pred_e = function (f, g, v) {
      return fold_pred((function (v2) {
                    return Curry._1(f, [
                                v2,
                                v
                              ]);
                  }), g, v);
    };
    var pred_e = function (g, v) {
      return Curry._1(fold_pred_e((function (e, l) {
                        return {
                                hd: e,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var S$1 = S;
    var mem_edge$1 = mem_edge;
    var nb_vertex = function (g) {
      return Curry._3(HM$1.fold, (function (param, param$1) {
                    return function (prim) {
                      return prim + 1 | 0;
                    };
                  }), g, 0);
    };
    var nb_edges = function (g) {
      return Curry._3(HM$1.fold, (function (param, param$1, n) {
                    return n + Curry._1(S$1.cardinal, param$1[1]) | 0;
                  }), g, 0);
    };
    var out_degree = function (g, v) {
      var tmp;
      try {
        tmp = Curry._2(HM$1.find, v, g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          tmp = Pervasives.invalid_arg("[ocamlgraph] out_degree");
        } else {
          throw exn;
        }
      }
      return Curry._1(S$1.cardinal, tmp[1]);
    };
    var mem_vertex = function (g, v) {
      return Curry._2(HM$1.mem, v, g);
    };
    var unsafe_add_vertex = function (g, v) {
      return Curry._3(HM$1.add, v, [
                  S$1.empty,
                  S$1.empty
                ], g);
    };
    var add_vertex = function (g, v) {
      if (Curry._2(HM$1.mem, v, g)) {
        return g;
      } else {
        return unsafe_add_vertex(g, v);
      }
    };
    var iter_vertex = function (f) {
      return Curry._1(HM$1.iter, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var fold_vertex = function (f) {
      return Curry._1(HM$1.fold, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var include_empty = HM$1.empty;
    var include_create = HM$1.create;
    var include_clear = HM$1.clear;
    var include_is_empty = HM$1.is_empty;
    var include_copy = HM$1.copy;
    var include$1 = {
      is_directed: true,
      empty: include_empty,
      create: include_create,
      clear: include_clear,
      is_empty: include_is_empty,
      copy: include_copy,
      nb_vertex: nb_vertex,
      nb_edges: nb_edges,
      out_degree: out_degree,
      mem_vertex: mem_vertex,
      unsafe_add_vertex: unsafe_add_vertex,
      add_vertex: add_vertex,
      iter_vertex: iter_vertex,
      fold_vertex: fold_vertex
    };
    var unsafe_add_edge = function (g, v1, v2) {
      var find = function (v, g) {
        try {
          return Curry._2(HM$1.find, v, g);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Not_found") {
            return [
                    S$1.empty,
                    S$1.empty
                  ];
          }
          throw exn;
        }
      };
      var match = find(v1, g);
      var g$1 = Curry._3(HM$1.add, v1, [
            match[0],
            Curry._2(S$1.add, v2, match[1])
          ], g);
      var match$1 = find(v2, g$1);
      return Curry._3(HM$1.add, v2, [
                  Curry._2(S$1.add, v1, match$1[0]),
                  match$1[1]
                ], g$1);
    };
    var add_edge = function (g, v1, v2) {
      if (Curry._3(mem_edge$1, g, v1, v2)) {
        return g;
      } else {
        return unsafe_add_edge(g, v1, v2);
      }
    };
    var add_edge_e = function (g, param) {
      return add_edge(g, param[0], param[1]);
    };
    return {
            V: V$2,
            HM: HM$1,
            S: S$1,
            E: E,
            mem_edge: mem_edge$1,
            mem_edge_e: mem_edge_e,
            find_edge: find_edge,
            find_all_edges: find_all_edges,
            unsafe_remove_edge: unsafe_remove_edge,
            unsafe_remove_edge_e: unsafe_remove_edge_e,
            remove_edge: remove_edge,
            remove_edge_e: remove_edge_e,
            iter_succ: iter_succ,
            fold_succ: fold_succ,
            iter_succ_e: iter_succ_e,
            fold_succ_e: fold_succ_e,
            succ: succ,
            succ_e: succ_e,
            map_vertex: map_vertex,
            I: I,
            PV: V$2,
            PE: PE,
            iter_edges: iter_edges,
            fold_edges: fold_edges,
            iter_edges_e: iter_edges_e,
            fold_edges_e: fold_edges_e,
            iter_pred: iter_pred,
            fold_pred: fold_pred,
            pred: pred,
            in_degree: in_degree,
            iter_pred_e: iter_pred_e,
            fold_pred_e: fold_pred_e,
            pred_e: pred_e,
            is_directed: include$1.is_directed,
            empty: include_empty,
            create: include_create,
            clear: include_clear,
            is_empty: include_is_empty,
            copy: include_copy,
            nb_vertex: nb_vertex,
            nb_edges: nb_edges,
            out_degree: out_degree,
            mem_vertex: mem_vertex,
            unsafe_add_vertex: unsafe_add_vertex,
            add_vertex: add_vertex,
            iter_vertex: iter_vertex,
            fold_vertex: fold_vertex,
            unsafe_add_edge: unsafe_add_edge,
            add_edge: add_edge,
            add_edge_e: add_edge_e
          };
  };
  var ConcreteLabeled = function (V, Edge) {
    var label = function (v) {
      return v;
    };
    var create = function (v) {
      return v;
    };
    var V_compare = V.compare;
    var V_hash = V.hash;
    var V_equal = V.equal;
    var V$1 = {
      compare: V_compare,
      hash: V_hash,
      equal: V_equal,
      label: label,
      create: create
    };
    var HM = Curry._1(F, V$1);
    var V$2 = V$1;
    var HM$1 = HM;
    var VE = Util.OTProduct(V$2, Edge);
    var S = $$Set.Make(VE);
    var src = function (param) {
      return param[0];
    };
    var dst = function (param) {
      return param[2];
    };
    var label$1 = function (param) {
      return param[1];
    };
    var create$1 = function (v1, l, v2) {
      return [
              v1,
              l,
              v2
            ];
    };
    var C = Util.OTProduct(V$2, VE);
    var compare = function (param, param$1) {
      return Curry._2(C.compare, [
                  param[0],
                  [
                    param[2],
                    param[1]
                  ]
                ], [
                  param$1[0],
                  [
                    param$1[2],
                    param$1[1]
                  ]
                ]);
    };
    var E = {
      src: src,
      dst: dst,
      label: label$1,
      create: create$1,
      C: C,
      compare: compare
    };
    var mem_edge = function (g, v1, v2) {
      try {
        return Curry._2(S.exists, (function (param) {
                      return Curry._2(V$2.equal, v2, param[0]);
                    }), Curry._2(HM$1.find, v1, g));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var mem_edge_e = function (g, param) {
      try {
        var ve_0 = param[2];
        var ve_1 = param[1];
        var ve = [
          ve_0,
          ve_1
        ];
        return Curry._2(S.exists, (function (ve$p) {
                      return Curry._2(VE.compare, ve, ve$p) === 0;
                    }), Curry._2(HM$1.find, param[0], g));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var Found = /* @__PURE__ */Caml_exceptions.create("Blocks.Labeled(V)(E)(HM).Found");
    var find_edge = function (g, v1, v2) {
      try {
        Curry._2(S.iter, (function (param) {
                var v2$p = param[0];
                if (!Curry._2(V$2.equal, v2, v2$p)) {
                  return ;
                }
                throw {
                      RE_EXN_ID: Found,
                      _1: [
                        v1,
                        param[1],
                        v2$p
                      ],
                      Error: new Error()
                    };
              }), Curry._2(HM$1.find, v1, g));
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      catch (raw_e){
        var e = Caml_js_exceptions.internalToOCamlException(raw_e);
        if (e.RE_EXN_ID === Found) {
          return e._1;
        }
        throw e;
      }
    };
    var find_all_edges = function (g, v1, v2) {
      try {
        return Curry._3(S.fold, (function (param, acc) {
                      var v2$p = param[0];
                      if (Curry._2(V$2.equal, v2, v2$p)) {
                        return {
                                hd: [
                                  v1,
                                  param[1],
                                  v2$p
                                ],
                                tl: acc
                              };
                      } else {
                        return acc;
                      }
                    }), Curry._2(HM$1.find, v1, g), /* [] */0);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return /* [] */0;
        }
        throw exn;
      }
    };
    var unsafe_remove_edge = function (g, v1, v2) {
      return Curry._3(HM$1.add, v1, Curry._2(S.filter, (function (param) {
                        return !Curry._2(V$2.equal, v2, param[0]);
                      }), Curry._2(HM$1.find, v1, g)), g);
    };
    var unsafe_remove_edge_e = function (g, param) {
      var v1 = param[0];
      return Curry._3(HM$1.add, v1, Curry._2(S.remove, [
                      param[2],
                      param[1]
                    ], Curry._2(HM$1.find, v1, g)), g);
    };
    var remove_edge = function (g, v1, v2) {
      if (!Curry._2(HM$1.mem, v2, g)) {
        Pervasives.invalid_arg("[ocamlgraph] remove_edge");
      }
      return Curry._3(HM$1.add, v1, Curry._2(S.filter, (function (param) {
                        return !Curry._2(V$2.equal, v2, param[0]);
                      }), Curry._3(HM$1.find_and_raise, v1, g, "[ocamlgraph] remove_edge")), g);
    };
    var remove_edge_e = function (g, param) {
      var v2 = param[2];
      var v1 = param[0];
      if (!Curry._2(HM$1.mem, v2, g)) {
        Pervasives.invalid_arg("[ocamlgraph] remove_edge_e");
      }
      return Curry._3(HM$1.add, v1, Curry._2(S.remove, [
                      v2,
                      param[1]
                    ], Curry._3(HM$1.find_and_raise, v1, g, "[ocamlgraph] remove_edge_e")), g);
    };
    var iter_succ = function (f, g, v) {
      return Curry._2(S.iter, (function (param) {
                    return Curry._1(f, param[0]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_succ"));
    };
    var fold_succ = function (f, g, v) {
      return Curry._2(S.fold, (function (param) {
                    return Curry._1(f, param[0]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_succ"));
    };
    var iter_succ_e = function (f, g, v) {
      return Curry._2(S.iter, (function (param) {
                    return Curry._1(f, [
                                v,
                                param[1],
                                param[0]
                              ]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_succ_e"));
    };
    var fold_succ_e = function (f, g, v) {
      return Curry._2(S.fold, (function (param) {
                    return Curry._1(f, [
                                v,
                                param[1],
                                param[0]
                              ]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_succ_e"));
    };
    var succ = function (g, v) {
      return Curry._1(fold_succ((function (w, l) {
                        return {
                                hd: w,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var succ_e = function (g, v) {
      return Curry._1(fold_succ_e((function (e, l) {
                        return {
                                hd: e,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var map_vertex = function (f) {
      return Curry._1(HM$1.map, (function (v, s) {
                    return [
                            Curry._1(f, v),
                            Curry._3(S.fold, (function (param, s) {
                                    return Curry._2(S.add, [
                                                Curry._1(f, param[0]),
                                                param[1]
                                              ], s);
                                  }), s, S.empty)
                          ];
                  }));
    };
    var PE;
    var iter_edges = function (f) {
      return Curry._1(HM$1.iter, (function (v) {
                    return Curry._1(S.iter, (function (param) {
                                  return Curry._2(f, v, param[0]);
                                }));
                  }));
    };
    var fold_edges = function (f) {
      return Curry._1(HM$1.fold, (function (v) {
                    return Curry._1(S.fold, (function (param) {
                                  return Curry._2(f, v, param[0]);
                                }));
                  }));
    };
    var iter_edges_e = function (f) {
      return Curry._1(HM$1.iter, (function (v) {
                    return Curry._1(S.iter, (function (param) {
                                  return Curry._1(f, [
                                              v,
                                              param[1],
                                              param[0]
                                            ]);
                                }));
                  }));
    };
    var fold_edges_e = function (f) {
      return Curry._1(HM$1.fold, (function (v) {
                    return Curry._1(S.fold, (function (param) {
                                  return Curry._1(f, [
                                              v,
                                              param[1],
                                              param[0]
                                            ]);
                                }));
                  }));
    };
    var I = {
      PV: V$2,
      PE: PE,
      iter_edges: iter_edges,
      fold_edges: fold_edges,
      iter_edges_e: iter_edges_e,
      fold_edges_e: fold_edges_e
    };
    var mem_vertex = HM$1.mem;
    var S_PE = {
      compare: compare,
      src: src,
      dst: dst,
      create: create$1,
      label: label$1
    };
    var iter_pred = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred");
      }
      return Curry._1(iter_edges(function (v1, v2) {
                      if (Curry._2(V$2.equal, v, v2)) {
                        return Curry._1(f, v1);
                      }
                      
                    }), g);
    };
    var fold_pred = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred");
      }
      return Curry._1(fold_edges(function (v1, v2, a) {
                      if (Curry._2(V$2.equal, v, v2)) {
                        return Curry._2(f, v1, a);
                      } else {
                        return a;
                      }
                    }), g);
    };
    var pred = function (g, v) {
      return Curry._1(fold_pred((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var in_degree = function (g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] in_degree");
      }
      return Curry._1(fold_pred((function (param, n) {
                        return n + 1 | 0;
                      }), g, v), 0);
    };
    var iter_pred_e = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
      }
      return Curry._1(iter_edges_e(function (e) {
                      if (Curry._2(V$2.equal, v, Curry._1(S_PE.dst, e))) {
                        return Curry._1(f, e);
                      }
                      
                    }), g);
    };
    var fold_pred_e = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
      }
      return Curry._1(fold_edges_e(function (e, a) {
                      if (Curry._2(V$2.equal, v, Curry._1(S_PE.dst, e))) {
                        return Curry._2(f, e, a);
                      } else {
                        return a;
                      }
                    }), g);
    };
    var pred_e = function (g, v) {
      return Curry._1(fold_pred_e((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var S$1 = S;
    var mem_edge_e$1 = mem_edge_e;
    var nb_vertex = function (g) {
      return Curry._3(HM$1.fold, (function (param, param$1) {
                    return function (prim) {
                      return prim + 1 | 0;
                    };
                  }), g, 0);
    };
    var nb_edges = function (g) {
      return Curry._3(HM$1.fold, (function (param, s, n) {
                    return n + Curry._1(S$1.cardinal, s) | 0;
                  }), g, 0);
    };
    var out_degree = function (g, v) {
      var tmp;
      try {
        tmp = Curry._2(HM$1.find, v, g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          tmp = Pervasives.invalid_arg("[ocamlgraph] out_degree");
        } else {
          throw exn;
        }
      }
      return Curry._1(S$1.cardinal, tmp);
    };
    var mem_vertex$1 = function (g, v) {
      return Curry._2(HM$1.mem, v, g);
    };
    var unsafe_add_vertex = function (g, v) {
      return Curry._3(HM$1.add, v, S$1.empty, g);
    };
    var unsafe_add_edge = function (g, v1, v2) {
      return Curry._3(HM$1.add, v1, Curry._2(S$1.add, v2, Curry._2(HM$1.find, v1, g)), g);
    };
    var add_vertex = function (g, v) {
      if (Curry._2(HM$1.mem, v, g)) {
        return g;
      } else {
        return Curry._3(HM$1.add, v, S$1.empty, g);
      }
    };
    var iter_vertex = function (f) {
      return Curry._1(HM$1.iter, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var fold_vertex = function (f) {
      return Curry._1(HM$1.fold, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var include_empty = HM$1.empty;
    var include_create = HM$1.create;
    var include_is_empty = HM$1.is_empty;
    var include_copy = HM$1.copy;
    var include_clear = HM$1.clear;
    var include = {
      is_directed: true,
      empty: include_empty,
      create: include_create,
      is_empty: include_is_empty,
      copy: include_copy,
      clear: include_clear,
      nb_vertex: nb_vertex,
      nb_edges: nb_edges,
      out_degree: out_degree,
      mem_vertex: mem_vertex$1,
      unsafe_add_vertex: unsafe_add_vertex,
      unsafe_add_edge: unsafe_add_edge,
      add_vertex: add_vertex,
      iter_vertex: iter_vertex,
      fold_vertex: fold_vertex
    };
    var unsafe_add_edge$1 = unsafe_add_edge;
    var add_vertex$1 = add_vertex;
    var add_edge_e = function (g, e) {
      var v2 = e[2];
      var v1 = e[0];
      if (Curry._2(mem_edge_e$1, g, e)) {
        return g;
      }
      var g$1 = Curry._2(add_vertex$1, g, v1);
      var g$2 = Curry._2(add_vertex$1, g$1, v2);
      return Curry._3(unsafe_add_edge$1, g$2, v1, [
                  v2,
                  e[1]
                ]);
    };
    var add_edge = function (g, v1, v2) {
      return add_edge_e(g, [
                  v1,
                  Edge.$$default,
                  v2
                ]);
    };
    return {
            V: V$2,
            HM: HM$1,
            VE: VE,
            S: S$1,
            E: E,
            mem_edge: mem_edge,
            mem_edge_e: mem_edge_e$1,
            Found: Found,
            find_edge: find_edge,
            find_all_edges: find_all_edges,
            unsafe_remove_edge: unsafe_remove_edge,
            unsafe_remove_edge_e: unsafe_remove_edge_e,
            remove_edge: remove_edge,
            remove_edge_e: remove_edge_e,
            iter_succ: iter_succ,
            fold_succ: fold_succ,
            iter_succ_e: iter_succ_e,
            fold_succ_e: fold_succ_e,
            succ: succ,
            succ_e: succ_e,
            map_vertex: map_vertex,
            I: I,
            PV: V$2,
            PE: PE,
            iter_edges: iter_edges,
            fold_edges: fold_edges,
            iter_edges_e: iter_edges_e,
            fold_edges_e: fold_edges_e,
            iter_pred: iter_pred,
            fold_pred: fold_pred,
            pred: pred,
            in_degree: in_degree,
            iter_pred_e: iter_pred_e,
            fold_pred_e: fold_pred_e,
            pred_e: pred_e,
            is_directed: include.is_directed,
            empty: include_empty,
            create: include_create,
            is_empty: include_is_empty,
            copy: include_copy,
            clear: include_clear,
            nb_vertex: nb_vertex,
            nb_edges: nb_edges,
            out_degree: out_degree,
            mem_vertex: mem_vertex$1,
            unsafe_add_vertex: unsafe_add_vertex,
            unsafe_add_edge: unsafe_add_edge$1,
            add_vertex: add_vertex$1,
            iter_vertex: iter_vertex,
            fold_vertex: fold_vertex,
            add_edge_e: add_edge_e,
            add_edge: add_edge
          };
  };
  var ConcreteBidirectionalLabeled = function (V, Edge) {
    var label = function (v) {
      return v;
    };
    var create = function (v) {
      return v;
    };
    var V_compare = V.compare;
    var V_hash = V.hash;
    var V_equal = V.equal;
    var V$1 = {
      compare: V_compare,
      hash: V_hash,
      equal: V_equal,
      label: label,
      create: create
    };
    var HM = Curry._1(F, V$1);
    var V$2 = V$1;
    var HM$1 = HM;
    var VE = Util.OTProduct(V$2, Edge);
    var S = $$Set.Make(VE);
    var src = function (param) {
      return param[0];
    };
    var dst = function (param) {
      return param[2];
    };
    var label$1 = function (param) {
      return param[1];
    };
    var create$1 = function (v1, l, v2) {
      return [
              v1,
              l,
              v2
            ];
    };
    var C = Util.OTProduct(V$2, VE);
    var compare = function (param, param$1) {
      return Curry._2(C.compare, [
                  param[0],
                  [
                    param[2],
                    param[1]
                  ]
                ], [
                  param$1[0],
                  [
                    param$1[2],
                    param$1[1]
                  ]
                ]);
    };
    var E = {
      src: src,
      dst: dst,
      label: label$1,
      create: create$1,
      C: C,
      compare: compare
    };
    var mem_edge = function (g, v1, v2) {
      try {
        return Curry._2(S.exists, (function (param) {
                      return Curry._2(V$2.equal, v2, param[0]);
                    }), Curry._2(HM$1.find, v1, g)[1]);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var mem_edge_e = function (g, param) {
      try {
        var ve_0 = param[2];
        var ve_1 = param[1];
        var ve = [
          ve_0,
          ve_1
        ];
        return Curry._2(S.exists, (function (ve$p) {
                      return Curry._2(VE.compare, ve, ve$p) === 0;
                    }), Curry._2(HM$1.find, param[0], g)[1]);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var Found = /* @__PURE__ */Caml_exceptions.create("Blocks.BidirectionalLabeled(V)(E)(HM).Found");
    var find_edge = function (g, v1, v2) {
      try {
        Curry._2(S.iter, (function (param) {
                var v2$p = param[0];
                if (!Curry._2(V$2.equal, v2, v2$p)) {
                  return ;
                }
                throw {
                      RE_EXN_ID: Found,
                      _1: [
                        v1,
                        param[1],
                        v2$p
                      ],
                      Error: new Error()
                    };
              }), Curry._2(HM$1.find, v1, g)[1]);
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      catch (raw_e){
        var e = Caml_js_exceptions.internalToOCamlException(raw_e);
        if (e.RE_EXN_ID === Found) {
          return e._1;
        }
        throw e;
      }
    };
    var find_all_edges = function (g, v1, v2) {
      try {
        return Curry._3(S.fold, (function (param, acc) {
                      var v2$p = param[0];
                      if (Curry._2(V$2.equal, v2, v2$p)) {
                        return {
                                hd: [
                                  v1,
                                  param[1],
                                  v2$p
                                ],
                                tl: acc
                              };
                      } else {
                        return acc;
                      }
                    }), Curry._2(HM$1.find, v1, g)[1], /* [] */0);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return /* [] */0;
        }
        throw exn;
      }
    };
    var unsafe_remove_edge = function (g, v1, v2) {
      var match = Curry._2(HM$1.find, v1, g);
      var del = function (v, set) {
        return Curry._2(S.filter, (function (param) {
                      return !Curry._2(V$2.equal, v, param[0]);
                    }), set);
      };
      var g$1 = Curry._3(HM$1.add, v1, [
            match[0],
            del(v2, match[1])
          ], g);
      var match$1 = Curry._2(HM$1.find, v2, g$1);
      return Curry._3(HM$1.add, v2, [
                  del(v1, match$1[0]),
                  match$1[1]
                ], g$1);
    };
    var unsafe_remove_edge_e = function (g, param) {
      var v2 = param[2];
      var l = param[1];
      var v1 = param[0];
      var match = Curry._2(HM$1.find, v1, g);
      var g$1 = Curry._3(HM$1.add, v1, [
            match[0],
            Curry._2(S.remove, [
                  v2,
                  l
                ], match[1])
          ], g);
      var match$1 = Curry._2(HM$1.find, v2, g$1);
      return Curry._3(HM$1.add, v2, [
                  Curry._2(S.remove, [
                        v1,
                        l
                      ], match$1[0]),
                  match$1[1]
                ], g$1);
    };
    var remove_edge = function (g, v1, v2) {
      var match = Curry._3(HM$1.find_and_raise, v1, g, "[ocamlgraph] remove_edge");
      var del = function (v, set) {
        return Curry._2(S.filter, (function (param) {
                      return !Curry._2(V$2.equal, v, param[0]);
                    }), set);
      };
      var g$1 = Curry._3(HM$1.add, v1, [
            match[0],
            del(v2, match[1])
          ], g);
      var match$1 = Curry._3(HM$1.find_and_raise, v2, g$1, "[ocamlgraph] remove_edge");
      return Curry._3(HM$1.add, v2, [
                  del(v1, match$1[0]),
                  match$1[1]
                ], g$1);
    };
    var remove_edge_e = function (g, param) {
      var v2 = param[2];
      var l = param[1];
      var v1 = param[0];
      var match = Curry._3(HM$1.find_and_raise, v1, g, "[ocamlgraph] remove_edge_e");
      var g$1 = Curry._3(HM$1.add, v1, [
            match[0],
            Curry._2(S.remove, [
                  v2,
                  l
                ], match[1])
          ], g);
      var match$1 = Curry._3(HM$1.find_and_raise, v2, g$1, "[ocamlgraph] remove_edge_e");
      return Curry._3(HM$1.add, v2, [
                  Curry._2(S.remove, [
                        v1,
                        l
                      ], match$1[0]),
                  match$1[1]
                ], g$1);
    };
    var iter_succ = function (f, g, v) {
      return Curry._2(S.iter, (function (param) {
                    return Curry._1(f, param[0]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_succ")[1]);
    };
    var fold_succ = function (f, g, v) {
      return Curry._2(S.fold, (function (param) {
                    return Curry._1(f, param[0]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_succ")[1]);
    };
    var iter_succ_e = function (f, g, v) {
      return Curry._2(S.iter, (function (param) {
                    return Curry._1(f, [
                                v,
                                param[1],
                                param[0]
                              ]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_succ_e")[1]);
    };
    var fold_succ_e = function (f, g, v) {
      return Curry._2(S.fold, (function (param) {
                    return Curry._1(f, [
                                v,
                                param[1],
                                param[0]
                              ]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_succ_e")[1]);
    };
    var succ = function (g, v) {
      return Curry._1(fold_succ((function (w, l) {
                        return {
                                hd: w,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var succ_e = function (g, v) {
      return Curry._1(fold_succ_e((function (e, l) {
                        return {
                                hd: e,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var map_vertex = function (f) {
      return Curry._1(HM$1.map, (function (v, param) {
                    return [
                            Curry._1(f, v),
                            [
                              Curry._3(S.fold, (function (param, s) {
                                      return Curry._2(S.add, [
                                                  Curry._1(f, param[0]),
                                                  param[1]
                                                ], s);
                                    }), param[0], S.empty),
                              Curry._3(S.fold, (function (param, s) {
                                      return Curry._2(S.add, [
                                                  Curry._1(f, param[0]),
                                                  param[1]
                                                ], s);
                                    }), param[1], S.empty)
                            ]
                          ];
                  }));
    };
    var PE;
    var iter_edges = function (f) {
      return Curry._1(HM$1.iter, (function (v, param) {
                    return Curry._2(S.iter, (function (param) {
                                  return Curry._2(f, v, param[0]);
                                }), param[1]);
                  }));
    };
    var fold_edges = function (f) {
      return Curry._1(HM$1.fold, (function (v, param) {
                    return Curry._2(S.fold, (function (param) {
                                  return Curry._2(f, v, param[0]);
                                }), param[1]);
                  }));
    };
    var iter_edges_e = function (f) {
      return Curry._1(HM$1.iter, (function (v, param) {
                    return Curry._2(S.iter, (function (param) {
                                  return Curry._1(f, [
                                              v,
                                              param[1],
                                              param[0]
                                            ]);
                                }), param[1]);
                  }));
    };
    var fold_edges_e = function (f) {
      return Curry._1(HM$1.fold, (function (v, param) {
                    return Curry._2(S.fold, (function (param) {
                                  return Curry._1(f, [
                                              v,
                                              param[1],
                                              param[0]
                                            ]);
                                }), param[1]);
                  }));
    };
    var I = {
      PV: V$2,
      PE: PE,
      iter_edges: iter_edges,
      fold_edges: fold_edges,
      iter_edges_e: iter_edges_e,
      fold_edges_e: fold_edges_e
    };
    var iter_pred = function (f, g, v) {
      return Curry._2(S.iter, (function (param) {
                    return Curry._1(f, param[0]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_pred")[0]);
    };
    var fold_pred = function (f, g, v) {
      return Curry._2(S.fold, (function (param) {
                    return Curry._1(f, param[0]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_pred")[0]);
    };
    var in_degree = function (g, v) {
      var tmp;
      try {
        tmp = Curry._2(HM$1.find, v, g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          tmp = Pervasives.invalid_arg("[ocamlgraph] in_degree");
        } else {
          throw exn;
        }
      }
      return Curry._1(S.cardinal, tmp[0]);
    };
    var iter_pred_e = function (f, g, v) {
      return Curry._2(S.iter, (function (param) {
                    return Curry._1(f, [
                                param[0],
                                param[1],
                                v
                              ]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] iter_pred_e")[0]);
    };
    var fold_pred_e = function (f, g, v) {
      return Curry._2(S.fold, (function (param) {
                    return Curry._1(f, [
                                param[0],
                                param[1],
                                v
                              ]);
                  }), Curry._3(HM$1.find_and_raise, v, g, "[ocamlgraph] fold_pred_e")[0]);
    };
    var pred = function (g, v) {
      return Curry._1(fold_pred((function (w, l) {
                        return {
                                hd: w,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var pred_e = function (g, v) {
      return Curry._1(fold_pred_e((function (e, l) {
                        return {
                                hd: e,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var S$1 = S;
    var mem_edge_e$1 = mem_edge_e;
    var nb_vertex = function (g) {
      return Curry._3(HM$1.fold, (function (param, param$1) {
                    return function (prim) {
                      return prim + 1 | 0;
                    };
                  }), g, 0);
    };
    var nb_edges = function (g) {
      return Curry._3(HM$1.fold, (function (param, param$1, n) {
                    return n + Curry._1(S$1.cardinal, param$1[1]) | 0;
                  }), g, 0);
    };
    var out_degree = function (g, v) {
      var tmp;
      try {
        tmp = Curry._2(HM$1.find, v, g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          tmp = Pervasives.invalid_arg("[ocamlgraph] out_degree");
        } else {
          throw exn;
        }
      }
      return Curry._1(S$1.cardinal, tmp[1]);
    };
    var mem_vertex = function (g, v) {
      return Curry._2(HM$1.mem, v, g);
    };
    var unsafe_add_vertex = function (g, v) {
      return Curry._3(HM$1.add, v, [
                  S$1.empty,
                  S$1.empty
                ], g);
    };
    var add_vertex = function (g, v) {
      if (Curry._2(HM$1.mem, v, g)) {
        return g;
      } else {
        return unsafe_add_vertex(g, v);
      }
    };
    var iter_vertex = function (f) {
      return Curry._1(HM$1.iter, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var fold_vertex = function (f) {
      return Curry._1(HM$1.fold, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var include_empty = HM$1.empty;
    var include_create = HM$1.create;
    var include_clear = HM$1.clear;
    var include_is_empty = HM$1.is_empty;
    var include_copy = HM$1.copy;
    var include = {
      is_directed: true,
      empty: include_empty,
      create: include_create,
      clear: include_clear,
      is_empty: include_is_empty,
      copy: include_copy,
      nb_vertex: nb_vertex,
      nb_edges: nb_edges,
      out_degree: out_degree,
      mem_vertex: mem_vertex,
      unsafe_add_vertex: unsafe_add_vertex,
      add_vertex: add_vertex,
      iter_vertex: iter_vertex,
      fold_vertex: fold_vertex
    };
    var unsafe_add_edge_e = function (g, param) {
      var v2 = param[2];
      var l = param[1];
      var v1 = param[0];
      var find = function (v, g) {
        try {
          return Curry._2(HM$1.find, v, g);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Not_found") {
            return [
                    S$1.empty,
                    S$1.empty
                  ];
          }
          throw exn;
        }
      };
      var match = find(v1, g);
      var g$1 = Curry._3(HM$1.add, v1, [
            match[0],
            Curry._2(S$1.add, [
                  v2,
                  l
                ], match[1])
          ], g);
      var match$1 = find(v2, g$1);
      return Curry._3(HM$1.add, v2, [
                  Curry._2(S$1.add, [
                        v1,
                        l
                      ], match$1[0]),
                  match$1[1]
                ], g$1);
    };
    var add_edge_e = function (g, e) {
      if (Curry._2(mem_edge_e$1, g, e)) {
        return g;
      } else {
        return unsafe_add_edge_e(g, e);
      }
    };
    var add_edge = function (g, v1, v2) {
      return add_edge_e(g, [
                  v1,
                  Edge.$$default,
                  v2
                ]);
    };
    return {
            V: V$2,
            HM: HM$1,
            VE: VE,
            S: S$1,
            E: E,
            mem_edge: mem_edge,
            mem_edge_e: mem_edge_e$1,
            Found: Found,
            find_edge: find_edge,
            find_all_edges: find_all_edges,
            unsafe_remove_edge: unsafe_remove_edge,
            unsafe_remove_edge_e: unsafe_remove_edge_e,
            remove_edge: remove_edge,
            remove_edge_e: remove_edge_e,
            iter_succ: iter_succ,
            fold_succ: fold_succ,
            iter_succ_e: iter_succ_e,
            fold_succ_e: fold_succ_e,
            succ: succ,
            succ_e: succ_e,
            map_vertex: map_vertex,
            I: I,
            PV: V$2,
            PE: PE,
            iter_edges: iter_edges,
            fold_edges: fold_edges,
            iter_edges_e: iter_edges_e,
            fold_edges_e: fold_edges_e,
            iter_pred: iter_pred,
            fold_pred: fold_pred,
            in_degree: in_degree,
            iter_pred_e: iter_pred_e,
            fold_pred_e: fold_pred_e,
            pred: pred,
            pred_e: pred_e,
            is_directed: include.is_directed,
            empty: include_empty,
            create: include_create,
            clear: include_clear,
            is_empty: include_is_empty,
            copy: include_copy,
            nb_vertex: nb_vertex,
            nb_edges: nb_edges,
            out_degree: out_degree,
            mem_vertex: mem_vertex,
            unsafe_add_vertex: unsafe_add_vertex,
            add_vertex: add_vertex,
            iter_vertex: iter_vertex,
            fold_vertex: fold_vertex,
            unsafe_add_edge_e: unsafe_add_edge_e,
            add_edge_e: add_edge_e,
            add_edge: add_edge
          };
  };
  var Abstract = function (V) {
    var HM = Curry._1(F, V);
    var S = $$Set.Make(V);
    var include = Util.OTProduct(V, V);
    var compare = include.compare;
    var src = function (prim) {
      return prim[0];
    };
    var dst = function (prim) {
      return prim[1];
    };
    var label = function (param) {
      
    };
    var create = function (v1, param, v2) {
      return [
              v1,
              v2
            ];
    };
    var E = {
      compare: compare,
      src: src,
      dst: dst,
      label: label,
      create: create
    };
    var mem_edge = function (g, v1, v2) {
      try {
        return Curry._2(S.mem, v2, Curry._2(HM.find, v1, g));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var mem_edge_e = function (g, param) {
      return mem_edge(g, param[0], param[1]);
    };
    var find_edge = function (g, v1, v2) {
      if (mem_edge(g, v1, v2)) {
        return [
                v1,
                v2
              ];
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    };
    var find_all_edges = function (g, v1, v2) {
      try {
        return {
                hd: find_edge(g, v1, v2),
                tl: /* [] */0
              };
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return /* [] */0;
        }
        throw exn;
      }
    };
    var unsafe_remove_edge = function (g, v1, v2) {
      return Curry._3(HM.add, v1, Curry._2(S.remove, v2, Curry._2(HM.find, v1, g)), g);
    };
    var unsafe_remove_edge_e = function (g, param) {
      return unsafe_remove_edge(g, param[0], param[1]);
    };
    var remove_edge = function (g, v1, v2) {
      if (!Curry._2(HM.mem, v2, g)) {
        Pervasives.invalid_arg("[ocamlgraph] remove_edge");
      }
      return Curry._3(HM.add, v1, Curry._2(S.remove, v2, Curry._3(HM.find_and_raise, v1, g, "[ocamlgraph] remove_edge")), g);
    };
    var remove_edge_e = function (g, param) {
      return remove_edge(g, param[0], param[1]);
    };
    var iter_succ = function (f, g, v) {
      return Curry._2(S.iter, f, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ"));
    };
    var fold_succ = function (f, g, v) {
      return Curry._2(S.fold, f, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ"));
    };
    var iter_succ_e = function (f, g, v) {
      return iter_succ((function (v2) {
                    return Curry._1(f, [
                                v,
                                v2
                              ]);
                  }), g, v);
    };
    var fold_succ_e = function (f, g, v) {
      return fold_succ((function (v2) {
                    return Curry._1(f, [
                                v,
                                v2
                              ]);
                  }), g, v);
    };
    var succ = function (g, v) {
      return Curry._1(S.elements, Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] succ"));
    };
    var succ_e = function (g, v) {
      return Curry._1(fold_succ_e((function (e, l) {
                        return {
                                hd: e,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var map_vertex = function (f) {
      return Curry._1(HM.map, (function (v, s) {
                    return [
                            Curry._1(f, v),
                            Curry._3(S.fold, (function (v, s) {
                                    return Curry._2(S.add, Curry._1(f, v), s);
                                  }), s, S.empty)
                          ];
                  }));
    };
    var PE;
    var iter_edges = function (f) {
      return Curry._1(HM.iter, (function (v) {
                    return Curry._1(S.iter, Curry._1(f, v));
                  }));
    };
    var fold_edges = function (f) {
      return Curry._1(HM.fold, (function (v) {
                    return Curry._1(S.fold, Curry._1(f, v));
                  }));
    };
    var iter_edges_e = function (f) {
      return Curry._1(HM.iter, (function (v) {
                    return Curry._1(S.iter, (function (param) {
                                  return Curry._1(f, [
                                              v,
                                              param
                                            ]);
                                }));
                  }));
    };
    var fold_edges_e = function (f) {
      return Curry._1(HM.fold, (function (v) {
                    return Curry._1(S.fold, (function (param, param$1) {
                                  return Curry._2(f, [
                                              v,
                                              param
                                            ], param$1);
                                }));
                  }));
    };
    var I = {
      PV: V,
      PE: PE,
      iter_edges: iter_edges,
      fold_edges: fold_edges,
      iter_edges_e: iter_edges_e,
      fold_edges_e: fold_edges_e
    };
    var mem_vertex = HM.mem;
    var S_PE = {
      compare: compare,
      src: src,
      dst: dst,
      create: create,
      label: label
    };
    var iter_pred = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred");
      }
      return Curry._1(iter_edges(function (v1, v2) {
                      if (Curry._2(V.equal, v, v2)) {
                        return Curry._1(f, v1);
                      }
                      
                    }), g);
    };
    var fold_pred = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred");
      }
      return Curry._1(fold_edges(function (v1, v2, a) {
                      if (Curry._2(V.equal, v, v2)) {
                        return Curry._2(f, v1, a);
                      } else {
                        return a;
                      }
                    }), g);
    };
    var pred = function (g, v) {
      return Curry._1(fold_pred((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var in_degree = function (g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] in_degree");
      }
      return Curry._1(fold_pred((function (param, n) {
                        return n + 1 | 0;
                      }), g, v), 0);
    };
    var iter_pred_e = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
      }
      return Curry._1(iter_edges_e(function (e) {
                      if (Curry._2(V.equal, v, Curry._1(S_PE.dst, e))) {
                        return Curry._1(f, e);
                      }
                      
                    }), g);
    };
    var fold_pred_e = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
      }
      return Curry._1(fold_edges_e(function (e, a) {
                      if (Curry._2(V.equal, v, Curry._1(S_PE.dst, e))) {
                        return Curry._2(f, e, a);
                      } else {
                        return a;
                      }
                    }), g);
    };
    var pred_e = function (g, v) {
      return Curry._1(fold_pred_e((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var S$1 = S;
    var E$1 = E;
    var mem_edge$1 = mem_edge;
    var mem_edge_e$1 = mem_edge_e;
    var find_edge$1 = find_edge;
    var find_all_edges$1 = find_all_edges;
    var unsafe_remove_edge$1 = unsafe_remove_edge;
    var unsafe_remove_edge_e$1 = unsafe_remove_edge_e;
    var remove_edge$1 = remove_edge;
    var remove_edge_e$1 = remove_edge_e;
    var iter_succ$1 = iter_succ;
    var fold_succ$1 = fold_succ;
    var iter_succ_e$1 = iter_succ_e;
    var fold_succ_e$1 = fold_succ_e;
    var succ$1 = succ;
    var succ_e$1 = succ_e;
    var map_vertex$1 = map_vertex;
    var iter_edges$1 = iter_edges;
    var fold_edges$1 = fold_edges;
    var iter_edges_e$1 = iter_edges_e;
    var fold_edges_e$1 = fold_edges_e;
    var iter_pred$1 = iter_pred;
    var fold_pred$1 = fold_pred;
    var pred$1 = pred;
    var in_degree$1 = in_degree;
    var iter_pred_e$1 = iter_pred_e;
    var fold_pred_e$1 = fold_pred_e;
    var pred_e$1 = pred_e;
    var nb_vertex = function (g) {
      return Curry._3(HM.fold, (function (param, param$1) {
                    return function (prim) {
                      return prim + 1 | 0;
                    };
                  }), g, 0);
    };
    var nb_edges = function (g) {
      return Curry._3(HM.fold, (function (param, s, n) {
                    return n + Curry._1(S$1.cardinal, s) | 0;
                  }), g, 0);
    };
    var out_degree = function (g, v) {
      var tmp;
      try {
        tmp = Curry._2(HM.find, v, g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          tmp = Pervasives.invalid_arg("[ocamlgraph] out_degree");
        } else {
          throw exn;
        }
      }
      return Curry._1(S$1.cardinal, tmp);
    };
    var mem_vertex$1 = function (g, v) {
      return Curry._2(HM.mem, v, g);
    };
    var unsafe_add_vertex = function (g, v) {
      return Curry._3(HM.add, v, S$1.empty, g);
    };
    var unsafe_add_edge = function (g, v1, v2) {
      return Curry._3(HM.add, v1, Curry._2(S$1.add, v2, Curry._2(HM.find, v1, g)), g);
    };
    var add_vertex = function (g, v) {
      if (Curry._2(HM.mem, v, g)) {
        return g;
      } else {
        return Curry._3(HM.add, v, S$1.empty, g);
      }
    };
    var iter_vertex = function (f) {
      return Curry._1(HM.iter, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var fold_vertex = function (f) {
      return Curry._1(HM.fold, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var include_empty = HM.empty;
    var include_create = HM.create;
    var include_is_empty = HM.is_empty;
    var include_copy = HM.copy;
    var include_clear = HM.clear;
    var include$1 = {
      is_directed: true,
      empty: include_empty,
      create: include_create,
      is_empty: include_is_empty,
      copy: include_copy,
      clear: include_clear,
      nb_vertex: nb_vertex,
      nb_edges: nb_edges,
      out_degree: out_degree,
      mem_vertex: mem_vertex$1,
      unsafe_add_vertex: unsafe_add_vertex,
      unsafe_add_edge: unsafe_add_edge,
      add_vertex: add_vertex,
      iter_vertex: iter_vertex,
      fold_vertex: fold_vertex
    };
    var is_directed = include$1.is_directed;
    var create$1 = include_create;
    var is_empty = include_is_empty;
    var clear = include_clear;
    var nb_vertex$1 = nb_vertex;
    var nb_edges$1 = nb_edges;
    var out_degree$1 = out_degree;
    var mem_vertex$2 = mem_vertex$1;
    var unsafe_add_vertex$1 = unsafe_add_vertex;
    var unsafe_add_edge$1 = unsafe_add_edge;
    var iter_vertex$1 = iter_vertex;
    var fold_vertex$1 = fold_vertex;
    var G_I = I;
    var G_PV = V;
    var G_PE = PE;
    var G_empty = include_empty;
    var G_copy = include_copy;
    var G_add_vertex = add_vertex;
    var G = {
      V: V,
      HM: HM,
      S: S$1,
      E: E$1,
      mem_edge: mem_edge$1,
      mem_edge_e: mem_edge_e$1,
      find_edge: find_edge$1,
      find_all_edges: find_all_edges$1,
      unsafe_remove_edge: unsafe_remove_edge$1,
      unsafe_remove_edge_e: unsafe_remove_edge_e$1,
      remove_edge: remove_edge$1,
      remove_edge_e: remove_edge_e$1,
      iter_succ: iter_succ$1,
      fold_succ: fold_succ$1,
      iter_succ_e: iter_succ_e$1,
      fold_succ_e: fold_succ_e$1,
      succ: succ$1,
      succ_e: succ_e$1,
      map_vertex: map_vertex$1,
      I: G_I,
      PV: G_PV,
      PE: G_PE,
      iter_edges: iter_edges$1,
      fold_edges: fold_edges$1,
      iter_edges_e: iter_edges_e$1,
      fold_edges_e: fold_edges_e$1,
      iter_pred: iter_pred$1,
      fold_pred: fold_pred$1,
      pred: pred$1,
      in_degree: in_degree$1,
      iter_pred_e: iter_pred_e$1,
      fold_pred_e: fold_pred_e$1,
      pred_e: pred_e$1,
      is_directed: is_directed,
      empty: G_empty,
      create: create$1,
      is_empty: is_empty,
      copy: G_copy,
      clear: clear,
      nb_vertex: nb_vertex$1,
      nb_edges: nb_edges$1,
      out_degree: out_degree$1,
      mem_vertex: mem_vertex$2,
      unsafe_add_vertex: unsafe_add_vertex$1,
      unsafe_add_edge: unsafe_add_edge$1,
      add_vertex: G_add_vertex,
      iter_vertex: iter_vertex$1,
      fold_vertex: fold_vertex$1
    };
    var G_E = {
      compare: E$1.compare,
      src: E$1.src,
      dst: E$1.dst,
      create: E$1.create,
      label: E$1.label
    };
    var PE$1 = G_E;
    var iter_edges$2 = function (f, g) {
      return Curry._2(iter_edges$1, f, g.edges);
    };
    var fold_edges$2 = function (f, g) {
      return Curry._2(fold_edges$1, f, g.edges);
    };
    var iter_edges_e$2 = function (f, g) {
      return Curry._2(iter_edges_e$1, f, g.edges);
    };
    var fold_edges_e$2 = function (f, g) {
      return Curry._2(fold_edges_e$1, f, g.edges);
    };
    var mem_vertex$3 = function (v, g) {
      return Curry._2(mem_vertex$2, g.edges, v);
    };
    var create$2 = function (size, param) {
      return {
              edges: Curry._2(create$1, size, undefined),
              size: 0
            };
    };
    var clear$1 = function (g) {
      Curry._1(clear, g.edges);
      g.size = 0;
      
    };
    var I$1 = {
      PV: V,
      PE: PE$1,
      iter_edges: iter_edges$2,
      fold_edges: fold_edges$2,
      iter_edges_e: iter_edges_e$2,
      fold_edges_e: fold_edges_e$2,
      mem_vertex: mem_vertex$3,
      create: create$2,
      clear: clear$1
    };
    var iter_pred$2 = function (f, g, v) {
      if (!Curry._2(mem_vertex$2, g.edges, v)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred");
      }
      return Curry._2(iter_edges$1, (function (v1, v2) {
                    if (Curry._2(V.equal, v, v2)) {
                      return Curry._1(f, v1);
                    }
                    
                  }), g.edges);
    };
    var fold_pred$2 = function (f, g, v) {
      if (!Curry._2(mem_vertex$2, g.edges, v)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred");
      }
      return Curry._2(fold_edges$1, (function (v1, v2, a) {
                    if (Curry._2(V.equal, v, v2)) {
                      return Curry._2(f, v1, a);
                    } else {
                      return a;
                    }
                  }), g.edges);
    };
    var pred$2 = function (g, v) {
      return Curry._1(fold_pred$2((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var iter_pred_e$2 = function (f, g, v) {
      if (!Curry._2(mem_vertex$2, g.edges, v)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
      }
      return Curry._2(iter_edges_e$1, (function (e) {
                    if (Curry._2(V.equal, v, Curry._1(PE$1.dst, e))) {
                      return Curry._1(f, e);
                    }
                    
                  }), g.edges);
    };
    var fold_pred_e$2 = function (f, g, v) {
      if (!Curry._2(mem_vertex$2, g.edges, v)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
      }
      return Curry._2(fold_edges_e$1, (function (e, a) {
                    if (Curry._2(V.equal, v, Curry._1(PE$1.dst, e))) {
                      return Curry._2(f, e, a);
                    } else {
                      return a;
                    }
                  }), g.edges);
    };
    var pred_e$2 = function (g, v) {
      return Curry._1(fold_pred_e$2((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var is_empty$1 = function (g) {
      return g.size === 0;
    };
    var nb_vertex$2 = function (g) {
      return g.size;
    };
    var remove_edge$2 = function (g) {
      return Curry._1(remove_edge$1, g.edges);
    };
    var remove_edge_e$2 = function (g) {
      return Curry._1(remove_edge_e$1, g.edges);
    };
    var out_degree$2 = function (g) {
      return Curry._1(out_degree$1, g.edges);
    };
    var in_degree$2 = function (g) {
      return Curry._1(in_degree$1, g.edges);
    };
    var nb_edges$2 = function (g) {
      return Curry._1(nb_edges$1, g.edges);
    };
    var succ$2 = function (g) {
      return Curry._1(succ$1, g.edges);
    };
    var mem_vertex$4 = function (g) {
      return Curry._1(mem_vertex$2, g.edges);
    };
    var mem_edge$2 = function (g) {
      return Curry._1(mem_edge$1, g.edges);
    };
    var mem_edge_e$2 = function (g) {
      return Curry._1(mem_edge_e$1, g.edges);
    };
    var find_edge$2 = function (g) {
      return Curry._1(find_edge$1, g.edges);
    };
    var find_all_edges$2 = function (g) {
      return Curry._1(find_all_edges$1, g.edges);
    };
    var iter_vertex$2 = function (f, g) {
      return Curry._2(iter_vertex$1, f, g.edges);
    };
    var fold_vertex$2 = function (f, g) {
      return Curry._2(fold_vertex$1, f, g.edges);
    };
    var iter_succ$2 = function (f, g) {
      return Curry._2(iter_succ$1, f, g.edges);
    };
    var fold_succ$2 = function (f, g) {
      return Curry._2(fold_succ$1, f, g.edges);
    };
    var succ_e$2 = function (g) {
      return Curry._1(succ_e$1, g.edges);
    };
    var iter_succ_e$2 = function (f, g) {
      return Curry._2(iter_succ_e$1, f, g.edges);
    };
    var fold_succ_e$2 = function (f, g) {
      return Curry._2(fold_succ_e$1, f, g.edges);
    };
    var map_vertex$2 = function (f, g) {
      return {
              edges: Curry._2(map_vertex$1, f, g.edges),
              size: g.size
            };
    };
    var copy = function (g) {
      var h = Curry._2(HM.create, undefined, undefined);
      var vertex = function (v) {
        try {
          return Curry._2(HM.find, v, h);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Not_found") {
            var v$p = Curry._1(V.create, Curry._1(V.label, v));
            var h$p = Curry._3(HM.add, v, v$p, h);
            if (h !== h$p) {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "blocks.ml",
                      474,
                      8
                    ],
                    Error: new Error()
                  };
            }
            return v$p;
          }
          throw exn;
        }
      };
      return map_vertex$2(vertex, g);
    };
    return {
            G: G,
            I: I$1,
            PV: V,
            PE: PE$1,
            iter_edges: iter_edges$2,
            fold_edges: fold_edges$2,
            iter_edges_e: iter_edges_e$2,
            fold_edges_e: fold_edges_e$2,
            create: create$2,
            clear: clear$1,
            iter_pred: iter_pred$2,
            fold_pred: fold_pred$2,
            pred: pred$2,
            iter_pred_e: iter_pred_e$2,
            fold_pred_e: fold_pred_e$2,
            pred_e: pred_e$2,
            is_empty: is_empty$1,
            nb_vertex: nb_vertex$2,
            V: V,
            E: G_E,
            HM: HM,
            S: S$1,
            unsafe_add_edge: unsafe_add_edge$1,
            unsafe_remove_edge: unsafe_remove_edge$1,
            unsafe_remove_edge_e: unsafe_remove_edge_e$1,
            is_directed: is_directed,
            remove_edge: remove_edge$2,
            remove_edge_e: remove_edge_e$2,
            out_degree: out_degree$2,
            in_degree: in_degree$2,
            nb_edges: nb_edges$2,
            succ: succ$2,
            mem_vertex: mem_vertex$4,
            mem_edge: mem_edge$2,
            mem_edge_e: mem_edge_e$2,
            find_edge: find_edge$2,
            find_all_edges: find_all_edges$2,
            iter_vertex: iter_vertex$2,
            fold_vertex: fold_vertex$2,
            iter_succ: iter_succ$2,
            fold_succ: fold_succ$2,
            succ_e: succ_e$2,
            iter_succ_e: iter_succ_e$2,
            fold_succ_e: fold_succ_e$2,
            map_vertex: map_vertex$2,
            copy: copy
          };
  };
  var AbstractLabeled = function (V, E) {
    var HM = Curry._1(F, V);
    var VE = Util.OTProduct(V, E);
    var S = $$Set.Make(VE);
    var src = function (param) {
      return param[0];
    };
    var dst = function (param) {
      return param[2];
    };
    var label = function (param) {
      return param[1];
    };
    var create = function (v1, l, v2) {
      return [
              v1,
              l,
              v2
            ];
    };
    var C = Util.OTProduct(V, VE);
    var compare = function (param, param$1) {
      return Curry._2(C.compare, [
                  param[0],
                  [
                    param[2],
                    param[1]
                  ]
                ], [
                  param$1[0],
                  [
                    param$1[2],
                    param$1[1]
                  ]
                ]);
    };
    var E$1 = {
      src: src,
      dst: dst,
      label: label,
      create: create,
      C: C,
      compare: compare
    };
    var mem_edge = function (g, v1, v2) {
      try {
        return Curry._2(S.exists, (function (param) {
                      return Curry._2(V.equal, v2, param[0]);
                    }), Curry._2(HM.find, v1, g));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var mem_edge_e = function (g, param) {
      try {
        var ve_0 = param[2];
        var ve_1 = param[1];
        var ve = [
          ve_0,
          ve_1
        ];
        return Curry._2(S.exists, (function (ve$p) {
                      return Curry._2(VE.compare, ve, ve$p) === 0;
                    }), Curry._2(HM.find, param[0], g));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return false;
        }
        throw exn;
      }
    };
    var Found = /* @__PURE__ */Caml_exceptions.create("Blocks.Labeled(V)(E)(HM).Found");
    var find_edge = function (g, v1, v2) {
      try {
        Curry._2(S.iter, (function (param) {
                var v2$p = param[0];
                if (!Curry._2(V.equal, v2, v2$p)) {
                  return ;
                }
                throw {
                      RE_EXN_ID: Found,
                      _1: [
                        v1,
                        param[1],
                        v2$p
                      ],
                      Error: new Error()
                    };
              }), Curry._2(HM.find, v1, g));
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      catch (raw_e){
        var e = Caml_js_exceptions.internalToOCamlException(raw_e);
        if (e.RE_EXN_ID === Found) {
          return e._1;
        }
        throw e;
      }
    };
    var find_all_edges = function (g, v1, v2) {
      try {
        return Curry._3(S.fold, (function (param, acc) {
                      var v2$p = param[0];
                      if (Curry._2(V.equal, v2, v2$p)) {
                        return {
                                hd: [
                                  v1,
                                  param[1],
                                  v2$p
                                ],
                                tl: acc
                              };
                      } else {
                        return acc;
                      }
                    }), Curry._2(HM.find, v1, g), /* [] */0);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return /* [] */0;
        }
        throw exn;
      }
    };
    var unsafe_remove_edge = function (g, v1, v2) {
      return Curry._3(HM.add, v1, Curry._2(S.filter, (function (param) {
                        return !Curry._2(V.equal, v2, param[0]);
                      }), Curry._2(HM.find, v1, g)), g);
    };
    var unsafe_remove_edge_e = function (g, param) {
      var v1 = param[0];
      return Curry._3(HM.add, v1, Curry._2(S.remove, [
                      param[2],
                      param[1]
                    ], Curry._2(HM.find, v1, g)), g);
    };
    var remove_edge = function (g, v1, v2) {
      if (!Curry._2(HM.mem, v2, g)) {
        Pervasives.invalid_arg("[ocamlgraph] remove_edge");
      }
      return Curry._3(HM.add, v1, Curry._2(S.filter, (function (param) {
                        return !Curry._2(V.equal, v2, param[0]);
                      }), Curry._3(HM.find_and_raise, v1, g, "[ocamlgraph] remove_edge")), g);
    };
    var remove_edge_e = function (g, param) {
      var v2 = param[2];
      var v1 = param[0];
      if (!Curry._2(HM.mem, v2, g)) {
        Pervasives.invalid_arg("[ocamlgraph] remove_edge_e");
      }
      return Curry._3(HM.add, v1, Curry._2(S.remove, [
                      v2,
                      param[1]
                    ], Curry._3(HM.find_and_raise, v1, g, "[ocamlgraph] remove_edge_e")), g);
    };
    var iter_succ = function (f, g, v) {
      return Curry._2(S.iter, (function (param) {
                    return Curry._1(f, param[0]);
                  }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ"));
    };
    var fold_succ = function (f, g, v) {
      return Curry._2(S.fold, (function (param) {
                    return Curry._1(f, param[0]);
                  }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ"));
    };
    var iter_succ_e = function (f, g, v) {
      return Curry._2(S.iter, (function (param) {
                    return Curry._1(f, [
                                v,
                                param[1],
                                param[0]
                              ]);
                  }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] iter_succ_e"));
    };
    var fold_succ_e = function (f, g, v) {
      return Curry._2(S.fold, (function (param) {
                    return Curry._1(f, [
                                v,
                                param[1],
                                param[0]
                              ]);
                  }), Curry._3(HM.find_and_raise, v, g, "[ocamlgraph] fold_succ_e"));
    };
    var succ = function (g, v) {
      return Curry._1(fold_succ((function (w, l) {
                        return {
                                hd: w,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var succ_e = function (g, v) {
      return Curry._1(fold_succ_e((function (e, l) {
                        return {
                                hd: e,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var map_vertex = function (f) {
      return Curry._1(HM.map, (function (v, s) {
                    return [
                            Curry._1(f, v),
                            Curry._3(S.fold, (function (param, s) {
                                    return Curry._2(S.add, [
                                                Curry._1(f, param[0]),
                                                param[1]
                                              ], s);
                                  }), s, S.empty)
                          ];
                  }));
    };
    var PE;
    var iter_edges = function (f) {
      return Curry._1(HM.iter, (function (v) {
                    return Curry._1(S.iter, (function (param) {
                                  return Curry._2(f, v, param[0]);
                                }));
                  }));
    };
    var fold_edges = function (f) {
      return Curry._1(HM.fold, (function (v) {
                    return Curry._1(S.fold, (function (param) {
                                  return Curry._2(f, v, param[0]);
                                }));
                  }));
    };
    var iter_edges_e = function (f) {
      return Curry._1(HM.iter, (function (v) {
                    return Curry._1(S.iter, (function (param) {
                                  return Curry._1(f, [
                                              v,
                                              param[1],
                                              param[0]
                                            ]);
                                }));
                  }));
    };
    var fold_edges_e = function (f) {
      return Curry._1(HM.fold, (function (v) {
                    return Curry._1(S.fold, (function (param) {
                                  return Curry._1(f, [
                                              v,
                                              param[1],
                                              param[0]
                                            ]);
                                }));
                  }));
    };
    var I = {
      PV: V,
      PE: PE,
      iter_edges: iter_edges,
      fold_edges: fold_edges,
      iter_edges_e: iter_edges_e,
      fold_edges_e: fold_edges_e
    };
    var mem_vertex = HM.mem;
    var S_PE = {
      compare: compare,
      src: src,
      dst: dst,
      create: create,
      label: label
    };
    var iter_pred = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred");
      }
      return Curry._1(iter_edges(function (v1, v2) {
                      if (Curry._2(V.equal, v, v2)) {
                        return Curry._1(f, v1);
                      }
                      
                    }), g);
    };
    var fold_pred = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred");
      }
      return Curry._1(fold_edges(function (v1, v2, a) {
                      if (Curry._2(V.equal, v, v2)) {
                        return Curry._2(f, v1, a);
                      } else {
                        return a;
                      }
                    }), g);
    };
    var pred = function (g, v) {
      return Curry._1(fold_pred((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var in_degree = function (g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] in_degree");
      }
      return Curry._1(fold_pred((function (param, n) {
                        return n + 1 | 0;
                      }), g, v), 0);
    };
    var iter_pred_e = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
      }
      return Curry._1(iter_edges_e(function (e) {
                      if (Curry._2(V.equal, v, Curry._1(S_PE.dst, e))) {
                        return Curry._1(f, e);
                      }
                      
                    }), g);
    };
    var fold_pred_e = function (f, g, v) {
      if (!Curry._2(mem_vertex, v, g)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
      }
      return Curry._1(fold_edges_e(function (e, a) {
                      if (Curry._2(V.equal, v, Curry._1(S_PE.dst, e))) {
                        return Curry._2(f, e, a);
                      } else {
                        return a;
                      }
                    }), g);
    };
    var pred_e = function (g, v) {
      return Curry._1(fold_pred_e((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var S$1 = S;
    var E$2 = E$1;
    var mem_edge$1 = mem_edge;
    var mem_edge_e$1 = mem_edge_e;
    var find_edge$1 = find_edge;
    var find_all_edges$1 = find_all_edges;
    var unsafe_remove_edge$1 = unsafe_remove_edge;
    var unsafe_remove_edge_e$1 = unsafe_remove_edge_e;
    var remove_edge$1 = remove_edge;
    var remove_edge_e$1 = remove_edge_e;
    var iter_succ$1 = iter_succ;
    var fold_succ$1 = fold_succ;
    var iter_succ_e$1 = iter_succ_e;
    var fold_succ_e$1 = fold_succ_e;
    var succ$1 = succ;
    var succ_e$1 = succ_e;
    var map_vertex$1 = map_vertex;
    var iter_edges$1 = iter_edges;
    var fold_edges$1 = fold_edges;
    var iter_edges_e$1 = iter_edges_e;
    var fold_edges_e$1 = fold_edges_e;
    var iter_pred$1 = iter_pred;
    var fold_pred$1 = fold_pred;
    var pred$1 = pred;
    var in_degree$1 = in_degree;
    var iter_pred_e$1 = iter_pred_e;
    var fold_pred_e$1 = fold_pred_e;
    var pred_e$1 = pred_e;
    var nb_vertex = function (g) {
      return Curry._3(HM.fold, (function (param, param$1) {
                    return function (prim) {
                      return prim + 1 | 0;
                    };
                  }), g, 0);
    };
    var nb_edges = function (g) {
      return Curry._3(HM.fold, (function (param, s, n) {
                    return n + Curry._1(S$1.cardinal, s) | 0;
                  }), g, 0);
    };
    var out_degree = function (g, v) {
      var tmp;
      try {
        tmp = Curry._2(HM.find, v, g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          tmp = Pervasives.invalid_arg("[ocamlgraph] out_degree");
        } else {
          throw exn;
        }
      }
      return Curry._1(S$1.cardinal, tmp);
    };
    var mem_vertex$1 = function (g, v) {
      return Curry._2(HM.mem, v, g);
    };
    var unsafe_add_vertex = function (g, v) {
      return Curry._3(HM.add, v, S$1.empty, g);
    };
    var unsafe_add_edge = function (g, v1, v2) {
      return Curry._3(HM.add, v1, Curry._2(S$1.add, v2, Curry._2(HM.find, v1, g)), g);
    };
    var add_vertex = function (g, v) {
      if (Curry._2(HM.mem, v, g)) {
        return g;
      } else {
        return Curry._3(HM.add, v, S$1.empty, g);
      }
    };
    var iter_vertex = function (f) {
      return Curry._1(HM.iter, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var fold_vertex = function (f) {
      return Curry._1(HM.fold, (function (v, param) {
                    return Curry._1(f, v);
                  }));
    };
    var include_empty = HM.empty;
    var include_create = HM.create;
    var include_is_empty = HM.is_empty;
    var include_copy = HM.copy;
    var include_clear = HM.clear;
    var include = {
      is_directed: true,
      empty: include_empty,
      create: include_create,
      is_empty: include_is_empty,
      copy: include_copy,
      clear: include_clear,
      nb_vertex: nb_vertex,
      nb_edges: nb_edges,
      out_degree: out_degree,
      mem_vertex: mem_vertex$1,
      unsafe_add_vertex: unsafe_add_vertex,
      unsafe_add_edge: unsafe_add_edge,
      add_vertex: add_vertex,
      iter_vertex: iter_vertex,
      fold_vertex: fold_vertex
    };
    var is_directed = include.is_directed;
    var create$1 = include_create;
    var is_empty = include_is_empty;
    var clear = include_clear;
    var nb_vertex$1 = nb_vertex;
    var nb_edges$1 = nb_edges;
    var out_degree$1 = out_degree;
    var mem_vertex$2 = mem_vertex$1;
    var unsafe_add_vertex$1 = unsafe_add_vertex;
    var unsafe_add_edge$1 = unsafe_add_edge;
    var iter_vertex$1 = iter_vertex;
    var fold_vertex$1 = fold_vertex;
    var G_VE = VE;
    var G_Found = Found;
    var G_I = I;
    var G_PV = V;
    var G_PE = PE;
    var G_empty = include_empty;
    var G_copy = include_copy;
    var G_add_vertex = add_vertex;
    var G = {
      V: V,
      HM: HM,
      VE: G_VE,
      S: S$1,
      E: E$2,
      mem_edge: mem_edge$1,
      mem_edge_e: mem_edge_e$1,
      Found: G_Found,
      find_edge: find_edge$1,
      find_all_edges: find_all_edges$1,
      unsafe_remove_edge: unsafe_remove_edge$1,
      unsafe_remove_edge_e: unsafe_remove_edge_e$1,
      remove_edge: remove_edge$1,
      remove_edge_e: remove_edge_e$1,
      iter_succ: iter_succ$1,
      fold_succ: fold_succ$1,
      iter_succ_e: iter_succ_e$1,
      fold_succ_e: fold_succ_e$1,
      succ: succ$1,
      succ_e: succ_e$1,
      map_vertex: map_vertex$1,
      I: G_I,
      PV: G_PV,
      PE: G_PE,
      iter_edges: iter_edges$1,
      fold_edges: fold_edges$1,
      iter_edges_e: iter_edges_e$1,
      fold_edges_e: fold_edges_e$1,
      iter_pred: iter_pred$1,
      fold_pred: fold_pred$1,
      pred: pred$1,
      in_degree: in_degree$1,
      iter_pred_e: iter_pred_e$1,
      fold_pred_e: fold_pred_e$1,
      pred_e: pred_e$1,
      is_directed: is_directed,
      empty: G_empty,
      create: create$1,
      is_empty: is_empty,
      copy: G_copy,
      clear: clear,
      nb_vertex: nb_vertex$1,
      nb_edges: nb_edges$1,
      out_degree: out_degree$1,
      mem_vertex: mem_vertex$2,
      unsafe_add_vertex: unsafe_add_vertex$1,
      unsafe_add_edge: unsafe_add_edge$1,
      add_vertex: G_add_vertex,
      iter_vertex: iter_vertex$1,
      fold_vertex: fold_vertex$1
    };
    var G_E = {
      compare: E$2.compare,
      src: E$2.src,
      dst: E$2.dst,
      create: E$2.create,
      label: E$2.label
    };
    var PE$1 = G_E;
    var iter_edges$2 = function (f, g) {
      return Curry._2(iter_edges$1, f, g.edges);
    };
    var fold_edges$2 = function (f, g) {
      return Curry._2(fold_edges$1, f, g.edges);
    };
    var iter_edges_e$2 = function (f, g) {
      return Curry._2(iter_edges_e$1, f, g.edges);
    };
    var fold_edges_e$2 = function (f, g) {
      return Curry._2(fold_edges_e$1, f, g.edges);
    };
    var mem_vertex$3 = function (v, g) {
      return Curry._2(mem_vertex$2, g.edges, v);
    };
    var create$2 = function (size, param) {
      return {
              edges: Curry._2(create$1, size, undefined),
              size: 0
            };
    };
    var clear$1 = function (g) {
      Curry._1(clear, g.edges);
      g.size = 0;
      
    };
    var I$1 = {
      PV: V,
      PE: PE$1,
      iter_edges: iter_edges$2,
      fold_edges: fold_edges$2,
      iter_edges_e: iter_edges_e$2,
      fold_edges_e: fold_edges_e$2,
      mem_vertex: mem_vertex$3,
      create: create$2,
      clear: clear$1
    };
    var iter_pred$2 = function (f, g, v) {
      if (!Curry._2(mem_vertex$2, g.edges, v)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred");
      }
      return Curry._2(iter_edges$1, (function (v1, v2) {
                    if (Curry._2(V.equal, v, v2)) {
                      return Curry._1(f, v1);
                    }
                    
                  }), g.edges);
    };
    var fold_pred$2 = function (f, g, v) {
      if (!Curry._2(mem_vertex$2, g.edges, v)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred");
      }
      return Curry._2(fold_edges$1, (function (v1, v2, a) {
                    if (Curry._2(V.equal, v, v2)) {
                      return Curry._2(f, v1, a);
                    } else {
                      return a;
                    }
                  }), g.edges);
    };
    var pred$2 = function (g, v) {
      return Curry._1(fold_pred$2((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var iter_pred_e$2 = function (f, g, v) {
      if (!Curry._2(mem_vertex$2, g.edges, v)) {
        Pervasives.invalid_arg("[ocamlgraph] iter_pred_e");
      }
      return Curry._2(iter_edges_e$1, (function (e) {
                    if (Curry._2(V.equal, v, Curry._1(PE$1.dst, e))) {
                      return Curry._1(f, e);
                    }
                    
                  }), g.edges);
    };
    var fold_pred_e$2 = function (f, g, v) {
      if (!Curry._2(mem_vertex$2, g.edges, v)) {
        Pervasives.invalid_arg("[ocamlgraph] fold_pred_e");
      }
      return Curry._2(fold_edges_e$1, (function (e, a) {
                    if (Curry._2(V.equal, v, Curry._1(PE$1.dst, e))) {
                      return Curry._2(f, e, a);
                    } else {
                      return a;
                    }
                  }), g.edges);
    };
    var pred_e$2 = function (g, v) {
      return Curry._1(fold_pred_e$2((function (v, l) {
                        return {
                                hd: v,
                                tl: l
                              };
                      }), g, v), /* [] */0);
    };
    var is_empty$1 = function (g) {
      return g.size === 0;
    };
    var nb_vertex$2 = function (g) {
      return g.size;
    };
    var remove_edge$2 = function (g) {
      return Curry._1(remove_edge$1, g.edges);
    };
    var remove_edge_e$2 = function (g) {
      return Curry._1(remove_edge_e$1, g.edges);
    };
    var out_degree$2 = function (g) {
      return Curry._1(out_degree$1, g.edges);
    };
    var in_degree$2 = function (g) {
      return Curry._1(in_degree$1, g.edges);
    };
    var nb_edges$2 = function (g) {
      return Curry._1(nb_edges$1, g.edges);
    };
    var succ$2 = function (g) {
      return Curry._1(succ$1, g.edges);
    };
    var mem_vertex$4 = function (g) {
      return Curry._1(mem_vertex$2, g.edges);
    };
    var mem_edge$2 = function (g) {
      return Curry._1(mem_edge$1, g.edges);
    };
    var mem_edge_e$2 = function (g) {
      return Curry._1(mem_edge_e$1, g.edges);
    };
    var find_edge$2 = function (g) {
      return Curry._1(find_edge$1, g.edges);
    };
    var find_all_edges$2 = function (g) {
      return Curry._1(find_all_edges$1, g.edges);
    };
    var iter_vertex$2 = function (f, g) {
      return Curry._2(iter_vertex$1, f, g.edges);
    };
    var fold_vertex$2 = function (f, g) {
      return Curry._2(fold_vertex$1, f, g.edges);
    };
    var iter_succ$2 = function (f, g) {
      return Curry._2(iter_succ$1, f, g.edges);
    };
    var fold_succ$2 = function (f, g) {
      return Curry._2(fold_succ$1, f, g.edges);
    };
    var succ_e$2 = function (g) {
      return Curry._1(succ_e$1, g.edges);
    };
    var iter_succ_e$2 = function (f, g) {
      return Curry._2(iter_succ_e$1, f, g.edges);
    };
    var fold_succ_e$2 = function (f, g) {
      return Curry._2(fold_succ_e$1, f, g.edges);
    };
    var map_vertex$2 = function (f, g) {
      return {
              edges: Curry._2(map_vertex$1, f, g.edges),
              size: g.size
            };
    };
    var copy = function (g) {
      var h = Curry._2(HM.create, undefined, undefined);
      var vertex = function (v) {
        try {
          return Curry._2(HM.find, v, h);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Not_found") {
            var v$p = Curry._1(V.create, Curry._1(V.label, v));
            var h$p = Curry._3(HM.add, v, v$p, h);
            if (h !== h$p) {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "blocks.ml",
                      474,
                      8
                    ],
                    Error: new Error()
                  };
            }
            return v$p;
          }
          throw exn;
        }
      };
      return map_vertex$2(vertex, g);
    };
    return {
            G: G,
            I: I$1,
            PV: V,
            PE: PE$1,
            iter_edges: iter_edges$2,
            fold_edges: fold_edges$2,
            iter_edges_e: iter_edges_e$2,
            fold_edges_e: fold_edges_e$2,
            create: create$2,
            clear: clear$1,
            iter_pred: iter_pred$2,
            fold_pred: fold_pred$2,
            pred: pred$2,
            iter_pred_e: iter_pred_e$2,
            fold_pred_e: fold_pred_e$2,
            pred_e: pred_e$2,
            is_empty: is_empty$1,
            nb_vertex: nb_vertex$2,
            V: V,
            E: G_E,
            HM: HM,
            S: S$1,
            unsafe_add_edge: unsafe_add_edge$1,
            unsafe_remove_edge: unsafe_remove_edge$1,
            unsafe_remove_edge_e: unsafe_remove_edge_e$1,
            is_directed: is_directed,
            remove_edge: remove_edge$2,
            remove_edge_e: remove_edge_e$2,
            out_degree: out_degree$2,
            in_degree: in_degree$2,
            nb_edges: nb_edges$2,
            succ: succ$2,
            mem_vertex: mem_vertex$4,
            mem_edge: mem_edge$2,
            mem_edge_e: mem_edge_e$2,
            find_edge: find_edge$2,
            find_all_edges: find_all_edges$2,
            iter_vertex: iter_vertex$2,
            fold_vertex: fold_vertex$2,
            iter_succ: iter_succ$2,
            fold_succ: fold_succ$2,
            succ_e: succ_e$2,
            iter_succ_e: iter_succ_e$2,
            fold_succ_e: fold_succ_e$2,
            map_vertex: map_vertex$2,
            copy: copy
          };
  };
  var Digraph = {
    Concrete: Concrete,
    ConcreteBidirectional: ConcreteBidirectional,
    ConcreteLabeled: ConcreteLabeled,
    ConcreteBidirectionalLabeled: ConcreteBidirectionalLabeled,
    Abstract: Abstract,
    AbstractLabeled: AbstractLabeled
  };
  return {
          Digraph: Digraph
        };
}

function Graph(G) {
  var V = G.V;
  var E = G.E;
  var out_degree = G.out_degree;
  var succ = G.succ;
  var succ_e = G.succ_e;
  var iter_edges = G.iter_edges;
  var fold_edges = G.fold_edges;
  var iter_edges_e = G.iter_edges_e;
  var fold_edges_e = G.fold_edges_e;
  var iter_succ = G.iter_succ;
  var fold_succ = G.fold_succ;
  var iter_succ_e = G.iter_succ_e;
  var fold_succ_e = G.fold_succ_e;
  var iter_edges$1 = function (f) {
    return Curry._1(iter_edges, (function (v1, v2) {
                  if (Curry._2(V.compare, v1, v2) >= 0) {
                    return Curry._2(f, v1, v2);
                  }
                  
                }));
  };
  var fold_edges$1 = function (f) {
    return Curry._1(fold_edges, (function (v1, v2, acc) {
                  if (Curry._2(V.compare, v1, v2) >= 0) {
                    return Curry._3(f, v1, v2, acc);
                  } else {
                    return acc;
                  }
                }));
  };
  var iter_edges_e$1 = function (f) {
    return Curry._1(iter_edges_e, (function (e) {
                  if (Curry._2(V.compare, Curry._1(E.src, e), Curry._1(E.dst, e)) >= 0) {
                    return Curry._1(f, e);
                  }
                  
                }));
  };
  var fold_edges_e$1 = function (f) {
    return Curry._1(fold_edges_e, (function (e, acc) {
                  if (Curry._2(V.compare, Curry._1(E.src, e), Curry._1(E.dst, e)) >= 0) {
                    return Curry._2(f, e, acc);
                  } else {
                    return acc;
                  }
                }));
  };
  var nb_edges = function (g) {
    return Curry._2(fold_edges_e$1(function (param) {
                    return function (param) {
                      return 1 + param | 0;
                    };
                  }), g, 0);
  };
  return {
          V: V,
          E: E,
          is_empty: G.is_empty,
          nb_vertex: G.nb_vertex,
          out_degree: out_degree,
          mem_vertex: G.mem_vertex,
          mem_edge: G.mem_edge,
          mem_edge_e: G.mem_edge_e,
          find_edge: G.find_edge,
          find_all_edges: G.find_all_edges,
          succ: succ,
          succ_e: succ_e,
          iter_vertex: G.iter_vertex,
          fold_vertex: G.fold_vertex,
          map_vertex: G.map_vertex,
          iter_succ: iter_succ,
          fold_succ: fold_succ,
          iter_succ_e: iter_succ_e,
          fold_succ_e: fold_succ_e,
          create: G.create,
          clear: G.clear,
          copy: G.copy,
          add_vertex: G.add_vertex,
          remove_vertex: G.remove_vertex,
          is_directed: false,
          iter_edges: iter_edges$1,
          fold_edges: fold_edges$1,
          iter_edges_e: iter_edges_e$1,
          fold_edges_e: fold_edges_e$1,
          nb_edges: nb_edges,
          pred: succ,
          in_degree: out_degree,
          iter_pred: iter_succ,
          fold_pred: fold_succ,
          pred_e: succ_e,
          iter_pred_e: iter_succ_e,
          fold_pred_e: fold_succ_e
        };
}

var first_value_for_cpt_vertex = 0;

exports.first_value_for_cpt_vertex = first_value_for_cpt_vertex;
exports.cpt_vertex = cpt_vertex;
exports.max_cpt = max_cpt;
exports.after_unserialization = after_unserialization;
exports.Make_Hashtbl = Make_Hashtbl;
exports.Make_Map = Make_Map;
exports.Minimal = Minimal;
exports.Pred = Pred;
exports.Unlabeled = Unlabeled;
exports.Labeled = Labeled;
exports.ConcreteVertex = ConcreteVertex;
exports.Make_Abstract = Make_Abstract;
exports.BidirectionalMinimal = BidirectionalMinimal;
exports.BidirectionalUnlabeled = BidirectionalUnlabeled;
exports.BidirectionalLabeled = BidirectionalLabeled;
exports.Make = Make;
exports.Graph = Graph;
/* No side effect */
