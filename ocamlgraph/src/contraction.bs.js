// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Map from "rescript/lib/es6/map.js";
import * as $$Set from "rescript/lib/es6/set.js";
import * as Curry from "rescript/lib/es6/curry.js";

function Make(funarg) {
  var M = $$Map.Make(funarg.V);
  var S = $$Set.Make(funarg.V);
  var contract = function (prop, g) {
    var f = function (edge, m) {
      if (!Curry._1(prop, edge)) {
        return m;
      }
      var s_src = Curry._2(M.find, Curry._1(funarg.E.src, edge), m);
      var s_dst = Curry._2(M.find, Curry._1(funarg.E.dst, edge), m);
      var s = Curry._2(S.union, s_src, s_dst);
      return Curry._3(S.fold, (function (vertex, m) {
                    return Curry._3(M.add, vertex, s, m);
                  }), s, m);
    };
    var m = Curry._3(funarg.fold_vertex, (function (vertex, m) {
            return Curry._3(M.add, vertex, Curry._1(S.singleton, vertex), m);
          }), g, M.empty);
    var m$1 = Curry._3(funarg.fold_edges_e, f, g, m);
    return Curry._3(funarg.fold_edges_e, (function (param, param$1) {
                  if (Curry._1(prop, param)) {
                    return param$1;
                  }
                  var n = Curry._1(funarg.E.src, param);
                  var n$1 = Curry._1(funarg.E.dst, param);
                  return Curry._2(funarg.add_edge_e, param$1, Curry._3(funarg.E.create, Curry._1(S.min_elt, Curry._2(M.find, n, m$1)), Curry._1(funarg.E.label, param), Curry._1(S.min_elt, Curry._2(M.find, n$1, m$1))));
                }), g, funarg.empty);
  };
  return {
          contract: contract
        };
}

export {
  Make ,
  
}
/* No side effect */
