// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var Unionfind = require("./lib/unionfind.bs.js");

function Generic(G, W, UF) {
  var spanningtree = function (g) {
    var vertices = Curry._3(G.fold_vertex, (function (v, a) {
            return {
                    hd: v,
                    tl: a
                  };
          }), g, /* [] */0);
    var uf = Curry._1(UF.init, vertices);
    var l = {
      contents: /* [] */0
    };
    Curry._2(G.iter_edges_e, (function (e) {
            l.contents = {
              hd: e,
              tl: l.contents
            };
            
          }), g);
    var edges = List.sort((function (e, e$p) {
            return Curry._2(W.compare, Curry._1(G.E.label, e), Curry._1(G.E.label, e$p));
          }), l.contents);
    var s = {
      contents: /* [] */0
    };
    var cover = function (e) {
      var u = Curry._1(G.E.src, e);
      var v = Curry._1(G.E.dst, e);
      if (Curry._2(G.V.compare, Curry._2(UF.find, u, uf), Curry._2(UF.find, v, uf)) !== 0) {
        Curry._3(UF.union, u, v, uf);
        s.contents = {
          hd: e,
          tl: s.contents
        };
        return ;
      }
      
    };
    List.iter(cover, edges);
    return s.contents;
  };
  return {
          spanningtree: spanningtree
        };
}

function Make(G, W) {
  var $$let = G.V;
  var param = Unionfind.Make({
        equal: $$let.equal,
        hash: $$let.hash,
        compare: $$let.compare
      });
  var spanningtree = function (g) {
    var vertices = Curry._3(G.fold_vertex, (function (v, a) {
            return {
                    hd: v,
                    tl: a
                  };
          }), g, /* [] */0);
    var uf = Curry._1(param.init, vertices);
    var l = {
      contents: /* [] */0
    };
    Curry._2(G.iter_edges_e, (function (e) {
            l.contents = {
              hd: e,
              tl: l.contents
            };
            
          }), g);
    var edges = List.sort((function (e, e$p) {
            return Curry._2(W.compare, Curry._1(G.E.label, e), Curry._1(G.E.label, e$p));
          }), l.contents);
    var s = {
      contents: /* [] */0
    };
    var cover = function (e) {
      var u = Curry._1(G.E.src, e);
      var v = Curry._1(G.E.dst, e);
      if (Curry._2(G.V.compare, Curry._2(param.find, u, uf), Curry._2(param.find, v, uf)) !== 0) {
        Curry._3(param.union, u, v, uf);
        s.contents = {
          hd: e,
          tl: s.contents
        };
        return ;
      }
      
    };
    List.iter(cover, edges);
    return s.contents;
  };
  return {
          spanningtree: spanningtree
        };
}

exports.Make = Make;
exports.Generic = Generic;
/* No side effect */
