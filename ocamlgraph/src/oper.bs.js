// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Set from "rescript/lib/es6/set.js";
import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Builder from "./builder.bs.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function Make(funarg) {
  var add_transitive_closure = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    var phi = function (v, g) {
      var g$1 = reflexive ? Curry._3(funarg.add_edge, g, v, v) : g;
      return Curry._4(funarg.G.fold_succ, (function (sv, g) {
                    return Curry._4(funarg.G.fold_pred, (function (pv, g) {
                                  return Curry._3(funarg.add_edge, g, pv, sv);
                                }), g, v, g);
                  }), g$1, v, g$1);
    };
    return Curry._3(funarg.G.fold_vertex, phi, g0, g0);
  };
  var transitive_closure = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    return add_transitive_closure(reflexive, Curry._1(funarg.copy, g0));
  };
  var $$let = funarg.G.V;
  Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var mirror = function (g) {
    if (!funarg.G.is_directed) {
      return g;
    }
    var g$p = Curry._3(funarg.G.fold_vertex, (function (v, g$p) {
            return Curry._2(funarg.add_vertex, g$p, v);
          }), g, Curry._1(funarg.empty, undefined));
    return Curry._3(funarg.G.fold_edges_e, (function (e, g$p) {
                  var v1 = Curry._1(funarg.G.E.src, e);
                  var v2 = Curry._1(funarg.G.E.dst, e);
                  return Curry._2(funarg.add_edge_e, g$p, Curry._3(funarg.G.E.create, v2, Curry._1(funarg.G.E.label, e), v1));
                }), g, g$p);
  };
  var complement = function (g) {
    return Curry._3(funarg.G.fold_vertex, (function (v, g$p) {
                  return Curry._3(funarg.G.fold_vertex, (function (w, g$p) {
                                if (Curry._3(funarg.G.mem_edge, g, v, w)) {
                                  return g$p;
                                } else {
                                  return Curry._3(funarg.add_edge, g$p, v, w);
                                }
                              }), g, g$p);
                }), g, Curry._1(funarg.empty, undefined));
  };
  var intersect = function (g1, g2) {
    return Curry._3(funarg.G.fold_vertex, (function (v, g) {
                  try {
                    var succ = Curry._2(funarg.G.succ_e, g2, v);
                    return Curry._4(funarg.G.fold_succ_e, (function (e, g) {
                                  if (List.exists((function (e$p) {
                                            return Curry._2(funarg.G.E.compare, e, e$p) === 0;
                                          }), succ)) {
                                    return Curry._2(funarg.add_edge_e, g, e);
                                  } else {
                                    return g;
                                  }
                                }), g1, v, Curry._2(funarg.add_vertex, g, v));
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn.RE_EXN_ID === "Invalid_argument") {
                      return g;
                    }
                    throw exn;
                  }
                }), g1, Curry._1(funarg.empty, undefined));
  };
  var union = function (g1, g2) {
    var g2$1 = Curry._1(funarg.copy, g2);
    return Curry._3(funarg.G.fold_vertex, (function (v, g) {
                  return Curry._4(funarg.G.fold_succ_e, (function (e, g) {
                                return Curry._2(funarg.add_edge_e, g, e);
                              }), g1, v, Curry._2(funarg.add_vertex, g, v));
                }), g1, g2$1);
  };
  var replace_by_transitive_reduction = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    var phi = function (v, g) {
      var g$1 = reflexive ? Curry._3(funarg.remove_edge, g, v, v) : g;
      return Curry._4(funarg.G.fold_succ, (function (sv, g) {
                    return Curry._4(funarg.G.fold_pred, (function (pv, g) {
                                  if (Curry._2(funarg.G.V.equal, pv, v) || Curry._2(funarg.G.V.equal, sv, v)) {
                                    return g;
                                  } else {
                                    return Curry._3(funarg.remove_edge, g, pv, sv);
                                  }
                                }), g, v, g);
                  }), g$1, v, g$1);
    };
    return Curry._3(funarg.G.fold_vertex, phi, g0, g0);
  };
  var transitive_reduction = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    return replace_by_transitive_reduction(reflexive, Curry._1(funarg.copy, g0));
  };
  return {
          transitive_closure: transitive_closure,
          add_transitive_closure: add_transitive_closure,
          transitive_reduction: transitive_reduction,
          replace_by_transitive_reduction: replace_by_transitive_reduction,
          mirror: mirror,
          complement: complement,
          intersect: intersect,
          union: union
        };
}

function P(funarg) {
  var B = Builder.P(funarg);
  var add_transitive_closure = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    var phi = function (v, g) {
      var g$1 = reflexive ? Curry._3(B.add_edge, g, v, v) : g;
      return Curry._4(B.G.fold_succ, (function (sv, g) {
                    return Curry._4(B.G.fold_pred, (function (pv, g) {
                                  return Curry._3(B.add_edge, g, pv, sv);
                                }), g, v, g);
                  }), g$1, v, g$1);
    };
    return Curry._3(B.G.fold_vertex, phi, g0, g0);
  };
  var transitive_closure = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    return add_transitive_closure(reflexive, Curry._1(B.copy, g0));
  };
  var $$let = B.G.V;
  Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var mirror = function (g) {
    if (!B.G.is_directed) {
      return g;
    }
    var g$p = Curry._3(B.G.fold_vertex, (function (v, g$p) {
            return Curry._2(B.add_vertex, g$p, v);
          }), g, Curry._1(B.empty, undefined));
    return Curry._3(B.G.fold_edges_e, (function (e, g$p) {
                  var v1 = Curry._1(B.G.E.src, e);
                  var v2 = Curry._1(B.G.E.dst, e);
                  return Curry._2(B.add_edge_e, g$p, Curry._3(B.G.E.create, v2, Curry._1(B.G.E.label, e), v1));
                }), g, g$p);
  };
  var complement = function (g) {
    return Curry._3(B.G.fold_vertex, (function (v, g$p) {
                  return Curry._3(B.G.fold_vertex, (function (w, g$p) {
                                if (Curry._3(B.G.mem_edge, g, v, w)) {
                                  return g$p;
                                } else {
                                  return Curry._3(B.add_edge, g$p, v, w);
                                }
                              }), g, g$p);
                }), g, Curry._1(B.empty, undefined));
  };
  var intersect = function (g1, g2) {
    return Curry._3(B.G.fold_vertex, (function (v, g) {
                  try {
                    var succ = Curry._2(B.G.succ_e, g2, v);
                    return Curry._4(B.G.fold_succ_e, (function (e, g) {
                                  if (List.exists((function (e$p) {
                                            return Curry._2(B.G.E.compare, e, e$p) === 0;
                                          }), succ)) {
                                    return Curry._2(B.add_edge_e, g, e);
                                  } else {
                                    return g;
                                  }
                                }), g1, v, Curry._2(B.add_vertex, g, v));
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn.RE_EXN_ID === "Invalid_argument") {
                      return g;
                    }
                    throw exn;
                  }
                }), g1, Curry._1(B.empty, undefined));
  };
  var union = function (g1, g2) {
    var g2$1 = Curry._1(B.copy, g2);
    return Curry._3(B.G.fold_vertex, (function (v, g) {
                  return Curry._4(B.G.fold_succ_e, (function (e, g) {
                                return Curry._2(B.add_edge_e, g, e);
                              }), g1, v, Curry._2(B.add_vertex, g, v));
                }), g1, g2$1);
  };
  var replace_by_transitive_reduction = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    var phi = function (v, g) {
      var g$1 = reflexive ? Curry._3(B.remove_edge, g, v, v) : g;
      return Curry._4(B.G.fold_succ, (function (sv, g) {
                    return Curry._4(B.G.fold_pred, (function (pv, g) {
                                  if (Curry._2(B.G.V.equal, pv, v) || Curry._2(B.G.V.equal, sv, v)) {
                                    return g;
                                  } else {
                                    return Curry._3(B.remove_edge, g, pv, sv);
                                  }
                                }), g, v, g);
                  }), g$1, v, g$1);
    };
    return Curry._3(B.G.fold_vertex, phi, g0, g0);
  };
  var transitive_reduction = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    return replace_by_transitive_reduction(reflexive, Curry._1(B.copy, g0));
  };
  return {
          transitive_closure: transitive_closure,
          add_transitive_closure: add_transitive_closure,
          transitive_reduction: transitive_reduction,
          replace_by_transitive_reduction: replace_by_transitive_reduction,
          mirror: mirror,
          complement: complement,
          intersect: intersect,
          union: union
        };
}

function I(funarg) {
  var B = Builder.I(funarg);
  var add_transitive_closure = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    var phi = function (v, g) {
      var g$1 = reflexive ? Curry._3(B.add_edge, g, v, v) : g;
      return Curry._4(B.G.fold_succ, (function (sv, g) {
                    return Curry._4(B.G.fold_pred, (function (pv, g) {
                                  return Curry._3(B.add_edge, g, pv, sv);
                                }), g, v, g);
                  }), g$1, v, g$1);
    };
    return Curry._3(B.G.fold_vertex, phi, g0, g0);
  };
  var transitive_closure = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    return add_transitive_closure(reflexive, Curry._1(B.copy, g0));
  };
  var $$let = B.G.V;
  Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var mirror = function (g) {
    if (!B.G.is_directed) {
      return g;
    }
    var g$p = Curry._3(B.G.fold_vertex, (function (v, g$p) {
            return Curry._2(B.add_vertex, g$p, v);
          }), g, Curry._1(B.empty, undefined));
    return Curry._3(B.G.fold_edges_e, (function (e, g$p) {
                  var v1 = Curry._1(B.G.E.src, e);
                  var v2 = Curry._1(B.G.E.dst, e);
                  return Curry._2(B.add_edge_e, g$p, Curry._3(B.G.E.create, v2, Curry._1(B.G.E.label, e), v1));
                }), g, g$p);
  };
  var complement = function (g) {
    return Curry._3(B.G.fold_vertex, (function (v, g$p) {
                  return Curry._3(B.G.fold_vertex, (function (w, g$p) {
                                if (Curry._3(B.G.mem_edge, g, v, w)) {
                                  return g$p;
                                } else {
                                  return Curry._3(B.add_edge, g$p, v, w);
                                }
                              }), g, g$p);
                }), g, Curry._1(B.empty, undefined));
  };
  var intersect = function (g1, g2) {
    return Curry._3(B.G.fold_vertex, (function (v, g) {
                  try {
                    var succ = Curry._2(B.G.succ_e, g2, v);
                    return Curry._4(B.G.fold_succ_e, (function (e, g) {
                                  if (List.exists((function (e$p) {
                                            return Curry._2(B.G.E.compare, e, e$p) === 0;
                                          }), succ)) {
                                    return Curry._2(B.add_edge_e, g, e);
                                  } else {
                                    return g;
                                  }
                                }), g1, v, Curry._2(B.add_vertex, g, v));
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    if (exn.RE_EXN_ID === "Invalid_argument") {
                      return g;
                    }
                    throw exn;
                  }
                }), g1, Curry._1(B.empty, undefined));
  };
  var union = function (g1, g2) {
    var g2$1 = Curry._1(B.copy, g2);
    return Curry._3(B.G.fold_vertex, (function (v, g) {
                  return Curry._4(B.G.fold_succ_e, (function (e, g) {
                                return Curry._2(B.add_edge_e, g, e);
                              }), g1, v, Curry._2(B.add_vertex, g, v));
                }), g1, g2$1);
  };
  var replace_by_transitive_reduction = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    var phi = function (v, g) {
      var g$1 = reflexive ? Curry._3(B.remove_edge, g, v, v) : g;
      return Curry._4(B.G.fold_succ, (function (sv, g) {
                    return Curry._4(B.G.fold_pred, (function (pv, g) {
                                  if (Curry._2(B.G.V.equal, pv, v) || Curry._2(B.G.V.equal, sv, v)) {
                                    return g;
                                  } else {
                                    return Curry._3(B.remove_edge, g, pv, sv);
                                  }
                                }), g, v, g);
                  }), g$1, v, g$1);
    };
    return Curry._3(B.G.fold_vertex, phi, g0, g0);
  };
  var transitive_reduction = function (reflexiveOpt, g0) {
    var reflexive = reflexiveOpt !== undefined ? reflexiveOpt : false;
    return replace_by_transitive_reduction(reflexive, Curry._1(B.copy, g0));
  };
  return {
          transitive_closure: transitive_closure,
          add_transitive_closure: add_transitive_closure,
          transitive_reduction: transitive_reduction,
          replace_by_transitive_reduction: replace_by_transitive_reduction,
          mirror: mirror,
          complement: complement,
          intersect: intersect,
          union: union
        };
}

function Choose(funarg) {
  var Found_Vertex = /* @__PURE__ */Caml_exceptions.create("Oper.Choose(G).Found_Vertex");
  var choose_vertex = function (g) {
    try {
      Curry._2(funarg.iter_vertex, (function (v) {
              throw {
                    RE_EXN_ID: Found_Vertex,
                    _1: v,
                    Error: new Error()
                  };
            }), g);
      return Pervasives.invalid_arg("choose_vertex");
    }
    catch (raw_v){
      var v = Caml_js_exceptions.internalToOCamlException(raw_v);
      if (v.RE_EXN_ID === Found_Vertex) {
        return v._1;
      }
      throw v;
    }
  };
  var Found_Edge = /* @__PURE__ */Caml_exceptions.create("Oper.Choose(G).Found_Edge");
  var choose_edge = function (g) {
    try {
      Curry._2(funarg.iter_edges_e, (function (v) {
              throw {
                    RE_EXN_ID: Found_Edge,
                    _1: v,
                    Error: new Error()
                  };
            }), g);
      return Pervasives.invalid_arg("choose_vertex");
    }
    catch (raw_v){
      var v = Caml_js_exceptions.internalToOCamlException(raw_v);
      if (v.RE_EXN_ID === Found_Edge) {
        return v._1;
      }
      throw v;
    }
  };
  return {
          choose_vertex: choose_vertex,
          choose_edge: choose_edge
        };
}

function Neighbourhood(funarg) {
  var Vertex_Set = $$Set.Make(funarg.V);
  var set_from_vertex = function (g, v) {
    return Curry._4(funarg.fold_succ, (function (v$p, s) {
                  if (Curry._2(funarg.V.equal, v, v$p)) {
                    return s;
                  } else {
                    return Curry._2(Vertex_Set.add, v$p, s);
                  }
                }), g, v, Vertex_Set.empty);
  };
  var list_from_vertex = function (g, v) {
    var aux = function (param) {
      if (!param) {
        return /* [] */0;
      }
      var l = param.tl;
      var v$p = param.hd;
      if (!Curry._2(funarg.V.equal, v, v$p)) {
        return {
                hd: v$p,
                tl: aux(l)
              };
      }
      if (List.exists(Curry._1(funarg.V.equal, v), l)) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "oper.ml",
                175,
                10
              ],
              Error: new Error()
            };
      }
      return l;
    };
    return aux(Curry._2(funarg.succ, g, v));
  };
  var set_from_vertices = function (g, l) {
    var env_init = List.fold_left((function (s, v) {
            return Curry._2(Vertex_Set.add, v, s);
          }), Vertex_Set.empty, l);
    var add = function (x, s) {
      if (Curry._2(Vertex_Set.mem, x, env_init)) {
        return s;
      } else {
        return Curry._2(Vertex_Set.add, x, s);
      }
    };
    return List.fold_left((function (s, v) {
                  return Curry._4(funarg.fold_succ, add, g, v, s);
                }), Vertex_Set.empty, l);
  };
  var list_from_vertices = function (g, l) {
    return Curry._1(Vertex_Set.elements, set_from_vertices(g, l));
  };
  return {
          Vertex_Set: Vertex_Set,
          list_from_vertex: list_from_vertex,
          set_from_vertex: set_from_vertex,
          list_from_vertices: list_from_vertices,
          set_from_vertices: set_from_vertices
        };
}

export {
  Make ,
  P ,
  I ,
  Choose ,
  Neighbourhood ,
  
}
/* No side effect */
