// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Set from "rescript/lib/es6/set.js";
import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Queue from "rescript/lib/es6/queue.js";
import * as Stack from "rescript/lib/es6/stack.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function Mark(G) {
  var dfs = function (g) {
    Curry._1(G.Mark.clear, g);
    var n = {
      contents: 0
    };
    var visit = function (v) {
      if (Curry._1(G.Mark.get, v) === 0) {
        n.contents = n.contents + 1 | 0;
        Curry._2(G.Mark.set, v, n.contents);
        return Curry._3(G.iter_succ, visit, g, v);
      }
      
    };
    return Curry._2(G.iter_vertex, visit, g);
  };
  var has_cycle = function (g) {
    Curry._1(G.Mark.clear, g);
    var visit = function (v) {
      Curry._2(G.Mark.set, v, 1);
      Curry._3(G.iter_succ, (function (w) {
              var m = Curry._1(G.Mark.get, w);
              if (m === 1) {
                throw {
                      RE_EXN_ID: Pervasives.Exit,
                      Error: new Error()
                    };
              }
              if (m === 0) {
                return visit(w);
              }
              
            }), g, v);
      return Curry._2(G.Mark.set, v, 2);
    };
    try {
      Curry._2(G.iter_vertex, (function (v) {
              if (Curry._1(G.Mark.get, v) === 0) {
                return visit(v);
              }
              
            }), g);
      return false;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Pervasives.Exit) {
        return true;
      }
      throw exn;
    }
  };
  return {
          dfs: dfs,
          has_cycle: has_cycle
        };
}

function Dfs(funarg) {
  var $$let = funarg.V;
  var H = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var fold = function (f, i, g) {
    var h = Curry._1(H.create, 97);
    var s = Stack.create(undefined);
    var push = function (v) {
      if (!Curry._2(H.mem, h, v)) {
        Curry._3(H.add, h, v, undefined);
        return Stack.push(v, s);
      }
      
    };
    return Curry._3(funarg.fold_vertex, (function (v, s$1) {
                  push(v);
                  var _acc = s$1;
                  while(true) {
                    var acc = _acc;
                    if (Stack.is_empty(s)) {
                      return acc;
                    }
                    var v$1 = Stack.pop(s);
                    var ns = Curry._2(f, v$1, acc);
                    Curry._3(funarg.iter_succ, push, g, v$1);
                    _acc = ns;
                    continue ;
                  };
                }), g, i);
  };
  var iter = function (preOpt, postOpt, g) {
    var pre = preOpt !== undefined ? preOpt : (function (param) {
          
        });
    var post = postOpt !== undefined ? postOpt : (function (param) {
          
        });
    var h = Curry._1(H.create, 97);
    var visit = function (v) {
      if (!Curry._2(H.mem, h, v)) {
        Curry._3(H.add, h, v, undefined);
        Curry._1(pre, v);
        Curry._3(funarg.iter_succ, visit, g, v);
        return Curry._1(post, v);
      }
      
    };
    return Curry._2(funarg.iter_vertex, visit, g);
  };
  var postfix = function (post, g) {
    return iter(undefined, post, g);
  };
  var fold_component = function (f, i, g, v0) {
    var h = Curry._1(H.create, 97);
    var s = Stack.create(undefined);
    var push = function (v) {
      if (!Curry._2(H.mem, h, v)) {
        Curry._3(H.add, h, v, undefined);
        return Stack.push(v, s);
      }
      
    };
    push(v0);
    var _acc = i;
    while(true) {
      var acc = _acc;
      if (Stack.is_empty(s)) {
        return acc;
      }
      var v = Stack.pop(s);
      var ns = Curry._2(f, v, acc);
      Curry._3(funarg.iter_succ, push, g, v);
      _acc = ns;
      continue ;
    };
  };
  var iter_component = function (preOpt, postOpt, g, v) {
    var pre = preOpt !== undefined ? preOpt : (function (param) {
          
        });
    var post = postOpt !== undefined ? postOpt : (function (param) {
          
        });
    var h = Curry._1(H.create, 97);
    var visit = function (v) {
      Curry._3(H.add, h, v, undefined);
      Curry._1(pre, v);
      Curry._3(funarg.iter_succ, (function (w) {
              if (!Curry._2(H.mem, h, w)) {
                return visit(w);
              }
              
            }), g, v);
      return Curry._1(post, v);
    };
    return visit(v);
  };
  var postfix_component = function (post, g) {
    var partial_arg = post;
    return function (param) {
      return iter_component(undefined, partial_arg, g, param);
    };
  };
  var has_cycle = function (g) {
    if (funarg.is_directed) {
      var h = Curry._1(H.create, 97);
      var stack = Stack.create(undefined);
      try {
        Curry._2(funarg.iter_vertex, (function (v) {
                if (!Curry._2(H.mem, h, v)) {
                  Stack.push(v, stack);
                  while(!Stack.is_empty(stack)) {
                    var v$1 = Stack.top(stack);
                    if (Curry._2(H.mem, h, v$1)) {
                      Curry._3(H.replace, h, v$1, false);
                      Stack.pop(stack);
                    } else {
                      Curry._3(H.add, h, v$1, true);
                      Curry._3(funarg.iter_succ, (function (w) {
                              try {
                                if (!Curry._2(H.find, h, w)) {
                                  return ;
                                }
                                throw {
                                      RE_EXN_ID: Pervasives.Exit,
                                      Error: new Error()
                                    };
                              }
                              catch (raw_exn){
                                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                                if (exn.RE_EXN_ID === "Not_found") {
                                  return Stack.push(w, stack);
                                }
                                throw exn;
                              }
                            }), g, v$1);
                    }
                  };
                  return ;
                }
                
              }), g);
        return false;
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === Pervasives.Exit) {
          return true;
        }
        throw exn;
      }
    } else {
      var h$1 = Curry._1(H.create, 97);
      var father = Curry._1(H.create, 97);
      var is_father = function (u, v) {
        try {
          return Curry._2(funarg.V.equal, Curry._2(H.find, father, v), u);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === "Not_found") {
            return false;
          }
          throw exn;
        }
      };
      var stack$1 = Stack.create(undefined);
      try {
        Curry._2(funarg.iter_vertex, (function (v) {
                if (!Curry._2(H.mem, h$1, v)) {
                  Stack.push(v, stack$1);
                  while(!Stack.is_empty(stack$1)) {
                    var v$1 = Stack.top(stack$1);
                    if (Curry._2(H.mem, h$1, v$1)) {
                      Curry._2(H.remove, father, v$1);
                      Curry._3(H.replace, h$1, v$1, false);
                      Stack.pop(stack$1);
                    } else {
                      Curry._3(H.add, h$1, v$1, true);
                      Curry._3(funarg.iter_succ, (function(v$1){
                          return function (w) {
                            try {
                              if (!(Curry._2(H.find, h$1, w) && !is_father(w, v$1))) {
                                return ;
                              }
                              throw {
                                    RE_EXN_ID: Pervasives.Exit,
                                    Error: new Error()
                                  };
                            }
                            catch (raw_exn){
                              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                              if (exn.RE_EXN_ID === "Not_found") {
                                Curry._3(H.add, father, w, v$1);
                                return Stack.push(w, stack$1);
                              }
                              throw exn;
                            }
                          }
                          }(v$1)), g, v$1);
                    }
                  };
                  return ;
                }
                
              }), g);
        return false;
      }
      catch (raw_exn$1){
        var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.RE_EXN_ID === Pervasives.Exit) {
          return true;
        }
        throw exn$1;
      }
    }
  };
  var iter$1 = function (f, g) {
    var h = Curry._1(H.create, 97);
    var stack = Stack.create(undefined);
    return Curry._2(funarg.iter_vertex, (function (v) {
                  if (!Curry._2(H.mem, h, v)) {
                    Stack.push(v, stack);
                    while(!Stack.is_empty(stack)) {
                      var v$1 = Stack.pop(stack);
                      if (!Curry._2(H.mem, h, v$1)) {
                        Curry._3(H.add, h, v$1, undefined);
                        Curry._1(f, v$1);
                        Curry._3(funarg.iter_succ, (function (w) {
                                if (!Curry._2(H.mem, h, w)) {
                                  return Stack.push(w, stack);
                                }
                                
                              }), g, v$1);
                      }
                      
                    };
                    return ;
                  }
                  
                }), g);
  };
  var iter_component$1 = function (f, g, v0) {
    var h = Curry._1(H.create, 97);
    var stack = Stack.create(undefined);
    Stack.push(v0, stack);
    while(!Stack.is_empty(stack)) {
      var v = Stack.pop(stack);
      if (!Curry._2(H.mem, h, v)) {
        Curry._3(H.add, h, v, undefined);
        Curry._1(f, v);
        Curry._3(funarg.iter_succ, (function (w) {
                if (!Curry._2(H.mem, h, w)) {
                  return Stack.push(w, stack);
                }
                
              }), g, v);
      }
      
    };
    
  };
  var S = $$Set.Make(funarg.V);
  var start = function (g) {
    var st = Curry._3(funarg.fold_vertex, (function (v, st) {
            return {
                    hd: v,
                    tl: st
                  };
          }), g, /* [] */0);
    return [
            S.empty,
            st,
            g
          ];
  };
  var get = function (param) {
    var st = param[1];
    if (st) {
      return st.hd;
    }
    throw {
          RE_EXN_ID: Pervasives.Exit,
          Error: new Error()
        };
  };
  var step = function (param) {
    var st = param[1];
    if (st) {
      var v = st.hd;
      var g = param[2];
      var s$p = Curry._2(S.add, v, param[0]);
      var st$p = Curry._4(funarg.fold_succ, (function (w, st) {
              return {
                      hd: w,
                      tl: st
                    };
            }), g, v, st.tl);
      var clean = function (_st) {
        while(true) {
          var st = _st;
          if (!st) {
            return st;
          }
          if (!Curry._2(S.mem, st.hd, s$p)) {
            return st;
          }
          _st = st.tl;
          continue ;
        };
      };
      return [
              s$p,
              clean(st$p),
              g
            ];
    }
    throw {
          RE_EXN_ID: Pervasives.Exit,
          Error: new Error()
        };
  };
  return {
          iter: iter,
          prefix: iter$1,
          postfix: postfix,
          iter_component: iter_component,
          prefix_component: iter_component$1,
          postfix_component: postfix_component,
          fold: fold,
          fold_component: fold_component,
          start: start,
          step: step,
          get: get,
          has_cycle: has_cycle
        };
}

function Bfs(funarg) {
  var $$let = funarg.V;
  var H = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var fold = function (f, i, g) {
    var h = Curry._1(H.create, 97);
    var q = Queue.create(undefined);
    var push = function (v) {
      if (!Curry._2(H.mem, h, v)) {
        Curry._3(H.add, h, v, undefined);
        return Queue.add(v, q);
      }
      
    };
    return Curry._3(funarg.fold_vertex, (function (v, s) {
                  push(v);
                  var _s = s;
                  while(true) {
                    var s$1 = _s;
                    if (Queue.is_empty(q)) {
                      return s$1;
                    }
                    var v$1 = Queue.pop(q);
                    var ns = Curry._2(f, v$1, s$1);
                    Curry._3(funarg.iter_succ, push, g, v$1);
                    _s = ns;
                    continue ;
                  };
                }), g, i);
  };
  var iter = function (f) {
    return function (param) {
      return fold((function (v, param) {
                    return Curry._1(f, v);
                  }), undefined, param);
    };
  };
  var fold_component = function (f, i, g, v0) {
    var h = Curry._1(H.create, 97);
    var q = Queue.create(undefined);
    var push = function (v) {
      if (!Curry._2(H.mem, h, v)) {
        Curry._3(H.add, h, v, undefined);
        return Queue.add(v, q);
      }
      
    };
    push(v0);
    var _s = i;
    while(true) {
      var s = _s;
      if (Queue.is_empty(q)) {
        return s;
      }
      var v = Queue.pop(q);
      var ns = Curry._2(f, v, s);
      Curry._3(funarg.iter_succ, push, g, v);
      _s = ns;
      continue ;
    };
  };
  var iter_component = function (f) {
    return function (param, param$1) {
      return fold_component((function (v, param) {
                    return Curry._1(f, v);
                  }), undefined, param, param$1);
    };
  };
  var Empty = /* @__PURE__ */Caml_exceptions.create("Traverse.Bfs(G).Q.Empty");
  var is_empty = function (param) {
    if (param[0] || param[1]) {
      return false;
    } else {
      return true;
    }
  };
  var push = function (x, param) {
    return [
            {
              hd: x,
              tl: param[0]
            },
            param[1]
          ];
  };
  var pop = function (param) {
    var i = param[0];
    var match = param[1];
    if (match) {
      return [
              match.hd,
              [
                i,
                match.tl
              ]
            ];
    }
    if (i) {
      var match$1 = List.rev(i);
      if (match$1) {
        return [
                match$1.hd,
                [
                  /* [] */0,
                  match$1.tl
                ]
              ];
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "traverse.ml",
              294,
              16
            ],
            Error: new Error()
          };
    }
    throw {
          RE_EXN_ID: Empty,
          Error: new Error()
        };
  };
  var S = $$Set.Make(funarg.V);
  var start = function (g) {
    var s = Curry._3(funarg.fold_vertex, S.add, g, S.empty);
    return [
            s,
            [
              /* [] */0,
              /* [] */0
            ],
            g
          ];
  };
  var get = function (param) {
    var q = param[1];
    var s = param[0];
    if (!is_empty(q)) {
      return pop(q)[0];
    }
    if (Curry._1(S.is_empty, s)) {
      throw {
            RE_EXN_ID: Pervasives.Exit,
            Error: new Error()
          };
    }
    return Curry._1(S.choose, s);
  };
  var step = function (param) {
    var g = param[2];
    var q = param[1];
    var s = param[0];
    var push$1 = function (v, acc) {
      var s = acc[0];
      if (Curry._2(S.mem, v, s)) {
        return [
                Curry._2(S.remove, v, s),
                push(v, acc[1])
              ];
      } else {
        return acc;
      }
    };
    var match;
    if (is_empty(q)) {
      if (Curry._1(S.is_empty, s)) {
        throw {
              RE_EXN_ID: Pervasives.Exit,
              Error: new Error()
            };
      }
      var v = Curry._1(S.choose, s);
      match = [
        v,
        Curry._2(S.remove, v, s),
        q
      ];
    } else {
      var match$1 = pop(q);
      match = [
        match$1[0],
        s,
        match$1[1]
      ];
    }
    var match$2 = Curry._4(funarg.fold_succ, push$1, g, match[0], [
          match[1],
          match[2]
        ]);
    return [
            match$2[0],
            match$2[1],
            g
          ];
  };
  return {
          iter: iter,
          iter_component: iter_component,
          fold: fold,
          fold_component: fold_component,
          start: start,
          step: step,
          get: get
        };
}

export {
  Dfs ,
  Bfs ,
  Mark ,
  
}
/* No side effect */
