// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Stack = require("rescript/lib/js/stack.js");
var Hashtbl = require("rescript/lib/js/hashtbl.js");
var Traverse = require("./traverse.bs.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function Make(G) {
  var $$let = G.V;
  var H = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var coloring = function (g, k) {
    var h = Curry._1(H.create, 97);
    var nb_vertex = G.nb_vertex;
    var out_degree = G.out_degree;
    var iter_vertex = G.iter_vertex;
    var iter_succ = G.iter_succ;
    var get = function (v) {
      try {
        return Curry._2(H.find, h, v);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return 0;
        }
        throw exn;
      }
    };
    var NoColoring = /* @__PURE__ */Caml_exceptions.create("Coloring.Mark(G).NoColoring");
    var Bfs = Traverse.Bfs({
          is_directed: G.is_directed,
          V: G.V,
          iter_vertex: iter_vertex,
          fold_vertex: G.fold_vertex,
          iter_succ: iter_succ,
          fold_succ: G.fold_succ
        });
    var coloring$1 = function (g, k) {
      var stack = Stack.create(undefined);
      var nb_to_color = Curry._1(nb_vertex, g);
      var count = {
        contents: 1
      };
      while(count.contents > 0) {
        count.contents = 0;
        Curry._2(iter_vertex, (function (v) {
                if (get(v) === 0 && Curry._2(out_degree, g, v) < k) {
                  count.contents = count.contents + 1 | 0;
                  Curry._3(H.replace, h, v, k + 1 | 0);
                  return Stack.push(v, stack);
                }
                
              }), g);
        nb_to_color = nb_to_color - count.contents | 0;
      };
      var try_color = function (v, i) {
        Curry._3(H.replace, h, v, i);
        return Curry._3(iter_succ, (function (w) {
                      if (get(w) !== i) {
                        return ;
                      }
                      throw {
                            RE_EXN_ID: NoColoring,
                            Error: new Error()
                          };
                    }), g, v);
      };
      if (nb_to_color > 0) {
        var iterate = function (_iter) {
          while(true) {
            var iter = _iter;
            var v = Curry._1(Bfs.get, iter);
            var m = get(v);
            if (m > 0) {
              _iter = Curry._1(Bfs.step, iter);
              continue ;
            }
            for(var i = 1; i <= k; ++i){
              try {
                try_color(v, i);
                iterate(Curry._1(Bfs.step, iter));
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.RE_EXN_ID !== NoColoring) {
                  throw exn;
                }
                
              }
            }
            Curry._3(H.replace, h, v, 0);
            throw {
                  RE_EXN_ID: NoColoring,
                  Error: new Error()
                };
          };
        };
        try {
          iterate(Curry._1(Bfs.start, g));
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID !== Pervasives.Exit) {
            throw exn;
          }
          
        }
      }
      return Stack.iter((function (v) {
                    try {
                      for(var i = 1; i <= k; ++i){
                        try {
                          try_color(v, i);
                          throw {
                                RE_EXN_ID: Pervasives.Exit,
                                Error: new Error()
                              };
                        }
                        catch (raw_exn){
                          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                          if (exn.RE_EXN_ID !== NoColoring) {
                            throw exn;
                          }
                          
                        }
                      }
                      throw {
                            RE_EXN_ID: NoColoring,
                            Error: new Error()
                          };
                    }
                    catch (raw_exn$1){
                      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                      if (exn$1.RE_EXN_ID === Pervasives.Exit) {
                        return ;
                      }
                      throw exn$1;
                    }
                  }), stack);
    };
    coloring$1(g, k);
    return h;
  };
  return {
          H: H,
          coloring: coloring
        };
}

function Mark(funarg) {
  var NoColoring = /* @__PURE__ */Caml_exceptions.create("Coloring.Mark(G).NoColoring");
  var Bfs = Traverse.Bfs({
        is_directed: funarg.is_directed,
        V: funarg.V,
        iter_vertex: funarg.iter_vertex,
        fold_vertex: funarg.fold_vertex,
        iter_succ: funarg.iter_succ,
        fold_succ: funarg.fold_succ
      });
  var coloring = function (g, k) {
    var stack = Stack.create(undefined);
    var nb_to_color = Curry._1(funarg.nb_vertex, g);
    var count = {
      contents: 1
    };
    while(count.contents > 0) {
      count.contents = 0;
      Curry._2(funarg.iter_vertex, (function (v) {
              if (Curry._1(funarg.Mark.get, v) === 0 && Curry._2(funarg.out_degree, g, v) < k) {
                count.contents = count.contents + 1 | 0;
                Curry._2(funarg.Mark.set, v, k + 1 | 0);
                return Stack.push(v, stack);
              }
              
            }), g);
      nb_to_color = nb_to_color - count.contents | 0;
    };
    var try_color = function (v, i) {
      Curry._2(funarg.Mark.set, v, i);
      return Curry._3(funarg.iter_succ, (function (w) {
                    if (Curry._1(funarg.Mark.get, w) !== i) {
                      return ;
                    }
                    throw {
                          RE_EXN_ID: NoColoring,
                          Error: new Error()
                        };
                  }), g, v);
    };
    if (nb_to_color > 0) {
      var iterate = function (_iter) {
        while(true) {
          var iter = _iter;
          var v = Curry._1(Bfs.get, iter);
          var m = Curry._1(funarg.Mark.get, v);
          if (m > 0) {
            _iter = Curry._1(Bfs.step, iter);
            continue ;
          }
          for(var i = 1; i <= k; ++i){
            try {
              try_color(v, i);
              iterate(Curry._1(Bfs.step, iter));
            }
            catch (raw_exn){
              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.RE_EXN_ID !== NoColoring) {
                throw exn;
              }
              
            }
          }
          Curry._2(funarg.Mark.set, v, 0);
          throw {
                RE_EXN_ID: NoColoring,
                Error: new Error()
              };
        };
      };
      try {
        iterate(Curry._1(Bfs.start, g));
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID !== Pervasives.Exit) {
          throw exn;
        }
        
      }
    }
    return Stack.iter((function (v) {
                  try {
                    for(var i = 1; i <= k; ++i){
                      try {
                        try_color(v, i);
                        throw {
                              RE_EXN_ID: Pervasives.Exit,
                              Error: new Error()
                            };
                      }
                      catch (raw_exn){
                        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        if (exn.RE_EXN_ID !== NoColoring) {
                          throw exn;
                        }
                        
                      }
                    }
                    throw {
                          RE_EXN_ID: NoColoring,
                          Error: new Error()
                        };
                  }
                  catch (raw_exn$1){
                    var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                    if (exn$1.RE_EXN_ID === Pervasives.Exit) {
                      return ;
                    }
                    throw exn$1;
                  }
                }), stack);
  };
  return {
          NoColoring: NoColoring,
          coloring: coloring
        };
}

exports.Make = Make;
exports.Mark = Mark;
/* No side effect */
