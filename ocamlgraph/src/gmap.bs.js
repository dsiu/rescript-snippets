// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Map from "rescript/lib/es6/map.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function Vertex(funarg, funarg$1) {
  var $$let = funarg.V;
  var H = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var vertices = Curry._1(H.create, 97);
  var convert_vertex = function (f, x) {
    try {
      return Curry._2(H.find, vertices, x);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        var x$p = Curry._1(f, x);
        Curry._3(H.add, vertices, x, x$p);
        return x$p;
      }
      throw exn;
    }
  };
  var map = function (f, g) {
    Curry._1(H.clear, vertices);
    return Curry._3(funarg.fold_vertex, (function (x, g) {
                  return Curry._2(funarg$1.add_vertex, g, convert_vertex(f, x));
                }), g, Curry._1(funarg$1.empty, undefined));
  };
  var filter_map = function (f, g) {
    return Curry._3(funarg.fold_vertex, (function (x, g) {
                  var e = Curry._1(f, x);
                  if (e !== undefined) {
                    return Curry._2(funarg$1.add_vertex, g, Caml_option.valFromOption(e));
                  } else {
                    return g;
                  }
                }), g, Curry._1(funarg$1.empty, undefined));
  };
  return {
          map: map,
          filter_map: filter_map
        };
}

function Edge(funarg, funarg$1) {
  var M = $$Map.Make(funarg.E);
  var edges = {
    contents: M.empty
  };
  var convert_edge = function (f, x) {
    try {
      return Curry._2(M.find, x, edges.contents);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        var x$p = Curry._1(f, x);
        edges.contents = Curry._3(M.add, x, x$p, edges.contents);
        return x$p;
      }
      throw exn;
    }
  };
  var map = function (f, g) {
    edges.contents = M.empty;
    return Curry._3(funarg.fold_edges_e, (function (x, g) {
                  return Curry._2(funarg$1.add_edge_e, g, convert_edge(f, x));
                }), g, Curry._1(funarg$1.empty, undefined));
  };
  var filter_map = function (f, g) {
    return Curry._3(funarg.fold_edges_e, (function (x, g) {
                  var e = Curry._1(f, x);
                  if (e !== undefined) {
                    return Curry._2(funarg$1.add_edge_e, g, Caml_option.valFromOption(e));
                  } else {
                    return g;
                  }
                }), g, Curry._1(funarg$1.empty, undefined));
  };
  return {
          map: map,
          filter_map: filter_map
        };
}

export {
  Vertex ,
  Edge ,
  
}
/* No side effect */
