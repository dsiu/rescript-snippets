// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Flow from "./flow.bs.js";
import * as Oper from "./oper.bs.js";
import * as Path from "./path.bs.js";
import * as Rand from "./rand.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Builder from "./builder.bs.js";
import * as Classic from "./classic.bs.js";
import * as Kruskal from "./kruskal.bs.js";
import * as Traverse from "./traverse.bs.js";
import * as Components from "./components.bs.js";
import * as Imperative from "./imperative.bs.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Topological from "./topological.bs.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var compare = Caml.caml_int_compare;

var I = {
  compare: compare,
  $$default: 0
};

var partial_arg = {};

var G = Imperative.Digraph.AbstractLabeled(partial_arg, I);

var V = G.V;

var iter_vertex = G.iter_vertex;

var Found = /* @__PURE__ */Caml_exceptions.create("Pack.Generic(G).Found");

function find_vertex(g, i) {
  try {
    Curry._2(iter_vertex, (function (v) {
            if (Curry._1(V.label, v) !== i) {
              return ;
            }
            throw {
                  RE_EXN_ID: Found,
                  _1: v,
                  Error: new Error()
                };
          }), g);
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  catch (raw_v){
    var v = Caml_js_exceptions.internalToOCamlException(raw_v);
    if (v.RE_EXN_ID === Found) {
      return v._1;
    }
    throw v;
  }
}

var Builder$1 = Builder.I(G);

var Dfs = Traverse.Dfs({
      is_directed: G.is_directed,
      V: G.V,
      iter_vertex: G.iter_vertex,
      fold_vertex: G.fold_vertex,
      iter_succ: G.iter_succ,
      fold_succ: G.fold_succ
    });

var Bfs = Traverse.Bfs({
      is_directed: G.is_directed,
      V: G.V,
      iter_vertex: G.iter_vertex,
      fold_vertex: G.fold_vertex,
      iter_succ: G.iter_succ,
      fold_succ: G.fold_succ
    });

var Marking = Traverse.Mark({
      V: {},
      iter_vertex: G.iter_vertex,
      iter_succ: G.iter_succ,
      Mark: G.Mark
    });

var Classic$1 = Classic.I(G);

var Rand$1 = Rand.I(G);

var Components$1 = Components.Make({
      V: G.V,
      iter_vertex: G.iter_vertex,
      iter_succ: G.iter_succ
    });

function weight(e) {
  return Curry._1(G.E.label, e);
}

function add(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var compare$1 = Caml.caml_int_compare;

var $$let = G.E;

var partial_arg_V = G.V;

var partial_arg_E = {
  label: $$let.label,
  src: $$let.src,
  dst: $$let.dst,
  create: $$let.create
};

var partial_arg_iter_vertex = G.iter_vertex;

var partial_arg_fold_vertex = G.fold_vertex;

var partial_arg_iter_succ = G.iter_succ;

var partial_arg_iter_succ_e = G.iter_succ_e;

var partial_arg_fold_edges_e = G.fold_edges_e;

var partial_arg_nb_vertex = G.nb_vertex;

var partial_arg$1 = {
  V: partial_arg_V,
  E: partial_arg_E,
  iter_vertex: partial_arg_iter_vertex,
  fold_vertex: partial_arg_fold_vertex,
  iter_succ: partial_arg_iter_succ,
  iter_succ_e: partial_arg_iter_succ_e,
  fold_edges_e: partial_arg_fold_edges_e,
  nb_vertex: partial_arg_nb_vertex
};

var include = Path.Dijkstra(partial_arg$1, {
      weight: weight,
      compare: compare$1,
      add: add,
      zero: 0
    });

var $$let$1 = G.E;

var partial_arg_V$1 = G.V;

var partial_arg_E$1 = {
  label: $$let$1.label,
  src: $$let$1.src,
  dst: $$let$1.dst,
  create: $$let$1.create
};

var partial_arg_iter_vertex$1 = G.iter_vertex;

var partial_arg_fold_vertex$1 = G.fold_vertex;

var partial_arg_iter_succ$1 = G.iter_succ;

var partial_arg_iter_succ_e$1 = G.iter_succ_e;

var partial_arg_fold_edges_e$1 = G.fold_edges_e;

var partial_arg_nb_vertex$1 = G.nb_vertex;

var partial_arg$2 = {
  V: partial_arg_V$1,
  E: partial_arg_E$1,
  iter_vertex: partial_arg_iter_vertex$1,
  fold_vertex: partial_arg_fold_vertex$1,
  iter_succ: partial_arg_iter_succ$1,
  iter_succ_e: partial_arg_iter_succ_e$1,
  fold_edges_e: partial_arg_fold_edges_e$1,
  nb_vertex: partial_arg_nb_vertex$1
};

Path.Johnson(partial_arg$2, {
      weight: weight,
      compare: compare$1,
      add: add,
      zero: 0,
      sub: sub
    });

var $$let$2 = G.E;

var partial_arg_V$2 = G.V;

var partial_arg_E$2 = {
  label: $$let$2.label,
  src: $$let$2.src,
  dst: $$let$2.dst,
  create: $$let$2.create
};

var partial_arg_iter_vertex$2 = G.iter_vertex;

var partial_arg_fold_vertex$2 = G.fold_vertex;

var partial_arg_iter_succ$2 = G.iter_succ;

var partial_arg_iter_succ_e$2 = G.iter_succ_e;

var partial_arg_fold_edges_e$2 = G.fold_edges_e;

var partial_arg_nb_vertex$2 = G.nb_vertex;

var partial_arg$3 = {
  V: partial_arg_V$2,
  E: partial_arg_E$2,
  iter_vertex: partial_arg_iter_vertex$2,
  fold_vertex: partial_arg_fold_vertex$2,
  iter_succ: partial_arg_iter_succ$2,
  iter_succ_e: partial_arg_iter_succ_e$2,
  fold_edges_e: partial_arg_fold_edges_e$2,
  nb_vertex: partial_arg_nb_vertex$2
};

var BF = Path.BellmanFord(partial_arg$3, {
      weight: weight,
      compare: compare$1,
      add: add,
      zero: 0
    });

function max_capacity(x) {
  return x;
}

function min_capacity(param) {
  return 0;
}

function flow(param) {
  return 0;
}

function add$1(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub$1(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var compare$2 = Caml.caml_int_compare;

var $$let$3 = G.V;

var $$let$4 = G.E;

var partial_arg_V$3 = {
  hash: $$let$3.hash,
  equal: $$let$3.equal
};

var partial_arg_E$3 = {
  src: $$let$4.src,
  dst: $$let$4.dst,
  label: $$let$4.label
};

var partial_arg_iter_succ_e$3 = G.iter_succ_e;

var partial_arg_iter_pred_e = G.iter_pred_e;

var partial_arg$4 = {
  V: partial_arg_V$3,
  E: partial_arg_E$3,
  iter_succ_e: partial_arg_iter_succ_e$3,
  iter_pred_e: partial_arg_iter_pred_e
};

var FF = Flow.Ford_Fulkerson(partial_arg$4, {
      max_capacity: max_capacity,
      flow: flow,
      add: add$1,
      sub: sub$1,
      zero: 0,
      compare: compare$2,
      min_capacity: min_capacity
    });

function ford_fulkerson(g) {
  if (!G.is_directed) {
    Pervasives.invalid_arg("ford_fulkerson: not a directed graph");
  }
  return Curry._1(FF.maxflow, g);
}

var partial_arg_V$4 = G.V;

var partial_arg_E$4 = G.E;

var partial_arg_nb_vertex$3 = G.nb_vertex;

var partial_arg_nb_edges = G.nb_edges;

var partial_arg_fold_edges_e$3 = G.fold_edges_e;

var partial_arg_fold_succ_e = G.fold_succ_e;

var partial_arg_fold_pred_e = G.fold_pred_e;

var partial_arg$5 = {
  V: partial_arg_V$4,
  E: partial_arg_E$4,
  nb_vertex: partial_arg_nb_vertex$3,
  nb_edges: partial_arg_nb_edges,
  fold_edges_e: partial_arg_fold_edges_e$3,
  fold_succ_e: partial_arg_fold_succ_e,
  fold_pred_e: partial_arg_fold_pred_e
};

var Goldberg = Flow.Goldberg_Tarjan(partial_arg$5, {
      max_capacity: max_capacity,
      flow: flow,
      add: add$1,
      sub: sub$1,
      zero: 0,
      compare: compare$2
    });

function goldberg_tarjan(g) {
  if (!G.is_directed) {
    Pervasives.invalid_arg("goldberg: not a directed graph");
  }
  return Curry._1(Goldberg.maxflow, g);
}

var include$1 = Oper.Make(Builder$1);

var PathCheck = Path.Check({
      V: G.V,
      iter_succ: G.iter_succ
    });

var include$2 = Topological.Make({
      V: G.V,
      iter_vertex: G.iter_vertex,
      iter_succ: G.iter_succ
    });

var S = Topological.Make_stable({
      V: G.V,
      iter_vertex: G.iter_vertex,
      iter_succ: G.iter_succ,
      in_degree: G.in_degree
    });

var compare$3 = Caml.caml_int_compare;

var Int = {
  compare: compare$3
};

var $$let$5 = G.E;

var partial_arg_V$5 = G.V;

var partial_arg_E$5 = {
  label: $$let$5.label,
  dst: $$let$5.dst,
  src: $$let$5.src
};

var partial_arg_fold_vertex$3 = G.fold_vertex;

var partial_arg_iter_edges_e = G.iter_edges_e;

var partial_arg$6 = {
  V: partial_arg_V$5,
  E: partial_arg_E$5,
  fold_vertex: partial_arg_fold_vertex$3,
  iter_edges_e: partial_arg_iter_edges_e
};

var include$3 = Kruskal.Make(partial_arg$6, Int);

var partial_arg$7 = {};

var G$1 = Imperative.Graph.AbstractLabeled(partial_arg$7, I);

var V$1 = G$1.V;

var iter_vertex$1 = G$1.iter_vertex;

var Found$1 = /* @__PURE__ */Caml_exceptions.create("Pack.Generic(G).Found");

function find_vertex$1(g, i) {
  try {
    Curry._2(iter_vertex$1, (function (v) {
            if (Curry._1(V$1.label, v) !== i) {
              return ;
            }
            throw {
                  RE_EXN_ID: Found$1,
                  _1: v,
                  Error: new Error()
                };
          }), g);
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  catch (raw_v){
    var v = Caml_js_exceptions.internalToOCamlException(raw_v);
    if (v.RE_EXN_ID === Found$1) {
      return v._1;
    }
    throw v;
  }
}

var Builder$2 = Builder.I(G$1);

var Dfs$1 = Traverse.Dfs({
      is_directed: G$1.is_directed,
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      fold_vertex: G$1.fold_vertex,
      iter_succ: G$1.iter_succ,
      fold_succ: G$1.fold_succ
    });

var Bfs$1 = Traverse.Bfs({
      is_directed: G$1.is_directed,
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      fold_vertex: G$1.fold_vertex,
      iter_succ: G$1.iter_succ,
      fold_succ: G$1.fold_succ
    });

var Marking$1 = Traverse.Mark({
      V: {},
      iter_vertex: G$1.iter_vertex,
      iter_succ: G$1.iter_succ,
      Mark: G$1.Mark
    });

var Classic$2 = Classic.I(G$1);

var Rand$2 = Rand.I(G$1);

var Components$2 = Components.Make({
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      iter_succ: G$1.iter_succ
    });

function weight$1(e) {
  return Curry._1(G$1.E.label, e);
}

function add$2(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub$2(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var compare$4 = Caml.caml_int_compare;

var $$let$6 = G$1.E;

var partial_arg_V$6 = G$1.V;

var partial_arg_E$6 = {
  label: $$let$6.label,
  src: $$let$6.src,
  dst: $$let$6.dst,
  create: $$let$6.create
};

var partial_arg_iter_vertex$3 = G$1.iter_vertex;

var partial_arg_fold_vertex$4 = G$1.fold_vertex;

var partial_arg_iter_succ$3 = G$1.iter_succ;

var partial_arg_iter_succ_e$4 = G$1.iter_succ_e;

var partial_arg_fold_edges_e$4 = G$1.fold_edges_e;

var partial_arg_nb_vertex$4 = G$1.nb_vertex;

var partial_arg$8 = {
  V: partial_arg_V$6,
  E: partial_arg_E$6,
  iter_vertex: partial_arg_iter_vertex$3,
  fold_vertex: partial_arg_fold_vertex$4,
  iter_succ: partial_arg_iter_succ$3,
  iter_succ_e: partial_arg_iter_succ_e$4,
  fold_edges_e: partial_arg_fold_edges_e$4,
  nb_vertex: partial_arg_nb_vertex$4
};

var include$4 = Path.Dijkstra(partial_arg$8, {
      weight: weight$1,
      compare: compare$4,
      add: add$2,
      zero: 0
    });

var $$let$7 = G$1.E;

var partial_arg_V$7 = G$1.V;

var partial_arg_E$7 = {
  label: $$let$7.label,
  src: $$let$7.src,
  dst: $$let$7.dst,
  create: $$let$7.create
};

var partial_arg_iter_vertex$4 = G$1.iter_vertex;

var partial_arg_fold_vertex$5 = G$1.fold_vertex;

var partial_arg_iter_succ$4 = G$1.iter_succ;

var partial_arg_iter_succ_e$5 = G$1.iter_succ_e;

var partial_arg_fold_edges_e$5 = G$1.fold_edges_e;

var partial_arg_nb_vertex$5 = G$1.nb_vertex;

var partial_arg$9 = {
  V: partial_arg_V$7,
  E: partial_arg_E$7,
  iter_vertex: partial_arg_iter_vertex$4,
  fold_vertex: partial_arg_fold_vertex$5,
  iter_succ: partial_arg_iter_succ$4,
  iter_succ_e: partial_arg_iter_succ_e$5,
  fold_edges_e: partial_arg_fold_edges_e$5,
  nb_vertex: partial_arg_nb_vertex$5
};

Path.Johnson(partial_arg$9, {
      weight: weight$1,
      compare: compare$4,
      add: add$2,
      zero: 0,
      sub: sub$2
    });

var $$let$8 = G$1.E;

var partial_arg_V$8 = G$1.V;

var partial_arg_E$8 = {
  label: $$let$8.label,
  src: $$let$8.src,
  dst: $$let$8.dst,
  create: $$let$8.create
};

var partial_arg_iter_vertex$5 = G$1.iter_vertex;

var partial_arg_fold_vertex$6 = G$1.fold_vertex;

var partial_arg_iter_succ$5 = G$1.iter_succ;

var partial_arg_iter_succ_e$6 = G$1.iter_succ_e;

var partial_arg_fold_edges_e$6 = G$1.fold_edges_e;

var partial_arg_nb_vertex$6 = G$1.nb_vertex;

var partial_arg$10 = {
  V: partial_arg_V$8,
  E: partial_arg_E$8,
  iter_vertex: partial_arg_iter_vertex$5,
  fold_vertex: partial_arg_fold_vertex$6,
  iter_succ: partial_arg_iter_succ$5,
  iter_succ_e: partial_arg_iter_succ_e$6,
  fold_edges_e: partial_arg_fold_edges_e$6,
  nb_vertex: partial_arg_nb_vertex$6
};

var BF$1 = Path.BellmanFord(partial_arg$10, {
      weight: weight$1,
      compare: compare$4,
      add: add$2,
      zero: 0
    });

function max_capacity$1(x) {
  return x;
}

function min_capacity$1(param) {
  return 0;
}

function flow$1(param) {
  return 0;
}

function add$3(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub$3(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var compare$5 = Caml.caml_int_compare;

var $$let$9 = G$1.V;

var $$let$10 = G$1.E;

var partial_arg_V$9 = {
  hash: $$let$9.hash,
  equal: $$let$9.equal
};

var partial_arg_E$9 = {
  src: $$let$10.src,
  dst: $$let$10.dst,
  label: $$let$10.label
};

var partial_arg_iter_succ_e$7 = G$1.iter_succ_e;

var partial_arg_iter_pred_e$1 = G$1.iter_pred_e;

var partial_arg$11 = {
  V: partial_arg_V$9,
  E: partial_arg_E$9,
  iter_succ_e: partial_arg_iter_succ_e$7,
  iter_pred_e: partial_arg_iter_pred_e$1
};

var FF$1 = Flow.Ford_Fulkerson(partial_arg$11, {
      max_capacity: max_capacity$1,
      flow: flow$1,
      add: add$3,
      sub: sub$3,
      zero: 0,
      compare: compare$5,
      min_capacity: min_capacity$1
    });

function ford_fulkerson$1(g) {
  if (!G$1.is_directed) {
    Pervasives.invalid_arg("ford_fulkerson: not a directed graph");
  }
  return Curry._1(FF$1.maxflow, g);
}

var partial_arg_V$10 = G$1.V;

var partial_arg_E$10 = G$1.E;

var partial_arg_nb_vertex$7 = G$1.nb_vertex;

var partial_arg_nb_edges$1 = G$1.nb_edges;

var partial_arg_fold_edges_e$7 = G$1.fold_edges_e;

var partial_arg_fold_succ_e$1 = G$1.fold_succ_e;

var partial_arg_fold_pred_e$1 = G$1.fold_pred_e;

var partial_arg$12 = {
  V: partial_arg_V$10,
  E: partial_arg_E$10,
  nb_vertex: partial_arg_nb_vertex$7,
  nb_edges: partial_arg_nb_edges$1,
  fold_edges_e: partial_arg_fold_edges_e$7,
  fold_succ_e: partial_arg_fold_succ_e$1,
  fold_pred_e: partial_arg_fold_pred_e$1
};

var Goldberg$1 = Flow.Goldberg_Tarjan(partial_arg$12, {
      max_capacity: max_capacity$1,
      flow: flow$1,
      add: add$3,
      sub: sub$3,
      zero: 0,
      compare: compare$5
    });

function goldberg_tarjan$1(g) {
  if (!G$1.is_directed) {
    Pervasives.invalid_arg("goldberg: not a directed graph");
  }
  return Curry._1(Goldberg$1.maxflow, g);
}

var include$5 = Oper.Make(Builder$2);

var PathCheck$1 = Path.Check({
      V: G$1.V,
      iter_succ: G$1.iter_succ
    });

var include$6 = Topological.Make({
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      iter_succ: G$1.iter_succ
    });

var S$1 = Topological.Make_stable({
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      iter_succ: G$1.iter_succ,
      in_degree: G$1.in_degree
    });

var compare$6 = Caml.caml_int_compare;

var Int$1 = {
  compare: compare$6
};

var $$let$11 = G$1.E;

var partial_arg_V$11 = G$1.V;

var partial_arg_E$11 = {
  label: $$let$11.label,
  dst: $$let$11.dst,
  src: $$let$11.src
};

var partial_arg_fold_vertex$7 = G$1.fold_vertex;

var partial_arg_iter_edges_e$1 = G$1.iter_edges_e;

var partial_arg$13 = {
  V: partial_arg_V$11,
  E: partial_arg_E$11,
  fold_vertex: partial_arg_fold_vertex$7,
  iter_edges_e: partial_arg_iter_edges_e$1
};

var include$7 = Kruskal.Make(partial_arg$13, Int$1);

var Digraph_E = G.E;

var Digraph_is_directed = G.is_directed;

var Digraph_create = G.create;

var Digraph_clear = G.clear;

var Digraph_copy = G.copy;

var Digraph_add_vertex = G.add_vertex;

var Digraph_remove_vertex = G.remove_vertex;

var Digraph_add_edge = G.add_edge;

var Digraph_add_edge_e = G.add_edge_e;

var Digraph_remove_edge = G.remove_edge;

var Digraph_remove_edge_e = G.remove_edge_e;

var Digraph_Mark = G.Mark;

var Digraph_is_empty = G.is_empty;

var Digraph_nb_vertex = G.nb_vertex;

var Digraph_nb_edges = G.nb_edges;

var Digraph_out_degree = G.out_degree;

var Digraph_in_degree = G.in_degree;

var Digraph_mem_vertex = G.mem_vertex;

var Digraph_mem_edge = G.mem_edge;

var Digraph_mem_edge_e = G.mem_edge_e;

var Digraph_find_edge = G.find_edge;

var Digraph_find_all_edges = G.find_all_edges;

var Digraph_succ = G.succ;

var Digraph_pred = G.pred;

var Digraph_succ_e = G.succ_e;

var Digraph_pred_e = G.pred_e;

var Digraph_iter_edges = G.iter_edges;

var Digraph_fold_vertex = G.fold_vertex;

var Digraph_fold_edges = G.fold_edges;

var Digraph_map_vertex = G.map_vertex;

var Digraph_iter_edges_e = G.iter_edges_e;

var Digraph_fold_edges_e = G.fold_edges_e;

var Digraph_iter_succ = G.iter_succ;

var Digraph_iter_pred = G.iter_pred;

var Digraph_fold_succ = G.fold_succ;

var Digraph_fold_pred = G.fold_pred;

var Digraph_iter_succ_e = G.iter_succ_e;

var Digraph_fold_succ_e = G.fold_succ_e;

var Digraph_iter_pred_e = G.iter_pred_e;

var Digraph_fold_pred_e = G.fold_pred_e;

var Digraph_transitive_closure = include$1.transitive_closure;

var Digraph_add_transitive_closure = include$1.add_transitive_closure;

var Digraph_transitive_reduction = include$1.transitive_reduction;

var Digraph_replace_by_transitive_reduction = include$1.replace_by_transitive_reduction;

var Digraph_mirror = include$1.mirror;

var Digraph_complement = include$1.complement;

var Digraph_intersect = include$1.intersect;

var Digraph_union = include$1.union;

var Digraph_Dfs = {
  iter: Dfs.iter,
  prefix: Dfs.prefix,
  postfix: Dfs.postfix,
  fold: Dfs.fold,
  iter_component: Dfs.iter_component,
  prefix_component: Dfs.prefix_component,
  postfix_component: Dfs.postfix_component,
  fold_component: Dfs.fold_component,
  has_cycle: Dfs.has_cycle
};

var Digraph_Rand = {
  graph: Rand$1.graph,
  labeled: Rand$1.labeled,
  gnp: Rand$1.gnp,
  gnp_labeled: Rand$1.gnp_labeled
};

var Digraph_shortest_path = include.shortest_path;

var Digraph_bellman_ford = BF.find_negative_cycle_from;

var Digraph_Topological = {
  fold: include$2.fold,
  iter: include$2.iter,
  fold_stable: S.fold,
  iter_stable: S.iter
};

var Digraph_spanningtree = include$3.spanningtree;

var Digraph = {
  V: V,
  E: Digraph_E,
  is_directed: Digraph_is_directed,
  create: Digraph_create,
  clear: Digraph_clear,
  copy: Digraph_copy,
  add_vertex: Digraph_add_vertex,
  remove_vertex: Digraph_remove_vertex,
  add_edge: Digraph_add_edge,
  add_edge_e: Digraph_add_edge_e,
  remove_edge: Digraph_remove_edge,
  remove_edge_e: Digraph_remove_edge_e,
  Mark: Digraph_Mark,
  is_empty: Digraph_is_empty,
  nb_vertex: Digraph_nb_vertex,
  nb_edges: Digraph_nb_edges,
  out_degree: Digraph_out_degree,
  in_degree: Digraph_in_degree,
  mem_vertex: Digraph_mem_vertex,
  mem_edge: Digraph_mem_edge,
  mem_edge_e: Digraph_mem_edge_e,
  find_edge: Digraph_find_edge,
  find_all_edges: Digraph_find_all_edges,
  succ: Digraph_succ,
  pred: Digraph_pred,
  succ_e: Digraph_succ_e,
  pred_e: Digraph_pred_e,
  iter_vertex: iter_vertex,
  iter_edges: Digraph_iter_edges,
  fold_vertex: Digraph_fold_vertex,
  fold_edges: Digraph_fold_edges,
  map_vertex: Digraph_map_vertex,
  iter_edges_e: Digraph_iter_edges_e,
  fold_edges_e: Digraph_fold_edges_e,
  iter_succ: Digraph_iter_succ,
  iter_pred: Digraph_iter_pred,
  fold_succ: Digraph_fold_succ,
  fold_pred: Digraph_fold_pred,
  iter_succ_e: Digraph_iter_succ_e,
  fold_succ_e: Digraph_fold_succ_e,
  iter_pred_e: Digraph_iter_pred_e,
  fold_pred_e: Digraph_fold_pred_e,
  find_vertex: find_vertex,
  transitive_closure: Digraph_transitive_closure,
  add_transitive_closure: Digraph_add_transitive_closure,
  transitive_reduction: Digraph_transitive_reduction,
  replace_by_transitive_reduction: Digraph_replace_by_transitive_reduction,
  mirror: Digraph_mirror,
  complement: Digraph_complement,
  intersect: Digraph_intersect,
  union: Digraph_union,
  Dfs: Digraph_Dfs,
  Bfs: Bfs,
  Marking: Marking,
  Classic: Classic$1,
  Rand: Digraph_Rand,
  Components: Components$1,
  shortest_path: Digraph_shortest_path,
  ford_fulkerson: ford_fulkerson,
  goldberg_tarjan: goldberg_tarjan,
  bellman_ford: Digraph_bellman_ford,
  PathCheck: PathCheck,
  Topological: Digraph_Topological,
  spanningtree: Digraph_spanningtree
};

var Graph_E = G$1.E;

var Graph_is_directed = G$1.is_directed;

var Graph_create = G$1.create;

var Graph_clear = G$1.clear;

var Graph_copy = G$1.copy;

var Graph_add_vertex = G$1.add_vertex;

var Graph_remove_vertex = G$1.remove_vertex;

var Graph_add_edge = G$1.add_edge;

var Graph_add_edge_e = G$1.add_edge_e;

var Graph_remove_edge = G$1.remove_edge;

var Graph_remove_edge_e = G$1.remove_edge_e;

var Graph_Mark = G$1.Mark;

var Graph_is_empty = G$1.is_empty;

var Graph_nb_vertex = G$1.nb_vertex;

var Graph_nb_edges = G$1.nb_edges;

var Graph_out_degree = G$1.out_degree;

var Graph_in_degree = G$1.in_degree;

var Graph_mem_vertex = G$1.mem_vertex;

var Graph_mem_edge = G$1.mem_edge;

var Graph_mem_edge_e = G$1.mem_edge_e;

var Graph_find_edge = G$1.find_edge;

var Graph_find_all_edges = G$1.find_all_edges;

var Graph_succ = G$1.succ;

var Graph_pred = G$1.pred;

var Graph_succ_e = G$1.succ_e;

var Graph_pred_e = G$1.pred_e;

var Graph_iter_edges = G$1.iter_edges;

var Graph_fold_vertex = G$1.fold_vertex;

var Graph_fold_edges = G$1.fold_edges;

var Graph_map_vertex = G$1.map_vertex;

var Graph_iter_edges_e = G$1.iter_edges_e;

var Graph_fold_edges_e = G$1.fold_edges_e;

var Graph_iter_succ = G$1.iter_succ;

var Graph_iter_pred = G$1.iter_pred;

var Graph_fold_succ = G$1.fold_succ;

var Graph_fold_pred = G$1.fold_pred;

var Graph_iter_succ_e = G$1.iter_succ_e;

var Graph_fold_succ_e = G$1.fold_succ_e;

var Graph_iter_pred_e = G$1.iter_pred_e;

var Graph_fold_pred_e = G$1.fold_pred_e;

var Graph_transitive_closure = include$5.transitive_closure;

var Graph_add_transitive_closure = include$5.add_transitive_closure;

var Graph_transitive_reduction = include$5.transitive_reduction;

var Graph_replace_by_transitive_reduction = include$5.replace_by_transitive_reduction;

var Graph_mirror = include$5.mirror;

var Graph_complement = include$5.complement;

var Graph_intersect = include$5.intersect;

var Graph_union = include$5.union;

var Graph_Dfs = {
  iter: Dfs$1.iter,
  prefix: Dfs$1.prefix,
  postfix: Dfs$1.postfix,
  fold: Dfs$1.fold,
  iter_component: Dfs$1.iter_component,
  prefix_component: Dfs$1.prefix_component,
  postfix_component: Dfs$1.postfix_component,
  fold_component: Dfs$1.fold_component,
  has_cycle: Dfs$1.has_cycle
};

var Graph_Rand = {
  graph: Rand$2.graph,
  labeled: Rand$2.labeled,
  gnp: Rand$2.gnp,
  gnp_labeled: Rand$2.gnp_labeled
};

var Graph_shortest_path = include$4.shortest_path;

var Graph_bellman_ford = BF$1.find_negative_cycle_from;

var Graph_Topological = {
  fold: include$6.fold,
  iter: include$6.iter,
  fold_stable: S$1.fold,
  iter_stable: S$1.iter
};

var Graph_spanningtree = include$7.spanningtree;

var Graph = {
  V: V$1,
  E: Graph_E,
  is_directed: Graph_is_directed,
  create: Graph_create,
  clear: Graph_clear,
  copy: Graph_copy,
  add_vertex: Graph_add_vertex,
  remove_vertex: Graph_remove_vertex,
  add_edge: Graph_add_edge,
  add_edge_e: Graph_add_edge_e,
  remove_edge: Graph_remove_edge,
  remove_edge_e: Graph_remove_edge_e,
  Mark: Graph_Mark,
  is_empty: Graph_is_empty,
  nb_vertex: Graph_nb_vertex,
  nb_edges: Graph_nb_edges,
  out_degree: Graph_out_degree,
  in_degree: Graph_in_degree,
  mem_vertex: Graph_mem_vertex,
  mem_edge: Graph_mem_edge,
  mem_edge_e: Graph_mem_edge_e,
  find_edge: Graph_find_edge,
  find_all_edges: Graph_find_all_edges,
  succ: Graph_succ,
  pred: Graph_pred,
  succ_e: Graph_succ_e,
  pred_e: Graph_pred_e,
  iter_vertex: iter_vertex$1,
  iter_edges: Graph_iter_edges,
  fold_vertex: Graph_fold_vertex,
  fold_edges: Graph_fold_edges,
  map_vertex: Graph_map_vertex,
  iter_edges_e: Graph_iter_edges_e,
  fold_edges_e: Graph_fold_edges_e,
  iter_succ: Graph_iter_succ,
  iter_pred: Graph_iter_pred,
  fold_succ: Graph_fold_succ,
  fold_pred: Graph_fold_pred,
  iter_succ_e: Graph_iter_succ_e,
  fold_succ_e: Graph_fold_succ_e,
  iter_pred_e: Graph_iter_pred_e,
  fold_pred_e: Graph_fold_pred_e,
  find_vertex: find_vertex$1,
  transitive_closure: Graph_transitive_closure,
  add_transitive_closure: Graph_add_transitive_closure,
  transitive_reduction: Graph_transitive_reduction,
  replace_by_transitive_reduction: Graph_replace_by_transitive_reduction,
  mirror: Graph_mirror,
  complement: Graph_complement,
  intersect: Graph_intersect,
  union: Graph_union,
  Dfs: Graph_Dfs,
  Bfs: Bfs$1,
  Marking: Marking$1,
  Classic: Classic$2,
  Rand: Graph_Rand,
  Components: Components$2,
  shortest_path: Graph_shortest_path,
  ford_fulkerson: ford_fulkerson$1,
  goldberg_tarjan: goldberg_tarjan$1,
  bellman_ford: Graph_bellman_ford,
  PathCheck: PathCheck$1,
  Topological: Graph_Topological,
  spanningtree: Graph_spanningtree
};

export {
  Digraph ,
  Graph ,
  
}
/* G Not a pure module */
