// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Map from "../../node_modules/rescript/lib/es6/map.js";
import * as Curry from "../../node_modules/rescript/lib/es6/curry.js";
import * as WeakTopological from "./weakTopological.bs.js";
import * as Caml_js_exceptions from "../../node_modules/rescript/lib/es6/caml_js_exceptions.js";

function Make(G, D) {
  var M = $$Map.Make(G.V);
  var recurse = function (g, wto, init, widening_set, widening_delay) {
    var do_nonhead_widen = function (v) {
      if (widening_set) {
        return Curry._1(widening_set._0, v);
      } else {
        return false;
      }
    };
    var do_head_widen = function (v) {
      if (widening_set) {
        return Curry._1(widening_set._0, v);
      } else {
        return true;
      }
    };
    var find = function (vertex, data) {
      try {
        return Curry._2(M.find, vertex, data);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return Curry._1(init, vertex);
        }
        throw exn;
      }
    };
    var analyze_vertex = function (widening_steps, do_widen, v, data) {
      var result = Curry._4(G.fold_pred_e, (function (edge, acc) {
              var src = Curry._1(G.E.src, edge);
              var data_src = find(src, data);
              var data_dst = Curry._2(D.analyze, edge, data_src);
              return Curry._2(D.join, data_dst, acc);
            }), g, v, Curry._1(init, v));
      if (widening_steps <= 0 && Curry._1(do_widen, v)) {
        return Curry._2(D.widening, find(v, data), result);
      } else {
        return result;
      }
    };
    var analyze_elements = function (widening_steps, comp, data) {
      return WeakTopological.fold_left((function (param, param$1) {
                    if (param$1.TAG !== /* Vertex */0) {
                      var _can_stop = false;
                      var _widening_steps = widening_delay;
                      var head = param$1._0;
                      var comps = param$1._1;
                      var _data = param;
                      while(true) {
                        var data = _data;
                        var widening_steps$1 = _widening_steps;
                        var can_stop = _can_stop;
                        var old_data_head = find(head, data);
                        var new_data_head = analyze_vertex(widening_steps$1, do_head_widen, head, data);
                        if (can_stop && Curry._2(D.equal, old_data_head, new_data_head)) {
                          return data;
                        }
                        var partial_arg = widening_steps$1 - 1 | 0;
                        _data = analyze_elements(widening_steps$1, comps, Curry._3(M.add, head, new_data_head, data));
                        _widening_steps = partial_arg;
                        _can_stop = true;
                        continue ;
                      };
                    }
                    var v = param$1._0;
                    return Curry._3(M.add, v, analyze_vertex(widening_steps, do_nonhead_widen, v, param), param);
                  }), data, comp);
    };
    return analyze_elements(widening_delay, wto, M.empty);
  };
  return {
          M: M,
          recurse: recurse
        };
}

export {
  Make ,
  
}
/* No side effect */
