// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Curry = require("rescript/lib/js/curry.js");
var Blocks = require("./blocks.bs.js");
var Pervasives = require("rescript/lib/js/pervasives.js");

var P = Blocks.Make(function (funarg) {
      var $$let = Blocks.Make_Map(funarg);
      return {
              create: $$let.create,
              create_from: $$let.create_from,
              empty: $$let.empty,
              clear: $$let.clear,
              is_empty: $$let.is_empty,
              add: $$let.add,
              remove: $$let.remove,
              mem: $$let.mem,
              find: $$let.find,
              find_and_raise: $$let.find_and_raise,
              iter: $$let.iter,
              map: $$let.map,
              fold: $$let.fold,
              copy: $$let.copy
            };
    });

function Digraph_Concrete(funarg) {
  var include = Curry._1(P.Digraph.Concrete, funarg);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var E = include.E;
  var empty = include.empty;
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g)) {
      return g;
    }
    var g$1 = Curry._2(HM.remove, v, g);
    return Curry._3(HM.fold, (function (k, s) {
                  return Curry._2(HM.add, k, Curry._2(S.remove, v, s));
                }), g$1, empty);
  };
  return {
          V: {
            compare: V.compare,
            hash: V.hash,
            equal: V.equal,
            create: V.create,
            label: V.label
          },
          E: {
            compare: E.compare,
            src: E.src,
            dst: E.dst,
            create: E.create,
            label: E.label
          },
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          empty: empty,
          add_vertex: include.add_vertex,
          remove_vertex: remove_vertex,
          add_edge: include.add_edge,
          add_edge_e: include.add_edge_e,
          remove_edge: include.remove_edge,
          remove_edge_e: include.remove_edge_e
        };
}

function Digraph_Abstract(funarg) {
  var compare = function (x, y) {
    return Caml.caml_int_compare(x.tag, y.tag);
  };
  var hash = function (x) {
    return x.tag;
  };
  var equal = function (x, y) {
    return x.tag === y.tag;
  };
  var label = function (x) {
    return x.label;
  };
  var create = function (l) {
    if (Blocks.cpt_vertex.contents === (Blocks.first_value_for_cpt_vertex - 1 | 0)) {
      Pervasives.invalid_arg("Too much vertices");
    }
    Blocks.cpt_vertex.contents = Blocks.cpt_vertex.contents + 1 | 0;
    return {
            tag: Blocks.cpt_vertex.contents,
            label: l
          };
  };
  var include = Curry._1(P.Digraph.Abstract, {
        compare: compare,
        hash: hash,
        equal: equal,
        create: create,
        label: label
      });
  var G = include.G;
  var HM = include.HM;
  var S = include.S;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var mem_vertex = include.mem_vertex;
  var empty = {
    edges: G.empty,
    size: 0
  };
  var add_vertex = function (g, v) {
    if (Curry._2(mem_vertex, g, v)) {
      return g;
    } else {
      return {
              edges: Curry._2(G.unsafe_add_vertex, g.edges, v),
              size: g.size + 1 | 0
            };
    }
  };
  var add_edge = function (g, v1, v2) {
    var g$1 = add_vertex(g, v1);
    var g$2 = add_vertex(g$1, v2);
    return {
            edges: Curry._3(G.unsafe_add_edge, g$2.edges, v1, v2),
            size: g$2.size
          };
  };
  var add_edge_e = function (g, param) {
    return add_edge(g, param[0], param[1]);
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      return g;
    }
    var e = Curry._2(HM.remove, v, g.edges);
    var e$1 = Curry._3(HM.fold, (function (k, s, g) {
            return Curry._3(HM.add, k, Curry._2(S.remove, v, s), g);
          }), e, HM.empty);
    return {
            edges: e$1,
            size: g.size - 1 | 0
          };
  };
  var remove_edge$1 = function (g, v1, v2) {
    return {
            edges: Curry._3(remove_edge, g, v1, v2),
            size: g.size
          };
  };
  var remove_edge_e$1 = function (g, e) {
    return {
            edges: Curry._2(remove_edge_e, g, e),
            size: g.size
          };
  };
  return {
          V: include.V,
          E: include.E,
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          empty: empty,
          add_vertex: add_vertex,
          remove_vertex: remove_vertex,
          add_edge: add_edge,
          add_edge_e: add_edge_e,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1
        };
}

function Digraph_ConcreteLabeled(funarg, funarg$1) {
  var include = Curry._2(P.Digraph.ConcreteLabeled, funarg, funarg$1);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var E = include.E;
  var empty = include.empty;
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g)) {
      return g;
    }
    var g$1 = Curry._2(HM.remove, v, g);
    var remove = function (v) {
      return Curry._1(S.filter, (function (param) {
                    return !Curry._2(V.equal, v, param[0]);
                  }));
    };
    return Curry._3(HM.fold, (function (k, s) {
                  return Curry._2(HM.add, k, Curry._1(remove(v), s));
                }), g$1, empty);
  };
  return {
          V: {
            compare: V.compare,
            hash: V.hash,
            equal: V.equal,
            create: V.create,
            label: V.label
          },
          E: {
            compare: E.compare,
            src: E.src,
            dst: E.dst,
            create: E.create,
            label: E.label
          },
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          empty: empty,
          add_vertex: include.add_vertex,
          remove_vertex: remove_vertex,
          add_edge: include.add_edge,
          add_edge_e: include.add_edge_e,
          remove_edge: include.remove_edge,
          remove_edge_e: include.remove_edge_e
        };
}

function Digraph_AbstractLabeled(funarg, funarg$1) {
  var compare = function (x, y) {
    return Caml.caml_int_compare(x.tag, y.tag);
  };
  var hash = function (x) {
    return x.tag;
  };
  var equal = function (x, y) {
    return x.tag === y.tag;
  };
  var label = function (x) {
    return x.label;
  };
  var create = function (l) {
    if (Blocks.cpt_vertex.contents === (Blocks.first_value_for_cpt_vertex - 1 | 0)) {
      Pervasives.invalid_arg("Too much vertices");
    }
    Blocks.cpt_vertex.contents = Blocks.cpt_vertex.contents + 1 | 0;
    return {
            tag: Blocks.cpt_vertex.contents,
            label: l
          };
  };
  var include = Curry._2(P.Digraph.AbstractLabeled, {
        compare: compare,
        hash: hash,
        equal: equal,
        create: create,
        label: label
      }, funarg$1);
  var G = include.G;
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var mem_vertex = include.mem_vertex;
  var empty = {
    edges: G.empty,
    size: 0
  };
  var add_vertex = function (g, v) {
    if (Curry._2(mem_vertex, g, v)) {
      return g;
    } else {
      return {
              edges: Curry._2(G.unsafe_add_vertex, g.edges, v),
              size: g.size + 1 | 0
            };
    }
  };
  var add_edge_e = function (g, param) {
    var v2 = param[2];
    var v1 = param[0];
    var g$1 = add_vertex(g, v1);
    var g$2 = add_vertex(g$1, v2);
    return {
            edges: Curry._3(G.unsafe_add_edge, g$2.edges, v1, [
                  v2,
                  param[1]
                ]),
            size: g$2.size
          };
  };
  var add_edge = function (g, v1, v2) {
    return add_edge_e(g, [
                v1,
                funarg$1.$$default,
                v2
              ]);
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      return g;
    }
    var remove = function (v, s) {
      return Curry._3(S.fold, (function (e, s) {
                    if (Curry._2(V.equal, v, e[0])) {
                      return s;
                    } else {
                      return Curry._2(S.add, e, s);
                    }
                  }), s, S.empty);
    };
    var edges = Curry._2(HM.remove, v, g.edges);
    return {
            edges: Curry._3(HM.fold, (function (k, s, g) {
                    return Curry._3(HM.add, k, remove(v, s), g);
                  }), edges, HM.empty),
            size: g.size - 1 | 0
          };
  };
  var remove_edge$1 = function (g, v1, v2) {
    return {
            edges: Curry._3(remove_edge, g, v1, v2),
            size: g.size
          };
  };
  var remove_edge_e$1 = function (g, e) {
    return {
            edges: Curry._2(remove_edge_e, g, e),
            size: g.size
          };
  };
  return {
          V: V,
          E: include.E,
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: include.fold_succ,
          fold_pred: include.fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          empty: empty,
          add_vertex: add_vertex,
          remove_vertex: remove_vertex,
          add_edge: add_edge,
          add_edge_e: add_edge_e,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1
        };
}

function Digraph_ConcreteBidirectional(funarg) {
  var include = Curry._1(P.Digraph.ConcreteBidirectional, funarg);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var E = include.E;
  var fold_succ = include.fold_succ;
  var fold_pred = include.fold_pred;
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g)) {
      return g;
    }
    var remove = function (v) {
      return Curry._1(S.filter, (function (v$p) {
                    return !Curry._2(V.equal, v, v$p);
                  }));
    };
    var g$1 = Curry._4(fold_pred, (function (v$p, acc) {
            var match = Curry._2(HM.find, v$p, acc);
            return Curry._3(HM.add, v$p, [
                        match[0],
                        Curry._1(remove(v), match[1])
                      ], acc);
          }), g, v, g);
    var g$2 = Curry._4(fold_succ, (function (v$p, acc) {
            var match = Curry._2(HM.find, v$p, acc);
            return Curry._3(HM.add, v$p, [
                        Curry._1(remove(v), match[0]),
                        match[1]
                      ], acc);
          }), g$1, v, g$1);
    return Curry._2(HM.remove, v, g$2);
  };
  return {
          V: {
            compare: V.compare,
            hash: V.hash,
            equal: V.equal,
            create: V.create,
            label: V.label
          },
          E: {
            compare: E.compare,
            src: E.src,
            dst: E.dst,
            create: E.create,
            label: E.label
          },
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: fold_succ,
          fold_pred: fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          empty: include.empty,
          add_vertex: include.add_vertex,
          remove_vertex: remove_vertex,
          add_edge: include.add_edge,
          add_edge_e: include.add_edge_e,
          remove_edge: include.remove_edge,
          remove_edge_e: include.remove_edge_e
        };
}

function Digraph_ConcreteBidirectionalLabeled(funarg, funarg$1) {
  var include = Curry._2(P.Digraph.ConcreteBidirectionalLabeled, funarg, funarg$1);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var E = include.E;
  var fold_succ = include.fold_succ;
  var fold_pred = include.fold_pred;
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g)) {
      return g;
    }
    var remove = function (v) {
      return Curry._1(S.filter, (function (param) {
                    return !Curry._2(V.equal, v, param[0]);
                  }));
    };
    var g$1 = Curry._4(fold_pred, (function (v$p, acc) {
            var match = Curry._2(HM.find, v$p, acc);
            return Curry._3(HM.add, v$p, [
                        match[0],
                        Curry._1(remove(v), match[1])
                      ], acc);
          }), g, v, g);
    var g$2 = Curry._4(fold_succ, (function (v$p, acc) {
            var match = Curry._2(HM.find, v$p, acc);
            return Curry._3(HM.add, v$p, [
                        Curry._1(remove(v), match[0]),
                        match[1]
                      ], acc);
          }), g$1, v, g$1);
    return Curry._2(HM.remove, v, g$2);
  };
  return {
          V: {
            compare: V.compare,
            hash: V.hash,
            equal: V.equal,
            create: V.create,
            label: V.label
          },
          E: {
            compare: E.compare,
            src: E.src,
            dst: E.dst,
            create: E.create,
            label: E.label
          },
          is_directed: include.is_directed,
          is_empty: include.is_empty,
          nb_vertex: include.nb_vertex,
          nb_edges: include.nb_edges,
          out_degree: include.out_degree,
          in_degree: include.in_degree,
          mem_vertex: include.mem_vertex,
          mem_edge: include.mem_edge,
          mem_edge_e: include.mem_edge_e,
          find_edge: include.find_edge,
          find_all_edges: include.find_all_edges,
          succ: include.succ,
          pred: include.pred,
          succ_e: include.succ_e,
          pred_e: include.pred_e,
          iter_vertex: include.iter_vertex,
          fold_vertex: include.fold_vertex,
          iter_edges: include.iter_edges,
          fold_edges: include.fold_edges,
          iter_edges_e: include.iter_edges_e,
          fold_edges_e: include.fold_edges_e,
          map_vertex: include.map_vertex,
          iter_succ: include.iter_succ,
          iter_pred: include.iter_pred,
          fold_succ: fold_succ,
          fold_pred: fold_pred,
          iter_succ_e: include.iter_succ_e,
          fold_succ_e: include.fold_succ_e,
          iter_pred_e: include.iter_pred_e,
          fold_pred_e: include.fold_pred_e,
          empty: include.empty,
          add_vertex: include.add_vertex,
          remove_vertex: remove_vertex,
          add_edge: include.add_edge,
          add_edge_e: include.add_edge_e,
          remove_edge: include.remove_edge,
          remove_edge_e: include.remove_edge_e
        };
}

var Digraph = {
  Concrete: Digraph_Concrete,
  Abstract: Digraph_Abstract,
  ConcreteLabeled: Digraph_ConcreteLabeled,
  AbstractLabeled: Digraph_AbstractLabeled,
  ConcreteBidirectional: Digraph_ConcreteBidirectional,
  ConcreteBidirectionalLabeled: Digraph_ConcreteBidirectionalLabeled
};

function Graph_Concrete(funarg) {
  var include = Curry._1(P.Digraph.Concrete, funarg);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var E = include.E;
  var unsafe_remove_edge = include.unsafe_remove_edge;
  var remove_edge = include.remove_edge;
  var empty = include.empty;
  var unsafe_add_edge = include.unsafe_add_edge;
  var add_edge = include.add_edge;
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g)) {
      return g;
    }
    var g$1 = Curry._2(HM.remove, v, g);
    return Curry._3(HM.fold, (function (k, s) {
                  return Curry._2(HM.add, k, Curry._2(S.remove, v, s));
                }), g$1, empty);
  };
  var include$1 = Blocks.Graph({
        V: {
          compare: V.compare,
          hash: V.hash,
          equal: V.equal,
          create: V.create,
          label: V.label
        },
        E: {
          compare: E.compare,
          src: E.src,
          dst: E.dst,
          create: E.create,
          label: E.label
        },
        is_directed: include.is_directed,
        is_empty: include.is_empty,
        nb_vertex: include.nb_vertex,
        nb_edges: include.nb_edges,
        out_degree: include.out_degree,
        in_degree: include.in_degree,
        mem_vertex: include.mem_vertex,
        mem_edge: include.mem_edge,
        mem_edge_e: include.mem_edge_e,
        find_edge: include.find_edge,
        find_all_edges: include.find_all_edges,
        succ: include.succ,
        pred: include.pred,
        succ_e: include.succ_e,
        pred_e: include.pred_e,
        iter_vertex: include.iter_vertex,
        fold_vertex: include.fold_vertex,
        iter_edges: include.iter_edges,
        fold_edges: include.fold_edges,
        iter_edges_e: include.iter_edges_e,
        fold_edges_e: include.fold_edges_e,
        map_vertex: include.map_vertex,
        iter_succ: include.iter_succ,
        iter_pred: include.iter_pred,
        fold_succ: include.fold_succ,
        fold_pred: include.fold_pred,
        iter_succ_e: include.iter_succ_e,
        fold_succ_e: include.fold_succ_e,
        iter_pred_e: include.iter_pred_e,
        fold_pred_e: include.fold_pred_e,
        create: include.create,
        clear: include.clear,
        copy: include.copy,
        add_vertex: include.add_vertex,
        remove_vertex: remove_vertex
      });
  var add_edge$1 = function (g, v1, v2) {
    var g$1 = Curry._3(add_edge, g, v1, v2);
    if (!(Curry._2(HM.mem, v1, g$1) && Curry._2(HM.mem, v2, g$1))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              221,
              6
            ],
            Error: new Error()
          };
    }
    return Curry._3(unsafe_add_edge, g$1, v2, v1);
  };
  var add_edge_e = function (g, param) {
    return add_edge$1(g, param[0], param[1]);
  };
  var remove_edge$1 = function (g, v1, v2) {
    var g$1 = Curry._3(remove_edge, g, v1, v2);
    if (!(Curry._2(HM.mem, v1, g$1) && Curry._2(HM.mem, v2, g$1))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              228,
              6
            ],
            Error: new Error()
          };
    }
    return Curry._3(unsafe_remove_edge, g$1, v2, v1);
  };
  var remove_edge_e = function (g, param) {
    return remove_edge$1(g, param[0], param[1]);
  };
  return {
          V: include$1.V,
          E: include$1.E,
          is_directed: include$1.is_directed,
          is_empty: include$1.is_empty,
          nb_vertex: include$1.nb_vertex,
          nb_edges: include$1.nb_edges,
          out_degree: include$1.out_degree,
          in_degree: include$1.in_degree,
          mem_vertex: include$1.mem_vertex,
          mem_edge: include$1.mem_edge,
          mem_edge_e: include$1.mem_edge_e,
          find_edge: include$1.find_edge,
          find_all_edges: include$1.find_all_edges,
          succ: include$1.succ,
          pred: include$1.pred,
          succ_e: include$1.succ_e,
          pred_e: include$1.pred_e,
          iter_vertex: include$1.iter_vertex,
          fold_vertex: include$1.fold_vertex,
          iter_edges: include$1.iter_edges,
          fold_edges: include$1.fold_edges,
          iter_edges_e: include$1.iter_edges_e,
          fold_edges_e: include$1.fold_edges_e,
          map_vertex: include$1.map_vertex,
          iter_succ: include$1.iter_succ,
          iter_pred: include$1.iter_pred,
          fold_succ: include$1.fold_succ,
          fold_pred: include$1.fold_pred,
          iter_succ_e: include$1.iter_succ_e,
          fold_succ_e: include$1.fold_succ_e,
          iter_pred_e: include$1.iter_pred_e,
          fold_pred_e: include$1.fold_pred_e,
          empty: empty,
          add_vertex: include$1.add_vertex,
          remove_vertex: include$1.remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e
        };
}

function Graph_Abstract(funarg) {
  var compare = function (x, y) {
    return Caml.caml_int_compare(x.tag, y.tag);
  };
  var hash = function (x) {
    return x.tag;
  };
  var equal = function (x, y) {
    return x.tag === y.tag;
  };
  var label = function (x) {
    return x.label;
  };
  var create = function (l) {
    if (Blocks.cpt_vertex.contents === (Blocks.first_value_for_cpt_vertex - 1 | 0)) {
      Pervasives.invalid_arg("Too much vertices");
    }
    Blocks.cpt_vertex.contents = Blocks.cpt_vertex.contents + 1 | 0;
    return {
            tag: Blocks.cpt_vertex.contents,
            label: l
          };
  };
  var include = Curry._1(P.Digraph.Abstract, {
        compare: compare,
        hash: hash,
        equal: equal,
        create: create,
        label: label
      });
  var G = include.G;
  var HM = include.HM;
  var S = include.S;
  var unsafe_add_edge = include.unsafe_add_edge;
  var unsafe_remove_edge = include.unsafe_remove_edge;
  var remove_edge = include.remove_edge;
  var mem_vertex = include.mem_vertex;
  var empty = {
    edges: G.empty,
    size: 0
  };
  var add_vertex = function (g, v) {
    if (Curry._2(mem_vertex, g, v)) {
      return g;
    } else {
      return {
              edges: Curry._2(G.unsafe_add_vertex, g.edges, v),
              size: g.size + 1 | 0
            };
    }
  };
  var add_edge = function (g, v1, v2) {
    var g$1 = add_vertex(g, v1);
    var g$2 = add_vertex(g$1, v2);
    return {
            edges: Curry._3(G.unsafe_add_edge, g$2.edges, v1, v2),
            size: g$2.size
          };
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      return g;
    }
    var e = Curry._2(HM.remove, v, g.edges);
    var e$1 = Curry._3(HM.fold, (function (k, s, g) {
            return Curry._3(HM.add, k, Curry._2(S.remove, v, s), g);
          }), e, HM.empty);
    return {
            edges: e$1,
            size: g.size - 1 | 0
          };
  };
  var remove_edge$1 = function (g, v1, v2) {
    return {
            edges: Curry._3(remove_edge, g, v1, v2),
            size: g.size
          };
  };
  var include$1 = Blocks.Graph({
        V: include.V,
        E: include.E,
        is_directed: include.is_directed,
        is_empty: include.is_empty,
        nb_vertex: include.nb_vertex,
        nb_edges: include.nb_edges,
        out_degree: include.out_degree,
        in_degree: include.in_degree,
        mem_vertex: mem_vertex,
        mem_edge: include.mem_edge,
        mem_edge_e: include.mem_edge_e,
        find_edge: include.find_edge,
        find_all_edges: include.find_all_edges,
        succ: include.succ,
        pred: include.pred,
        succ_e: include.succ_e,
        pred_e: include.pred_e,
        iter_vertex: include.iter_vertex,
        fold_vertex: include.fold_vertex,
        iter_edges: include.iter_edges,
        fold_edges: include.fold_edges,
        iter_edges_e: include.iter_edges_e,
        fold_edges_e: include.fold_edges_e,
        map_vertex: include.map_vertex,
        iter_succ: include.iter_succ,
        iter_pred: include.iter_pred,
        fold_succ: include.fold_succ,
        fold_pred: include.fold_pred,
        iter_succ_e: include.iter_succ_e,
        fold_succ_e: include.fold_succ_e,
        iter_pred_e: include.iter_pred_e,
        fold_pred_e: include.fold_pred_e,
        create: include.create,
        clear: include.clear,
        copy: include.copy,
        add_vertex: add_vertex,
        remove_vertex: remove_vertex
      });
  var add_edge$1 = function (g, v1, v2) {
    var g$1 = add_edge(g, v1, v2);
    if (!(Curry._2(HM.mem, v1, g$1.edges) && Curry._2(HM.mem, v2, g$1.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              279,
              6
            ],
            Error: new Error()
          };
    }
    return {
            edges: Curry._3(unsafe_add_edge, g$1.edges, v2, v1),
            size: g$1.size
          };
  };
  var add_edge_e = function (g, param) {
    return add_edge$1(g, param[0], param[1]);
  };
  var remove_edge$2 = function (g, v1, v2) {
    var g$1 = remove_edge$1(g, v1, v2);
    if (!(Curry._2(HM.mem, v1, g$1.edges) && Curry._2(HM.mem, v2, g$1.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              286,
              6
            ],
            Error: new Error()
          };
    }
    return {
            edges: Curry._3(unsafe_remove_edge, g$1.edges, v2, v1),
            size: g$1.size
          };
  };
  var remove_edge_e = function (g, param) {
    return remove_edge$2(g, param[0], param[1]);
  };
  return {
          V: include$1.V,
          E: include$1.E,
          is_directed: include$1.is_directed,
          is_empty: include$1.is_empty,
          nb_vertex: include$1.nb_vertex,
          nb_edges: include$1.nb_edges,
          out_degree: include$1.out_degree,
          in_degree: include$1.in_degree,
          mem_vertex: include$1.mem_vertex,
          mem_edge: include$1.mem_edge,
          mem_edge_e: include$1.mem_edge_e,
          find_edge: include$1.find_edge,
          find_all_edges: include$1.find_all_edges,
          succ: include$1.succ,
          pred: include$1.pred,
          succ_e: include$1.succ_e,
          pred_e: include$1.pred_e,
          iter_vertex: include$1.iter_vertex,
          fold_vertex: include$1.fold_vertex,
          iter_edges: include$1.iter_edges,
          fold_edges: include$1.fold_edges,
          iter_edges_e: include$1.iter_edges_e,
          fold_edges_e: include$1.fold_edges_e,
          map_vertex: include$1.map_vertex,
          iter_succ: include$1.iter_succ,
          iter_pred: include$1.iter_pred,
          fold_succ: include$1.fold_succ,
          fold_pred: include$1.fold_pred,
          iter_succ_e: include$1.iter_succ_e,
          fold_succ_e: include$1.fold_succ_e,
          iter_pred_e: include$1.iter_pred_e,
          fold_pred_e: include$1.fold_pred_e,
          empty: empty,
          add_vertex: include$1.add_vertex,
          remove_vertex: include$1.remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e,
          remove_edge: remove_edge$2,
          remove_edge_e: remove_edge_e
        };
}

function Graph_ConcreteLabeled(funarg, funarg$1) {
  var include = Curry._2(P.Digraph.ConcreteLabeled, funarg, funarg$1);
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var empty = include.empty;
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g)) {
      return g;
    }
    var g$1 = Curry._2(HM.remove, v, g);
    var remove = function (v) {
      return Curry._1(S.filter, (function (param) {
                    return !Curry._2(V.equal, v, param[0]);
                  }));
    };
    return Curry._3(HM.fold, (function (k, s) {
                  return Curry._2(HM.add, k, Curry._1(remove(v), s));
                }), g$1, empty);
  };
  var include_VE = include.VE;
  var include_E = include.E;
  var include_mem_edge = include.mem_edge;
  var include_mem_edge_e = include.mem_edge_e;
  var include_Found = include.Found;
  var include_find_edge = include.find_edge;
  var include_find_all_edges = include.find_all_edges;
  var include_unsafe_remove_edge = include.unsafe_remove_edge;
  var include_unsafe_remove_edge_e = include.unsafe_remove_edge_e;
  var include_remove_edge = include.remove_edge;
  var include_remove_edge_e = include.remove_edge_e;
  var include_iter_succ = include.iter_succ;
  var include_fold_succ = include.fold_succ;
  var include_iter_succ_e = include.iter_succ_e;
  var include_fold_succ_e = include.fold_succ_e;
  var include_succ = include.succ;
  var include_succ_e = include.succ_e;
  var include_map_vertex = include.map_vertex;
  var include_I = include.I;
  var include_PV = include.PV;
  var include_PE = include.PE;
  var include_iter_edges = include.iter_edges;
  var include_fold_edges = include.fold_edges;
  var include_iter_edges_e = include.iter_edges_e;
  var include_fold_edges_e = include.fold_edges_e;
  var include_iter_pred = include.iter_pred;
  var include_fold_pred = include.fold_pred;
  var include_pred = include.pred;
  var include_in_degree = include.in_degree;
  var include_iter_pred_e = include.iter_pred_e;
  var include_fold_pred_e = include.fold_pred_e;
  var include_pred_e = include.pred_e;
  var include_is_directed = include.is_directed;
  var include_create = include.create;
  var include_is_empty = include.is_empty;
  var include_copy = include.copy;
  var include_clear = include.clear;
  var include_nb_vertex = include.nb_vertex;
  var include_nb_edges = include.nb_edges;
  var include_out_degree = include.out_degree;
  var include_mem_vertex = include.mem_vertex;
  var include_unsafe_add_vertex = include.unsafe_add_vertex;
  var include_unsafe_add_edge = include.unsafe_add_edge;
  var include_add_vertex = include.add_vertex;
  var include_iter_vertex = include.iter_vertex;
  var include_fold_vertex = include.fold_vertex;
  var include_add_edge_e = include.add_edge_e;
  var include_add_edge = include.add_edge;
  var V$1 = V;
  var HM$1 = HM;
  var E = include_E;
  var unsafe_remove_edge = include_unsafe_remove_edge;
  var unsafe_remove_edge_e = include_unsafe_remove_edge_e;
  var remove_edge = include_remove_edge;
  var remove_edge_e = include_remove_edge_e;
  var unsafe_add_edge = include_unsafe_add_edge;
  var add_edge_e = include_add_edge_e;
  var include$1 = Blocks.Graph({
        V: {
          compare: V$1.compare,
          hash: V$1.hash,
          equal: V$1.equal,
          create: V$1.create,
          label: V$1.label
        },
        E: {
          compare: E.compare,
          src: E.src,
          dst: E.dst,
          create: E.create,
          label: E.label
        },
        is_directed: include_is_directed,
        is_empty: include_is_empty,
        nb_vertex: include_nb_vertex,
        nb_edges: include_nb_edges,
        out_degree: include_out_degree,
        in_degree: include_in_degree,
        mem_vertex: include_mem_vertex,
        mem_edge: include_mem_edge,
        mem_edge_e: include_mem_edge_e,
        find_edge: include_find_edge,
        find_all_edges: include_find_all_edges,
        succ: include_succ,
        pred: include_pred,
        succ_e: include_succ_e,
        pred_e: include_pred_e,
        iter_vertex: include_iter_vertex,
        fold_vertex: include_fold_vertex,
        iter_edges: include_iter_edges,
        fold_edges: include_fold_edges,
        iter_edges_e: include_iter_edges_e,
        fold_edges_e: include_fold_edges_e,
        map_vertex: include_map_vertex,
        iter_succ: include_iter_succ,
        iter_pred: include_iter_pred,
        fold_succ: include_fold_succ,
        fold_pred: include_fold_pred,
        iter_succ_e: include_iter_succ_e,
        fold_succ_e: include_fold_succ_e,
        iter_pred_e: include_iter_pred_e,
        fold_pred_e: include_fold_pred_e,
        create: include_create,
        clear: include_clear,
        copy: include_copy,
        add_vertex: include_add_vertex,
        remove_vertex: remove_vertex
      });
  var add_edge_e$1 = function (g, e) {
    var v2 = e[2];
    var v1 = e[0];
    var g$1 = Curry._2(add_edge_e, g, e);
    if (!(Curry._2(HM$1.mem, v1, g$1) && Curry._2(HM$1.mem, v2, g$1))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              250,
              6
            ],
            Error: new Error()
          };
    }
    return Curry._3(unsafe_add_edge, g$1, v2, [
                v1,
                e[1]
              ]);
  };
  var add_edge = function (g, v1, v2) {
    return add_edge_e$1(g, [
                v1,
                funarg$1.$$default,
                v2
              ]);
  };
  var remove_edge$1 = function (g, v1, v2) {
    var g$1 = Curry._3(remove_edge, g, v1, v2);
    if (!(Curry._2(HM$1.mem, v1, g$1) && Curry._2(HM$1.mem, v2, g$1))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              257,
              6
            ],
            Error: new Error()
          };
    }
    return Curry._3(unsafe_remove_edge, g$1, v2, v1);
  };
  var remove_edge_e$1 = function (g, e) {
    var v2 = e[2];
    var v1 = e[0];
    var g$1 = Curry._2(remove_edge_e, g, e);
    if (!(Curry._2(HM$1.mem, v1, g$1) && Curry._2(HM$1.mem, v2, g$1))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              262,
              6
            ],
            Error: new Error()
          };
    }
    return Curry._2(unsafe_remove_edge_e, g$1, [
                v2,
                e[1],
                v1
              ]);
  };
  return {
          V: include$1.V,
          E: include$1.E,
          is_directed: include$1.is_directed,
          is_empty: include$1.is_empty,
          nb_vertex: include$1.nb_vertex,
          nb_edges: include$1.nb_edges,
          out_degree: include$1.out_degree,
          in_degree: include$1.in_degree,
          mem_vertex: include$1.mem_vertex,
          mem_edge: include$1.mem_edge,
          mem_edge_e: include$1.mem_edge_e,
          find_edge: include$1.find_edge,
          find_all_edges: include$1.find_all_edges,
          succ: include$1.succ,
          pred: include$1.pred,
          succ_e: include$1.succ_e,
          pred_e: include$1.pred_e,
          iter_vertex: include$1.iter_vertex,
          fold_vertex: include$1.fold_vertex,
          iter_edges: include$1.iter_edges,
          fold_edges: include$1.fold_edges,
          iter_edges_e: include$1.iter_edges_e,
          fold_edges_e: include$1.fold_edges_e,
          map_vertex: include$1.map_vertex,
          iter_succ: include$1.iter_succ,
          iter_pred: include$1.iter_pred,
          fold_succ: include$1.fold_succ,
          fold_pred: include$1.fold_pred,
          iter_succ_e: include$1.iter_succ_e,
          fold_succ_e: include$1.fold_succ_e,
          iter_pred_e: include$1.iter_pred_e,
          fold_pred_e: include$1.fold_pred_e,
          empty: empty,
          add_vertex: include$1.add_vertex,
          remove_vertex: include$1.remove_vertex,
          add_edge: add_edge,
          add_edge_e: add_edge_e$1,
          remove_edge: remove_edge$1,
          remove_edge_e: remove_edge_e$1
        };
}

function Graph_AbstractLabeled(funarg, funarg$1) {
  var compare = function (x, y) {
    return Caml.caml_int_compare(x.tag, y.tag);
  };
  var hash = function (x) {
    return x.tag;
  };
  var equal = function (x, y) {
    return x.tag === y.tag;
  };
  var label = function (x) {
    return x.label;
  };
  var create = function (l) {
    if (Blocks.cpt_vertex.contents === (Blocks.first_value_for_cpt_vertex - 1 | 0)) {
      Pervasives.invalid_arg("Too much vertices");
    }
    Blocks.cpt_vertex.contents = Blocks.cpt_vertex.contents + 1 | 0;
    return {
            tag: Blocks.cpt_vertex.contents,
            label: l
          };
  };
  var include = Curry._2(P.Digraph.AbstractLabeled, {
        compare: compare,
        hash: hash,
        equal: equal,
        create: create,
        label: label
      }, funarg$1);
  var G = include.G;
  var V = include.V;
  var HM = include.HM;
  var S = include.S;
  var remove_edge = include.remove_edge;
  var remove_edge_e = include.remove_edge_e;
  var mem_vertex = include.mem_vertex;
  var empty = {
    edges: G.empty,
    size: 0
  };
  var add_vertex = function (g, v) {
    if (Curry._2(mem_vertex, g, v)) {
      return g;
    } else {
      return {
              edges: Curry._2(G.unsafe_add_vertex, g.edges, v),
              size: g.size + 1 | 0
            };
    }
  };
  var add_edge_e = function (g, param) {
    var v2 = param[2];
    var v1 = param[0];
    var g$1 = add_vertex(g, v1);
    var g$2 = add_vertex(g$1, v2);
    return {
            edges: Curry._3(G.unsafe_add_edge, g$2.edges, v1, [
                  v2,
                  param[1]
                ]),
            size: g$2.size
          };
  };
  var add_edge = function (g, v1, v2) {
    return add_edge_e(g, [
                v1,
                funarg$1.$$default,
                v2
              ]);
  };
  var remove_vertex = function (g, v) {
    if (!Curry._2(HM.mem, v, g.edges)) {
      return g;
    }
    var remove = function (v, s) {
      return Curry._3(S.fold, (function (e, s) {
                    if (Curry._2(V.equal, v, e[0])) {
                      return s;
                    } else {
                      return Curry._2(S.add, e, s);
                    }
                  }), s, S.empty);
    };
    var edges = Curry._2(HM.remove, v, g.edges);
    return {
            edges: Curry._3(HM.fold, (function (k, s, g) {
                    return Curry._3(HM.add, k, remove(v, s), g);
                  }), edges, HM.empty),
            size: g.size - 1 | 0
          };
  };
  var remove_edge$1 = function (g, v1, v2) {
    return {
            edges: Curry._3(remove_edge, g, v1, v2),
            size: g.size
          };
  };
  var remove_edge_e$1 = function (g, e) {
    return {
            edges: Curry._2(remove_edge_e, g, e),
            size: g.size
          };
  };
  var include_I = include.I;
  var include_PV = include.PV;
  var include_PE = include.PE;
  var include_iter_edges = include.iter_edges;
  var include_fold_edges = include.fold_edges;
  var include_iter_edges_e = include.iter_edges_e;
  var include_fold_edges_e = include.fold_edges_e;
  var include_create = include.create;
  var include_clear = include.clear;
  var include_iter_pred = include.iter_pred;
  var include_fold_pred = include.fold_pred;
  var include_pred = include.pred;
  var include_iter_pred_e = include.iter_pred_e;
  var include_fold_pred_e = include.fold_pred_e;
  var include_pred_e = include.pred_e;
  var include_is_empty = include.is_empty;
  var include_nb_vertex = include.nb_vertex;
  var include_E = include.E;
  var include_unsafe_add_edge = include.unsafe_add_edge;
  var include_unsafe_remove_edge = include.unsafe_remove_edge;
  var include_unsafe_remove_edge_e = include.unsafe_remove_edge_e;
  var include_is_directed = include.is_directed;
  var include_out_degree = include.out_degree;
  var include_in_degree = include.in_degree;
  var include_nb_edges = include.nb_edges;
  var include_succ = include.succ;
  var include_mem_edge = include.mem_edge;
  var include_mem_edge_e = include.mem_edge_e;
  var include_find_edge = include.find_edge;
  var include_find_all_edges = include.find_all_edges;
  var include_iter_vertex = include.iter_vertex;
  var include_fold_vertex = include.fold_vertex;
  var include_iter_succ = include.iter_succ;
  var include_fold_succ = include.fold_succ;
  var include_succ_e = include.succ_e;
  var include_iter_succ_e = include.iter_succ_e;
  var include_fold_succ_e = include.fold_succ_e;
  var include_map_vertex = include.map_vertex;
  var include_copy = include.copy;
  var HM$1 = HM;
  var unsafe_add_edge = include_unsafe_add_edge;
  var unsafe_remove_edge = include_unsafe_remove_edge;
  var unsafe_remove_edge_e = include_unsafe_remove_edge_e;
  var add_edge_e$1 = add_edge_e;
  var remove_edge$2 = remove_edge$1;
  var remove_edge_e$2 = remove_edge_e$1;
  var include$1 = Blocks.Graph({
        V: V,
        E: include_E,
        is_directed: include_is_directed,
        is_empty: include_is_empty,
        nb_vertex: include_nb_vertex,
        nb_edges: include_nb_edges,
        out_degree: include_out_degree,
        in_degree: include_in_degree,
        mem_vertex: mem_vertex,
        mem_edge: include_mem_edge,
        mem_edge_e: include_mem_edge_e,
        find_edge: include_find_edge,
        find_all_edges: include_find_all_edges,
        succ: include_succ,
        pred: include_pred,
        succ_e: include_succ_e,
        pred_e: include_pred_e,
        iter_vertex: include_iter_vertex,
        fold_vertex: include_fold_vertex,
        iter_edges: include_iter_edges,
        fold_edges: include_fold_edges,
        iter_edges_e: include_iter_edges_e,
        fold_edges_e: include_fold_edges_e,
        map_vertex: include_map_vertex,
        iter_succ: include_iter_succ,
        iter_pred: include_iter_pred,
        fold_succ: include_fold_succ,
        fold_pred: include_fold_pred,
        iter_succ_e: include_iter_succ_e,
        fold_succ_e: include_fold_succ_e,
        iter_pred_e: include_iter_pred_e,
        fold_pred_e: include_fold_pred_e,
        create: include_create,
        clear: include_clear,
        copy: include_copy,
        add_vertex: add_vertex,
        remove_vertex: remove_vertex
      });
  var add_edge_e$2 = function (g, e) {
    var v2 = e[2];
    var v1 = e[0];
    var g$1 = Curry._2(add_edge_e$1, g, e);
    if (!(Curry._2(HM$1.mem, v1, g$1.edges) && Curry._2(HM$1.mem, v2, g$1.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              308,
              6
            ],
            Error: new Error()
          };
    }
    return {
            edges: Curry._3(unsafe_add_edge, g$1.edges, v2, [
                  v1,
                  e[1]
                ]),
            size: g$1.size
          };
  };
  var add_edge$1 = function (g, v1, v2) {
    return add_edge_e$2(g, [
                v1,
                funarg$1.$$default,
                v2
              ]);
  };
  var remove_edge$3 = function (g, v1, v2) {
    var g$1 = Curry._3(remove_edge$2, g, v1, v2);
    if (!(Curry._2(HM$1.mem, v1, g$1.edges) && Curry._2(HM$1.mem, v2, g$1.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              315,
              6
            ],
            Error: new Error()
          };
    }
    return {
            edges: Curry._3(unsafe_remove_edge, g$1.edges, v2, v1),
            size: g$1.size
          };
  };
  var remove_edge_e$3 = function (g, e) {
    var v2 = e[2];
    var v1 = e[0];
    var g$1 = Curry._2(remove_edge_e$2, g, e);
    if (!(Curry._2(HM$1.mem, v1, g$1.edges) && Curry._2(HM$1.mem, v2, g$1.edges))) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "persistent.ml",
              320,
              6
            ],
            Error: new Error()
          };
    }
    return {
            edges: Curry._2(unsafe_remove_edge_e, g$1.edges, [
                  v2,
                  e[1],
                  v1
                ]),
            size: g$1.size
          };
  };
  return {
          V: include$1.V,
          E: include$1.E,
          is_directed: include$1.is_directed,
          is_empty: include$1.is_empty,
          nb_vertex: include$1.nb_vertex,
          nb_edges: include$1.nb_edges,
          out_degree: include$1.out_degree,
          in_degree: include$1.in_degree,
          mem_vertex: include$1.mem_vertex,
          mem_edge: include$1.mem_edge,
          mem_edge_e: include$1.mem_edge_e,
          find_edge: include$1.find_edge,
          find_all_edges: include$1.find_all_edges,
          succ: include$1.succ,
          pred: include$1.pred,
          succ_e: include$1.succ_e,
          pred_e: include$1.pred_e,
          iter_vertex: include$1.iter_vertex,
          fold_vertex: include$1.fold_vertex,
          iter_edges: include$1.iter_edges,
          fold_edges: include$1.fold_edges,
          iter_edges_e: include$1.iter_edges_e,
          fold_edges_e: include$1.fold_edges_e,
          map_vertex: include$1.map_vertex,
          iter_succ: include$1.iter_succ,
          iter_pred: include$1.iter_pred,
          fold_succ: include$1.fold_succ,
          fold_pred: include$1.fold_pred,
          iter_succ_e: include$1.iter_succ_e,
          fold_succ_e: include$1.fold_succ_e,
          iter_pred_e: include$1.iter_pred_e,
          fold_pred_e: include$1.fold_pred_e,
          empty: empty,
          add_vertex: include$1.add_vertex,
          remove_vertex: include$1.remove_vertex,
          add_edge: add_edge$1,
          add_edge_e: add_edge_e$2,
          remove_edge: remove_edge$3,
          remove_edge_e: remove_edge_e$3
        };
}

var Graph = {
  Concrete: Graph_Concrete,
  Abstract: Graph_Abstract,
  ConcreteLabeled: Graph_ConcreteLabeled,
  AbstractLabeled: Graph_AbstractLabeled
};

exports.Digraph = Digraph;
exports.Graph = Graph;
/* P Not a pure module */
