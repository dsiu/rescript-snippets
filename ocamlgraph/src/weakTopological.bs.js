// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Stack from "rescript/lib/es6/stack.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";

function Make(G) {
  var recursive_scc = function (g, root_g) {
    var stack = Stack.create(undefined);
    var dfn = Hashtbl.create(undefined, 1024);
    var num = {
      contents: 0
    };
    var partition = {
      contents: /* [] */0
    };
    Curry._2(G.iter_vertex, (function (v) {
            return Hashtbl.add(dfn, v, 0);
          }), g);
    var visit = function (vertex, partition) {
      var head = {
        contents: 0
      };
      var loop = {
        contents: false
      };
      Stack.push(vertex, stack);
      num.contents = num.contents + 1 | 0;
      Hashtbl.replace(dfn, vertex, num.contents);
      head.contents = num.contents;
      Curry._3(G.iter_succ, (function (succ) {
              var dfn_succ = Hashtbl.find(dfn, succ);
              var min = dfn_succ === 0 ? visit(succ, partition) : dfn_succ;
              if (min <= head.contents) {
                head.contents = min;
                loop.contents = true;
                return ;
              }
              
            }), g, vertex);
      if (head.contents === Hashtbl.find(dfn, vertex)) {
        Hashtbl.replace(dfn, vertex, Pervasives.max_int);
        var element = Stack.pop(stack);
        if (loop.contents) {
          while(Curry._2(G.V.compare, element, vertex) !== 0) {
            Hashtbl.replace(dfn, element, 0);
            element = Stack.pop(stack);
          };
          partition.contents = {
            hd: component(vertex),
            tl: partition.contents
          };
        } else {
          partition.contents = {
            hd: {
              TAG: /* Vertex */0,
              _0: vertex
            },
            tl: partition.contents
          };
        }
      }
      return head.contents;
    };
    var component = function (vertex) {
      var partition = {
        contents: /* [] */0
      };
      Curry._3(G.iter_succ, (function (succ) {
              if (Hashtbl.find(dfn, succ) === 0) {
                visit(succ, partition);
                return ;
              }
              
            }), g, vertex);
      return {
              TAG: /* Component */1,
              _0: vertex,
              _1: partition.contents
            };
    };
    visit(root_g, partition);
    return partition.contents;
  };
  return {
          recursive_scc: recursive_scc
        };
}

var fold_left = List.fold_left;

export {
  fold_left ,
  Make ,
  
}
/* No side effect */
