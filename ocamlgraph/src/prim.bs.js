// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Heap from "./lib/heap.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function Make(funarg, funarg$1) {
  var $$let = funarg.V;
  var H = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var compare = function (param, param$1) {
    var cw = Curry._2(funarg$1.compare, param$1[0], param[0]);
    if (cw !== 0) {
      return cw;
    } else {
      return Curry._2(funarg.V.compare, param[1], param$1[1]);
    }
  };
  var Elt = {
    compare: compare
  };
  var Q = Heap.Imperative(Elt);
  var spanningtree_from = function (g, r) {
    var visited = Curry._1(H.create, 97);
    var key = Curry._1(H.create, 97);
    var q = Curry._1(Q.create, 17);
    Curry._2(Q.add, q, [
          funarg$1.zero,
          r
        ]);
    while(!Curry._1(Q.is_empty, q)) {
      var match = Curry._1(Q.pop_maximum, q);
      var u = match[1];
      if (!Curry._2(H.mem, visited, u)) {
        Curry._3(H.add, visited, u, undefined);
        Curry._3(funarg.iter_succ_e, (function (e) {
                var v = Curry._1(funarg.E.dst, e);
                if (Curry._2(H.mem, visited, v)) {
                  return ;
                }
                var wuv = Curry._1(funarg$1.weight, e);
                var improvement;
                try {
                  improvement = Curry._2(funarg$1.compare, wuv, Curry._2(H.find, key, v)[0]) < 0;
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === "Not_found") {
                    improvement = true;
                  } else {
                    throw exn;
                  }
                }
                if (improvement) {
                  Curry._3(H.replace, key, v, [
                        wuv,
                        e
                      ]);
                  return Curry._2(Q.add, q, [
                              wuv,
                              v
                            ]);
                }
                
              }), g, u);
      }
      
    };
    return Curry._3(H.fold, (function (param, param$1, acc) {
                  return {
                          hd: param$1[1],
                          tl: acc
                        };
                }), key, /* [] */0);
  };
  var spanningtree = function (g) {
    var r = {
      contents: undefined
    };
    try {
      Curry._2(funarg.iter_vertex, (function (v) {
              r.contents = Caml_option.some(v);
              throw {
                    RE_EXN_ID: Pervasives.Exit,
                    Error: new Error()
                  };
            }), g);
      return Pervasives.invalid_arg("spanningtree");
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Pervasives.Exit) {
        var r$1 = r.contents;
        if (r$1 !== undefined) {
          return spanningtree_from(g, Caml_option.valFromOption(r$1));
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "prim.ml",
                85,
                14
              ],
              Error: new Error()
            };
      }
      throw exn;
    }
  };
  return {
          spanningtree: spanningtree,
          spanningtree_from: spanningtree_from
        };
}

export {
  Make ,
  
}
/* No side effect */
