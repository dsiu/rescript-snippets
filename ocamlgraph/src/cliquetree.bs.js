// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Set from "rescript/lib/es6/set.js";
import * as Caml from "rescript/lib/es6/caml.js";
import * as Gmap from "./gmap.bs.js";
import * as List from "rescript/lib/es6/list.js";
import * as Oper from "./oper.bs.js";
import * as Util from "./util.bs.js";
import * as $$Array from "rescript/lib/es6/array.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Builder from "./builder.bs.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Persistent from "./persistent.bs.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function CliqueTree(funarg) {
  $$Set.Make(funarg.V);
  var compare = function (x, y) {
    return Curry._2(funarg.V.compare, x.orig, y.orig);
  };
  var hash = function (x) {
    return Curry._1(funarg.V.hash, x.orig);
  };
  var equal = function (x, y) {
    return Curry._2(funarg.V.equal, x.orig, y.orig);
  };
  var label = function (x) {
    return x;
  };
  var create = function (o) {
    return {
            mark: 0,
            orig: o,
            m: CVS.empty,
            last: undefined,
            number: 0,
            clique: -1
          };
  };
  var vertex = function (x) {
    return x.orig;
  };
  var clique = function (x) {
    return x.clique;
  };
  var set_clique = function (x, v) {
    x.clique = v;
    
  };
  var number = function (x) {
    return x.number;
  };
  var set_number = function (x, v) {
    x.number = v;
    
  };
  var mark = function (x) {
    return x.mark;
  };
  var incr_mark = function (x) {
    x.mark = x.mark + 1 | 0;
    
  };
  var m = function (x) {
    return x.m;
  };
  var set_m = function (x, v) {
    x.m = v;
    
  };
  var last = function (x) {
    var v = x.last;
    if (v !== undefined) {
      return Caml_option.valFromOption(v);
    } else {
      return Pervasives.failwith("last not set");
    }
  };
  var set_last = function (x, v) {
    x.last = Caml_option.some(v);
    
  };
  var CliqueV = {
    compare: compare,
    hash: hash,
    equal: equal,
    label: label,
    create: create,
    vertex: vertex,
    number: number,
    set_number: set_number,
    clique: clique,
    set_clique: set_clique,
    mark: mark,
    incr_mark: incr_mark,
    m: m,
    set_m: set_m,
    last: last,
    set_last: set_last
  };
  var CVS = $$Set.Make(CliqueV);
  var partial_arg = {};
  var compare$1 = Caml.caml_int_compare;
  var equal$1 = Caml_obj.caml_equal;
  var CliqueTreeV = Util.DataV(partial_arg, {
        compare: compare$1,
        hash: Hashtbl.hash,
        equal: equal$1
      });
  var compare$2 = function (param, param$1) {
    return Caml.caml_int_compare(param[0], param$1[0]);
  };
  var default_1 = CVS.empty;
  var $$default = [
    0,
    default_1
  ];
  var create$1 = function (n, s) {
    return [
            n,
            s
          ];
  };
  var vertices = function (prim) {
    return prim[1];
  };
  var width = function (g, tri, param) {
    var vertices = List.map(vertex, Curry._1(CVS.elements, param[1]));
    var w = List.fold_left((function (w, v) {
            return List.fold_left((function (w, v$p) {
                          if (Caml_obj.caml_notequal(v, v$p) && !Curry._3(funarg.mem_edge, g, v, v$p) && Curry._3(funarg.mem_edge, tri, v, v$p)) {
                            return w + 1 | 0;
                          } else {
                            return w;
                          }
                        }), w, vertices);
          }), 0, vertices);
    if (w % 2 !== 0) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "cliquetree.ml",
              137,
              6
            ],
            Error: new Error()
          };
    }
    return w / 2 | 0;
  };
  var CliqueTreeE = {
    compare: compare$2,
    $$default: $$default,
    create: create$1,
    vertices: vertices,
    width: width
  };
  var CliqueTree$1 = Persistent.Digraph.ConcreteLabeled(CliqueTreeV, CliqueTreeE);
  var G = Persistent.Graph.Concrete(CliqueV);
  $$Set.Make(G.E);
  Hashtbl.Make({
        equal: equal,
        hash: hash
      });
  Oper.Choose({
        iter_vertex: G.iter_vertex,
        iter_edges_e: G.iter_edges_e
      });
  var $$let = funarg.V;
  var partial_arg_V = {
    hash: $$let.hash,
    equal: $$let.equal
  };
  var partial_arg_fold_vertex = funarg.fold_vertex;
  var partial_arg$1 = {
    V: partial_arg_V,
    fold_vertex: partial_arg_fold_vertex
  };
  var include = Builder.P(G);
  var Copy = Gmap.Vertex(partial_arg$1, {
        empty: include.empty,
        add_vertex: include.add_vertex
      });
  var mcs_clique = function (g) {
    var n = Curry._1(funarg.nb_vertex, g);
    var g$p = Curry._2(Copy.map, create, g);
    var unnumbered = Curry._3(G.fold_vertex, CVS.add, g$p, CVS.empty);
    var pmark = -1;
    var order = /* [] */0;
    var cliques = Caml_array.make(n, [
          /* [] */0,
          CVS.empty
        ]);
    var ties = /* [] */0;
    var j = 0;
    for(var i = n; i >= 1; --i){
      var choosed = Curry._1(CVS.choose, unnumbered);
      var match = Curry._3(CVS.fold, (function (x, max) {
              var v = Curry._1(mark, x);
              if (v > max[1]) {
                return [
                        x,
                        v
                      ];
              } else {
                return max;
              }
            }), unnumbered, [
            choosed,
            Curry._1(mark, choosed)
          ]);
      var mark$1 = match[1];
      var x = match[0];
      order = {
        hd: x,
        tl: order
      };
      unnumbered = Curry._2(CVS.remove, x, unnumbered);
      if (mark$1 <= pmark) {
        j = j + 1 | 0;
        Caml_array.set(cliques, j, [
              {
                hd: x,
                tl: /* [] */0
              },
              Curry._2(CVS.add, x, Curry._1(m, x))
            ]);
        var clast = Curry._1(clique, Curry._1(last, x));
        ties = {
          hd: [
            clast,
            Curry._1(m, x),
            j
          ],
          tl: ties
        };
      } else {
        var match$1 = Caml_array.get(cliques, j);
        Caml_array.set(cliques, j, [
              {
                hd: x,
                tl: match$1[0]
              },
              Curry._2(CVS.add, x, match$1[1])
            ]);
      }
      Curry._3(G.iter_succ, (function(x){
          return function (y) {
            if (Curry._1(number, y) === 0) {
              Curry._1(incr_mark, y);
              Curry._2(set_m, y, Curry._2(CVS.add, x, Curry._1(m, y)));
            }
            return Curry._2(set_last, y, x);
          }
          }(x)), g$p, x);
      pmark = mark$1;
      Curry._2(set_number, x, i);
      Curry._2(set_clique, x, j);
    }
    var cliques$1 = $$Array.mapi((function (i, param) {
            return Curry._2(CliqueTreeV.create, [
                        List.rev(param[0]),
                        param[1]
                      ], i);
          }), $$Array.sub(cliques, 0, j + 1 | 0));
    var tree = $$Array.fold_left(CliqueTree$1.add_vertex, CliqueTree$1.empty, cliques$1);
    var match$2 = List.fold_left((function (param, param$1) {
            var n = param[1];
            var label_1 = param$1[1];
            var label = [
              n,
              label_1
            ];
            var edge = Curry._3(CliqueTree$1.E.create, Caml_array.get(cliques$1, param$1[0]), label, Caml_array.get(cliques$1, param$1[2]));
            return [
                    Curry._2(CliqueTree$1.add_edge_e, param[0], edge),
                    n + 1 | 0
                  ];
          }), [
          tree,
          1
        ], ties);
    return [
            List.map(vertex, order),
            match$2[0],
            Caml_array.get(cliques$1, 0)
          ];
  };
  var sons = function (g, x) {
    return Curry._4(CliqueTree$1.fold_succ, (function (x, y) {
                  return {
                          hd: x,
                          tl: y
                        };
                }), g, x, /* [] */0);
  };
  var NotClique = /* @__PURE__ */Caml_exceptions.create("Cliquetree.CliqueTree(Gr).NotClique");
  var test_simpliciality_first$p = function (l, sons) {
    return List.for_all((function (son) {
                  var match = son.contents;
                  if (!match) {
                    return false;
                  }
                  var other = Curry._1(m, match.hd);
                  return Curry._2(CVS.subset, other, l);
                }), sons);
  };
  var test_simpliciality_next = function (vertices, _sons) {
    if (!vertices) {
      return true;
    }
    var x = vertices.hd;
    try {
      List.fold_left((function (vm, v$p) {
              var vm$p = Curry._1(m, v$p);
              if (Curry._2(CVS.equal, vm$p, vm)) {
                return Curry._2(CVS.add, v$p, vm$p);
              }
              throw {
                    RE_EXN_ID: NotClique,
                    Error: new Error()
                  };
            }), Curry._2(CVS.add, x, Curry._1(m, x)), vertices.tl);
      return true;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === NotClique) {
        return false;
      }
      throw exn;
    }
  };
  var is_chordal = function (g) {
    var match = mcs_clique(g);
    var tree = match[1];
    var aux = function (c) {
      var csons = sons(tree, c);
      var s = List.map(CliqueTreeV.data, csons);
      var l = Curry._1(CliqueTreeV.data, c);
      var sons$1 = function (param) {
        return List.map((function (param) {
                      return {
                              contents: param[0]
                            };
                    }), s);
      };
      var first = test_simpliciality_first$p(l[1], sons$1(undefined));
      var next = test_simpliciality_next(l[0], sons$1(undefined));
      if (first && next) {
        return List.for_all(aux, csons);
      } else {
        return false;
      }
    };
    return aux(match[2]);
  };
  var maxwidth = function (g, tri, tree) {
    return Curry._3(CliqueTree$1.fold_edges_e, (function (e, res) {
                  var w = width(g, tri, Curry._1(CliqueTree$1.E.label, e));
                  if (res > w) {
                    return res;
                  } else {
                    return w;
                  }
                }), tree, 0);
  };
  return {
          CliqueV: CliqueV,
          CVS: CVS,
          CliqueTreeV: CliqueTreeV,
          CliqueTreeE: CliqueTreeE,
          CliqueTree: CliqueTree$1,
          mcs_clique: mcs_clique,
          is_chordal: is_chordal,
          maxwidth: maxwidth
        };
}

export {
  CliqueTree ,
  
}
/* Persistent Not a pure module */
