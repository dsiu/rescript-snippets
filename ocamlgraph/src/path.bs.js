// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Heap from "./lib/heap.bs.js";
import * as List from "../../node_modules/rescript/lib/es6/list.js";
import * as Util from "./util.bs.js";
import * as Curry from "../../node_modules/rescript/lib/es6/curry.js";
import * as Queue from "../../node_modules/rescript/lib/es6/queue.js";
import * as Hashtbl from "../../node_modules/rescript/lib/es6/hashtbl.js";
import * as Components from "./components.bs.js";
import * as Caml_option from "../../node_modules/rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "../../node_modules/rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "../../node_modules/rescript/lib/es6/caml_js_exceptions.js";

function Dijkstra(funarg, funarg$1) {
  var $$let = funarg.V;
  var H = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var compare = function (param, param$1) {
    var cw = Curry._2(funarg$1.compare, param$1[0], param[0]);
    if (cw !== 0) {
      return cw;
    } else {
      return Curry._2(funarg.V.compare, param[1], param$1[1]);
    }
  };
  var Elt = {
    compare: compare
  };
  var PQ = Heap.Imperative(Elt);
  var shortest_path = function (g, v1, v2) {
    var visited = Curry._1(H.create, 97);
    var dist = Curry._1(H.create, 97);
    var q = Curry._1(PQ.create, 17);
    Curry._2(PQ.add, q, [
          funarg$1.zero,
          v1,
          /* [] */0
        ]);
    Curry._3(H.add, dist, v1, funarg$1.zero);
    var _param;
    while(true) {
      if (Curry._1(PQ.is_empty, q)) {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      var match = Curry._1(PQ.pop_maximum, q);
      var p = match[2];
      var v = match[1];
      var w = match[0];
      if (Curry._2(funarg.V.compare, v, v2) === 0) {
        return [
                List.rev(p),
                w
              ];
      }
      if (!Curry._2(H.mem, visited, v)) {
        Curry._3(H.add, visited, v, undefined);
        Curry._3(funarg.iter_succ_e, (function(p,w){
            return function (e) {
              var ev = Curry._1(funarg.E.dst, e);
              if (Curry._2(H.mem, visited, ev)) {
                return ;
              }
              var dev = Curry._2(funarg$1.add, w, Curry._1(funarg$1.weight, e));
              var improvement;
              try {
                improvement = Curry._2(funarg$1.compare, dev, Curry._2(H.find, dist, ev)) < 0;
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.RE_EXN_ID === "Not_found") {
                  improvement = true;
                } else {
                  throw exn;
                }
              }
              if (improvement) {
                Curry._3(H.replace, dist, ev, dev);
                return Curry._2(PQ.add, q, [
                            dev,
                            ev,
                            {
                              hd: e,
                              tl: p
                            }
                          ]);
              }
              
            }
            }(p,w)), g, v);
      }
      _param = undefined;
      continue ;
    };
  };
  return {
          shortest_path: shortest_path
        };
}

function BellmanFord(funarg, funarg$1) {
  var $$let = funarg.V;
  var H = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var NegativeCycle = /* @__PURE__ */Caml_exceptions.create("Path.BellmanFord(G)(W).NegativeCycle");
  var all_shortest_paths = function (g, vs) {
    var dist = Curry._1(H.create, 97);
    Curry._3(H.add, dist, vs, funarg$1.zero);
    var admissible = Curry._1(H.create, 97);
    var find_cycle = function (x0) {
      var visited = Curry._1(H.create, 97);
      var _x = x0;
      while(true) {
        var x = _x;
        if (Curry._2(H.mem, visited, x)) {
          var _x$1 = x;
          var _ret = /* [] */0;
          while(true) {
            var ret = _ret;
            var x$1 = _x$1;
            var e = Curry._2(H.find, admissible, x$1);
            var s = Curry._1(funarg.E.src, e);
            if (Curry._2(funarg.V.equal, s, x)) {
              return {
                      hd: e,
                      tl: ret
                    };
            }
            _ret = {
              hd: e,
              tl: ret
            };
            _x$1 = s;
            continue ;
          };
        }
        Curry._3(H.add, visited, x, undefined);
        var e$1 = Curry._2(H.find, admissible, x);
        _x = Curry._1(funarg.E.src, e$1);
        continue ;
      };
    };
    var _i = 0;
    while(true) {
      var i = _i;
      var update = Curry._3(funarg.fold_edges_e, (function (e, x) {
              var ev1 = Curry._1(funarg.E.src, e);
              var ev2 = Curry._1(funarg.E.dst, e);
              try {
                var dev1 = Curry._2(H.find, dist, ev1);
                var dev2 = Curry._2(funarg$1.add, dev1, Curry._1(funarg$1.weight, e));
                var improvement;
                try {
                  improvement = Curry._2(funarg$1.compare, dev2, Curry._2(H.find, dist, ev2)) < 0;
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === "Not_found") {
                    improvement = true;
                  } else {
                    throw exn;
                  }
                }
                if (improvement) {
                  Curry._3(H.replace, dist, ev2, dev2);
                  Curry._3(H.replace, admissible, ev2, e);
                  return Caml_option.some(ev2);
                } else {
                  return x;
                }
              }
              catch (raw_exn$1){
                var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.RE_EXN_ID === "Not_found") {
                  return x;
                }
                throw exn$1;
              }
            }), g, undefined);
      if (update === undefined) {
        return dist;
      }
      if (i === Curry._1(funarg.nb_vertex, g)) {
        throw {
              RE_EXN_ID: NegativeCycle,
              _1: find_cycle(Caml_option.valFromOption(update)),
              Error: new Error()
            };
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  var find_negative_cycle_from = function (g, vs) {
    try {
      all_shortest_paths(g, vs);
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    catch (raw_l){
      var l = Caml_js_exceptions.internalToOCamlException(raw_l);
      if (l.RE_EXN_ID === NegativeCycle) {
        return l._1;
      }
      throw l;
    }
  };
  var Comp = Components.Make({
        V: funarg.V,
        iter_vertex: funarg.iter_vertex,
        iter_succ: funarg.iter_succ
      });
  var find_negative_cycle = function (g) {
    var _param = Curry._1(Comp.scc_list, g);
    while(true) {
      var param = _param;
      if (param) {
        var match = param.hd;
        if (match) {
          try {
            return find_negative_cycle_from(g, match.hd);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "Not_found") {
              _param = param.tl;
              continue ;
            }
            throw exn;
          }
        } else {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "path.ml",
                  186,
                  8
                ],
                Error: new Error()
              };
        }
      } else {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
    };
  };
  return {
          H: H,
          NegativeCycle: NegativeCycle,
          all_shortest_paths: all_shortest_paths,
          find_negative_cycle_from: find_negative_cycle_from,
          find_negative_cycle: find_negative_cycle
        };
}

function Johnson(funarg, funarg$1) {
  var $$let = funarg.V;
  var partial_arg_hash = $$let.hash;
  var partial_arg_equal = $$let.equal;
  var partial_arg = {
    hash: partial_arg_hash,
    equal: partial_arg_equal
  };
  var $$let$1 = funarg.V;
  var $$let$2 = Util.HTProduct(partial_arg, {
        hash: $$let$1.hash,
        equal: $$let$1.equal
      });
  var HVV = Hashtbl.Make({
        equal: $$let$2.equal,
        hash: $$let$2.hash
      });
  var compare = function (v, u) {
    if (v) {
      if (u) {
        return Curry._2(funarg.V.compare, v._0, u._0);
      } else {
        return 1;
      }
    } else if (u) {
      return -1;
    } else {
      return 0;
    }
  };
  var hash = function (v) {
    if (v) {
      return Curry._1(funarg.V.hash, v._0);
    } else {
      return 42;
    }
  };
  var equal = function (v, u) {
    if (v) {
      if (u) {
        return Curry._2(funarg.V.equal, v._0, u._0);
      } else {
        return false;
      }
    } else if (u) {
      return false;
    } else {
      return true;
    }
  };
  var V = {
    compare: compare,
    hash: hash,
    equal: equal
  };
  var src = function (e) {
    if (e.TAG === /* NewE */0) {
      return /* New */0;
    } else {
      return /* Old */{
              _0: Curry._1(funarg.E.src, e._0)
            };
    }
  };
  var dst = function (e) {
    if (e.TAG === /* NewE */0) {
      return e._0;
    } else {
      return /* Old */{
              _0: Curry._1(funarg.E.dst, e._0)
            };
    }
  };
  var label = function (e) {
    if (e.TAG !== /* NewE */0) {
      return Curry._1(funarg.E.label, e._0);
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "path.ml",
            226,
            20
          ],
          Error: new Error()
        };
  };
  var create = function (v, l, u) {
    if (v) {
      if (u) {
        return {
                TAG: /* OldE */1,
                _0: Curry._3(funarg.E.create, v._0, l, u._0)
              };
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "path.ml",
              231,
              18
            ],
            Error: new Error()
          };
    }
    if (u) {
      return {
              TAG: /* NewE */0,
              _0: /* Old */{
                _0: u._0
              }
            };
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "path.ml",
            231,
            18
          ],
          Error: new Error()
        };
  };
  var iter_vertex = function (f, g) {
    Curry._1(f, /* New */0);
    return Curry._2(funarg.iter_vertex, (function (v) {
                  return Curry._1(f, /* Old */{
                              _0: v
                            });
                }), g);
  };
  var fold_vertex = function (f, g, acc) {
    var acc$p = Curry._2(f, /* New */0, acc);
    return Curry._3(funarg.fold_vertex, (function (v, a) {
                  return Curry._2(f, /* Old */{
                              _0: v
                            }, a);
                }), g, acc$p);
  };
  var iter_succ = function (f, g, v) {
    if (v) {
      return Curry._3(funarg.iter_succ, (function (u) {
                    return Curry._1(f, /* Old */{
                                _0: u
                              });
                  }), g, v._0);
    } else {
      return Curry._2(funarg.iter_vertex, (function (u) {
                    return Curry._1(f, /* Old */{
                                _0: u
                              });
                  }), g);
    }
  };
  var iter_succ_e = function (f, g, v) {
    if (v) {
      return Curry._3(funarg.iter_succ_e, (function (e) {
                    return Curry._1(f, {
                                TAG: /* OldE */1,
                                _0: e
                              });
                  }), g, v._0);
    } else {
      return Curry._2(funarg.iter_vertex, (function (u) {
                    return Curry._1(f, {
                                TAG: /* NewE */0,
                                _0: /* Old */{
                                  _0: u
                                }
                              });
                  }), g);
    }
  };
  var fold_edges_e = function (f, g, acc) {
    var acc$p = Curry._3(funarg.fold_vertex, (function (x, param) {
            return Curry._2(f, {
                        TAG: /* NewE */0,
                        _0: /* Old */{
                          _0: x
                        }
                      }, acc);
          }), g, acc);
    return Curry._3(funarg.fold_edges_e, (function (edg) {
                  var v1 = Curry._1(funarg.E.src, edg);
                  var v2 = Curry._1(funarg.E.dst, edg);
                  var l = Curry._1(funarg.E.label, edg);
                  return Curry._1(f, create(/* Old */{
                                  _0: v1
                                }, l, /* Old */{
                                  _0: v2
                                }));
                }), g, acc$p);
  };
  var nb_vertex = function (g) {
    return Curry._1(funarg.nb_vertex, g) + 1 | 0;
  };
  var zero = funarg$1.zero;
  var weight = function (e) {
    if (e.TAG === /* NewE */0) {
      return zero;
    } else {
      return Curry._1(funarg$1.weight, e._0);
    }
  };
  var compare$1 = funarg$1.compare;
  var add = funarg$1.add;
  var partial_arg_E = {
    label: label,
    src: src,
    dst: dst,
    create: create
  };
  var H = Hashtbl.Make({
        equal: equal,
        hash: hash
      });
  var NegativeCycle = /* @__PURE__ */Caml_exceptions.create("Path.BellmanFord(G)(W).NegativeCycle");
  var all_shortest_paths = function (g, vs) {
    var dist = Curry._1(H.create, 97);
    Curry._3(H.add, dist, vs, zero);
    var admissible = Curry._1(H.create, 97);
    var find_cycle = function (x0) {
      var visited = Curry._1(H.create, 97);
      var _x = x0;
      while(true) {
        var x = _x;
        if (Curry._2(H.mem, visited, x)) {
          var _x$1 = x;
          var _ret = /* [] */0;
          while(true) {
            var ret = _ret;
            var x$1 = _x$1;
            var e = Curry._2(H.find, admissible, x$1);
            var s = Curry._1(partial_arg_E.src, e);
            if (equal(s, x)) {
              return {
                      hd: e,
                      tl: ret
                    };
            }
            _ret = {
              hd: e,
              tl: ret
            };
            _x$1 = s;
            continue ;
          };
        }
        Curry._3(H.add, visited, x, undefined);
        var e$1 = Curry._2(H.find, admissible, x);
        _x = Curry._1(partial_arg_E.src, e$1);
        continue ;
      };
    };
    var _i = 0;
    while(true) {
      var i = _i;
      var update = fold_edges_e((function (e, x) {
              var ev1 = Curry._1(partial_arg_E.src, e);
              var ev2 = Curry._1(partial_arg_E.dst, e);
              try {
                var dev1 = Curry._2(H.find, dist, ev1);
                var dev2 = Curry._2(add, dev1, weight(e));
                var improvement;
                try {
                  improvement = Curry._2(compare$1, dev2, Curry._2(H.find, dist, ev2)) < 0;
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === "Not_found") {
                    improvement = true;
                  } else {
                    throw exn;
                  }
                }
                if (improvement) {
                  Curry._3(H.replace, dist, ev2, dev2);
                  Curry._3(H.replace, admissible, ev2, e);
                  return Caml_option.some(ev2);
                } else {
                  return x;
                }
              }
              catch (raw_exn$1){
                var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                if (exn$1.RE_EXN_ID === "Not_found") {
                  return x;
                }
                throw exn$1;
              }
            }), g, undefined);
      if (update === undefined) {
        return dist;
      }
      if (i === nb_vertex(g)) {
        throw {
              RE_EXN_ID: NegativeCycle,
              _1: find_cycle(Caml_option.valFromOption(update)),
              Error: new Error()
            };
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  var find_negative_cycle_from = function (g, vs) {
    try {
      all_shortest_paths(g, vs);
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    catch (raw_l){
      var l = Caml_js_exceptions.internalToOCamlException(raw_l);
      if (l.RE_EXN_ID === NegativeCycle) {
        return l._1;
      }
      throw l;
    }
  };
  var Comp = Components.Make({
        V: V,
        iter_vertex: iter_vertex,
        iter_succ: iter_succ
      });
  var find_negative_cycle = function (g) {
    var _param = Curry._1(Comp.scc_list, g);
    while(true) {
      var param = _param;
      if (param) {
        var match = param.hd;
        if (match) {
          try {
            return find_negative_cycle_from(g, match.hd);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "Not_found") {
              _param = param.tl;
              continue ;
            }
            throw exn;
          }
        } else {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "path.ml",
                  186,
                  8
                ],
                Error: new Error()
              };
        }
      } else {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
    };
  };
  var all_pairs_shortest_paths = function (g) {
    var pairs_dist = Curry._1(HVV.create, 97);
    var bf_res = Curry._2(all_shortest_paths, g, /* New */0);
    var add = funarg$1.add;
    var sub = funarg$1.sub;
    var weight = function (e) {
      var v1 = Curry._1(funarg.E.src, e);
      var v2 = Curry._1(funarg.E.dst, e);
      return Curry._2(add, Curry._1(funarg$1.weight, e), Curry._2(funarg$1.sub, Curry._2(H.find, bf_res, /* Old */{
                          _0: v1
                        }), Curry._2(H.find, bf_res, /* Old */{
                          _0: v2
                        })));
    };
    var compare = funarg$1.compare;
    var zero = funarg$1.zero;
    var $$let = funarg.V;
    var H$1 = Hashtbl.Make({
          equal: $$let.equal,
          hash: $$let.hash
        });
    var compare$1 = function (param, param$1) {
      var cw = Curry._2(compare, param$1[0], param[0]);
      if (cw !== 0) {
        return cw;
      } else {
        return Curry._2(funarg.V.compare, param[1], param$1[1]);
      }
    };
    var Elt = {
      compare: compare$1
    };
    var PQ = Heap.Imperative(Elt);
    var shortest_path = function (g, v1, v2) {
      var visited = Curry._1(H$1.create, 97);
      var dist = Curry._1(H$1.create, 97);
      var q = Curry._1(PQ.create, 17);
      Curry._2(PQ.add, q, [
            zero,
            v1,
            /* [] */0
          ]);
      Curry._3(H$1.add, dist, v1, zero);
      var _param;
      while(true) {
        if (Curry._1(PQ.is_empty, q)) {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        var match = Curry._1(PQ.pop_maximum, q);
        var p = match[2];
        var v = match[1];
        var w = match[0];
        if (Curry._2(funarg.V.compare, v, v2) === 0) {
          return [
                  List.rev(p),
                  w
                ];
        }
        if (!Curry._2(H$1.mem, visited, v)) {
          Curry._3(H$1.add, visited, v, undefined);
          Curry._3(funarg.iter_succ_e, (function(p,w){
              return function (e) {
                var ev = Curry._1(funarg.E.dst, e);
                if (Curry._2(H$1.mem, visited, ev)) {
                  return ;
                }
                var dev = Curry._2(add, w, weight(e));
                var improvement;
                try {
                  improvement = Curry._2(compare, dev, Curry._2(H$1.find, dist, ev)) < 0;
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === "Not_found") {
                    improvement = true;
                  } else {
                    throw exn;
                  }
                }
                if (improvement) {
                  Curry._3(H$1.replace, dist, ev, dev);
                  return Curry._2(PQ.add, q, [
                              dev,
                              ev,
                              {
                                hd: e,
                                tl: p
                              }
                            ]);
                }
                
              }
              }(p,w)), g, v);
        }
        _param = undefined;
        continue ;
      };
    };
    Curry._2(funarg.iter_vertex, (function (v) {
            return Curry._2(funarg.iter_vertex, (function (u) {
                          try {
                            var match = Curry._3(shortest_path, g, v, u);
                            return Curry._3(HVV.add, pairs_dist, [
                                        v,
                                        u
                                      ], Curry._2(add, match[1], Curry._2(sub, Curry._2(H.find, bf_res, /* Old */{
                                                    _0: u
                                                  }), Curry._2(H.find, bf_res, /* Old */{
                                                    _0: v
                                                  }))));
                          }
                          catch (raw_exn){
                            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                            if (exn.RE_EXN_ID === "Not_found") {
                              return ;
                            }
                            throw exn;
                          }
                        }), g);
          }), g);
    return pairs_dist;
  };
  return {
          HVV: HVV,
          all_pairs_shortest_paths: all_pairs_shortest_paths
        };
}

function Check(funarg) {
  var $$let = funarg.V;
  var HV = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var $$let$1 = funarg.V;
  var partial_arg_hash = $$let$1.hash;
  var partial_arg_equal = $$let$1.equal;
  var partial_arg = {
    hash: partial_arg_hash,
    equal: partial_arg_equal
  };
  var $$let$2 = funarg.V;
  var $$let$3 = Util.HTProduct(partial_arg, {
        hash: $$let$2.hash,
        equal: $$let$2.equal
      });
  var HVV = Hashtbl.Make({
        equal: $$let$3.equal,
        hash: $$let$3.hash
      });
  var create = function (g) {
    return {
            cache: Curry._1(HVV.create, 97),
            graph: g
          };
  };
  var check_path = function (pc, v1, v2) {
    try {
      return Curry._2(HVV.find, pc.cache, [
                  v1,
                  v2
                ]);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        var visited = Curry._1(HV.create, 97);
        var q = Queue.create(undefined);
        Queue.add(v1, q);
        var _param;
        while(true) {
          if (Queue.is_empty(q)) {
            Curry._3(HVV.add, pc.cache, [
                  v1,
                  v2
                ], false);
            return false;
          }
          var v = Queue.pop(q);
          Curry._3(HVV.add, pc.cache, [
                v1,
                v
              ], true);
          if (Curry._2(funarg.V.compare, v, v2) === 0) {
            return true;
          }
          if (!Curry._2(HV.mem, visited, v)) {
            Curry._3(HV.add, visited, v, undefined);
            Curry._3(funarg.iter_succ, (function (v$p) {
                    return Queue.add(v$p, q);
                  }), pc.graph, v);
          }
          _param = undefined;
          continue ;
        };
      }
      throw exn;
    }
  };
  return {
          create: create,
          check_path: check_path
        };
}

export {
  Dijkstra ,
  BellmanFord ,
  Johnson ,
  Check ,
  
}
/* No side effect */
