// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Set from "../../node_modules/rescript/lib/es6/set.js";
import * as Gmap from "./gmap.bs.js";
import * as List from "../../node_modules/rescript/lib/es6/list.js";
import * as Oper from "./oper.bs.js";
import * as Util from "./util.bs.js";
import * as Curry from "../../node_modules/rescript/lib/es6/curry.js";
import * as Builder from "./builder.bs.js";
import * as Hashtbl from "../../node_modules/rescript/lib/es6/hashtbl.js";
import * as Caml_obj from "../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Imperative from "./imperative.bs.js";
import * as Persistent from "./persistent.bs.js";

function MaximalCardinalitySearch_P(funarg) {
  var partial_arg = {};
  var include = Util.DataV(partial_arg, funarg.V);
  var hash = include.hash;
  var equal = include.equal;
  var create = include.create;
  var label = include.label;
  var data = include.data;
  var set_data = include.set_data;
  var NewV_compare = include.compare;
  var NewV = {
    compare: NewV_compare,
    hash: hash,
    equal: equal,
    create: create,
    label: label,
    data: data,
    set_data: set_data,
    weight: data,
    set_weight: set_data
  };
  var G = Persistent.Graph.Concrete(NewV);
  var EdgeSet = $$Set.Make(G.E);
  var VerticesSet = $$Set.Make(NewV);
  var Choose = Oper.Choose({
        iter_vertex: G.iter_vertex,
        iter_edges_e: G.iter_edges_e
      });
  var H = Hashtbl.Make({
        equal: equal,
        hash: hash
      });
  var check_path = function (g, u, v) {
    var h = Curry._1(H.create, 97);
    var maxw = Curry._1(data, u);
    var aux = function (x) {
      if (Curry._2(H.mem, h, x)) {
        return false;
      } else if (Caml_obj.caml_equal(x, v)) {
        return true;
      } else if (Curry._1(data, x) < maxw || Caml_obj.caml_equal(x, u)) {
        Curry._3(H.add, h, x, undefined);
        return Curry._4(G.fold_succ, (function (x, found) {
                      if (found) {
                        return found;
                      } else {
                        return aux(x);
                      }
                    }), g, x, false);
      } else {
        Curry._3(H.add, h, x, undefined);
        return false;
      }
    };
    return aux(u);
  };
  var $$let = funarg.V;
  var partial_arg_V = {
    hash: $$let.hash,
    equal: $$let.equal
  };
  var partial_arg_fold_vertex = funarg.fold_vertex;
  var partial_arg$1 = {
    V: partial_arg_V,
    fold_vertex: partial_arg_fold_vertex
  };
  var include$1 = Builder.P(G);
  var Copy = Gmap.Vertex(partial_arg$1, {
        empty: include$1.empty,
        add_vertex: include$1.add_vertex
      });
  var fold = function (f, d) {
    var _param = d;
    while(true) {
      var param = _param;
      if (!param[0]) {
        return param[1];
      }
      _param = Curry._1(f, param[1]);
      continue ;
    };
  };
  var mcsm = function (g) {
    var g$p = Curry._2(Copy.map, Curry._1(create, 0), g);
    var match = fold((function (x) {
            var i = x[0];
            if (i === 0) {
              return [
                      false,
                      x
                    ];
            }
            var g$p = x[1];
            var v = Curry._3(G.fold_vertex, (function (x, max) {
                    if (Curry._1(data, x) > Curry._1(data, max)) {
                      return x;
                    } else {
                      return max;
                    }
                  }), g$p, [
                  {
                    contents: 0
                  },
                  Curry._1(Choose.choose_vertex, g$p)[1]
                ]);
            var s = Curry._3(G.fold_vertex, (function (x, s) {
                    if (Caml_obj.caml_equal(x, v) || !check_path(g$p, x, v)) {
                      return s;
                    } else {
                      return Curry._2(VerticesSet.add, x, s);
                    }
                  }), g$p, VerticesSet.empty);
            var f$p = Curry._3(VerticesSet.fold, (function (x, f) {
                    Curry._2(set_data, x, Curry._1(data, x) + 1 | 0);
                    if (Curry._3(G.mem_edge, g$p, x, v)) {
                      return f;
                    } else {
                      return Curry._2(EdgeSet.add, [
                                  x,
                                  v
                                ], f);
                    }
                  }), s, x[3]);
            var g$p$1 = Curry._2(G.remove_vertex, g$p, v);
            var a$p_0 = [
              i,
              Curry._1(label, v)
            ];
            var a$p_1 = x[2];
            var a$p = {
              hd: a$p_0,
              tl: a$p_1
            };
            return [
                    true,
                    [
                      i - 1 | 0,
                      g$p$1,
                      a$p,
                      f$p
                    ]
                  ];
          }), [
          true,
          [
            Curry._1(funarg.nb_vertex, g),
            g$p,
            /* [] */0,
            EdgeSet.empty
          ]
        ]);
    return [
            List.rev(match[2]),
            Curry._3(EdgeSet.fold, (function (param, e) {
                    return {
                            hd: [
                              Curry._1(label, param[0]),
                              Curry._1(label, param[1])
                            ],
                            tl: e
                          };
                  }), match[3], /* [] */0)
          ];
  };
  var triangulate = function (g) {
    var match = mcsm(g);
    return List.fold_left((function (g, param) {
                  return Curry._3(funarg.add_edge, g, param[0], param[1]);
                }), g, match[1]);
  };
  return {
          mcsm: mcsm,
          triangulate: triangulate
        };
}

function MaximalCardinalitySearch_I(funarg) {
  var partial_arg = {};
  var include = Util.DataV(partial_arg, funarg.V);
  var hash = include.hash;
  var equal = include.equal;
  var create = include.create;
  var label = include.label;
  var data = include.data;
  var set_data = include.set_data;
  var NewV_compare = include.compare;
  var NewV = {
    compare: NewV_compare,
    hash: hash,
    equal: equal,
    create: create,
    label: label,
    data: data,
    set_data: set_data,
    weight: data,
    set_weight: set_data
  };
  var G = Imperative.Graph.Concrete(NewV);
  var EdgeSet = $$Set.Make(G.E);
  var VerticesSet = $$Set.Make(NewV);
  var Choose = Oper.Choose({
        iter_vertex: G.iter_vertex,
        iter_edges_e: G.iter_edges_e
      });
  var H = Hashtbl.Make({
        equal: equal,
        hash: hash
      });
  var check_path = function (g, u, v) {
    var h = Curry._1(H.create, 97);
    var maxw = Curry._1(data, u);
    var aux = function (x) {
      if (Curry._2(H.mem, h, x)) {
        return false;
      } else if (Caml_obj.caml_equal(x, v)) {
        return true;
      } else if (Curry._1(data, x) < maxw || Caml_obj.caml_equal(x, u)) {
        Curry._3(H.add, h, x, undefined);
        return Curry._4(G.fold_succ, (function (x, found) {
                      if (found) {
                        return found;
                      } else {
                        return aux(x);
                      }
                    }), g, x, false);
      } else {
        Curry._3(H.add, h, x, undefined);
        return false;
      }
    };
    return aux(u);
  };
  var $$let = funarg.V;
  var partial_arg_V = {
    hash: $$let.hash,
    equal: $$let.equal
  };
  var partial_arg_fold_vertex = funarg.fold_vertex;
  var partial_arg$1 = {
    V: partial_arg_V,
    fold_vertex: partial_arg_fold_vertex
  };
  var include$1 = Builder.I(G);
  var Copy = Gmap.Vertex(partial_arg$1, {
        empty: include$1.empty,
        add_vertex: include$1.add_vertex
      });
  var mcsm = function (g) {
    var f = EdgeSet.empty;
    var a = /* [] */0;
    var g$p = Curry._2(Copy.map, Curry._1(create, 0), g);
    for(var i = Curry._1(funarg.nb_vertex, g); i >= 1; --i){
      var v = Curry._3(G.fold_vertex, (function (x, max) {
              if (Curry._1(data, x) > Curry._1(data, max)) {
                return x;
              } else {
                return max;
              }
            }), g$p, [
            {
              contents: 0
            },
            Curry._1(Choose.choose_vertex, g$p)[1]
          ]);
      var s = Curry._3(G.fold_vertex, (function(v){
          return function (x, s) {
            if (Caml_obj.caml_equal(x, v) || !check_path(g$p, x, v)) {
              return s;
            } else {
              return Curry._2(VerticesSet.add, x, s);
            }
          }
          }(v)), g$p, VerticesSet.empty);
      var f$p = Curry._3(VerticesSet.fold, (function(v){
          return function (x, f) {
            Curry._2(set_data, x, Curry._1(data, x) + 1 | 0);
            if (Curry._3(G.mem_edge, g$p, x, v)) {
              return f;
            } else {
              return Curry._2(EdgeSet.add, [
                          x,
                          v
                        ], f);
            }
          }
          }(v)), s, f);
      f = f$p;
      Curry._2(G.remove_vertex, g$p, v);
      a = {
        hd: [
          i,
          Curry._1(label, v)
        ],
        tl: a
      };
    }
    return [
            List.rev(a),
            Curry._3(EdgeSet.fold, (function (param, e) {
                    return {
                            hd: [
                              Curry._1(label, param[0]),
                              Curry._1(label, param[1])
                            ],
                            tl: e
                          };
                  }), f, /* [] */0)
          ];
  };
  var triangulate = function (g) {
    var match = mcsm(g);
    return List.iter((function (param) {
                  return Curry._3(funarg.add_edge, g, param[0], param[1]);
                }), match[1]);
  };
  return {
          mcsm: mcsm,
          triangulate: triangulate
        };
}

var MaximalCardinalitySearch = {
  P: MaximalCardinalitySearch_P,
  I: MaximalCardinalitySearch_I
};

export {
  MaximalCardinalitySearch ,
  
}
/* Imperative Not a pure module */
