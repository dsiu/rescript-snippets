// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Map from "../../node_modules/rescript/lib/es6/map.js";
import * as $$Set from "../../node_modules/rescript/lib/es6/set.js";
import * as List from "../../node_modules/rescript/lib/es6/list.js";
import * as Curry from "../../node_modules/rescript/lib/es6/curry.js";
import * as Builder from "./builder.bs.js";
import * as Caml_obj from "../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Components from "./components.bs.js";
import * as Pervasives from "../../node_modules/rescript/lib/es6/pervasives.js";
import * as Caml_option from "../../node_modules/rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "../../node_modules/rescript/lib/es6/caml_js_exceptions.js";

function B(funarg) {
  var mem = function (x, ec) {
    return List.exists((function (y) {
                  return Curry._2(funarg.G.V.equal, x, y);
                }), ec);
  };
  var identify = function (x, ec) {
    if (ec && mem(x, ec.tl)) {
      return [
              true,
              ec.hd
            ];
    } else {
      return [
              false,
              x
            ];
    }
  };
  var identify_extremities = function (g, vl) {
    var f = function (e, accu) {
      var match = identify(Curry._1(funarg.G.E.src, e), vl);
      var match$1 = identify(Curry._1(funarg.G.E.dst, e), vl);
      if (match[0] || match$1[0]) {
        return {
                hd: Curry._3(funarg.G.E.create, match[1], Curry._1(funarg.G.E.label, e), match$1[1]),
                tl: accu
              };
      } else {
        return accu;
      }
    };
    return Curry._3(funarg.G.fold_edges_e, f, g, /* [] */0);
  };
  var merge_vertex = function (g, vl) {
    if (!vl) {
      return g;
    }
    var to_be_added = identify_extremities(g, vl);
    var g$1 = List.fold_left(funarg.remove_vertex, g, vl.tl);
    if (to_be_added === /* [] */0) {
      return Curry._2(funarg.add_vertex, g$1, vl.hd);
    } else {
      return List.fold_left(funarg.add_edge_e, g$1, to_be_added);
    }
  };
  var merge_edges_e = function (src, dst, g, el) {
    if (!el) {
      return g;
    }
    var e = el.hd;
    var el$p = List.filter(Curry._1(funarg.G.mem_edge_e, g))(el.tl);
    if (el$p === /* [] */0) {
      return g;
    }
    var el$1 = {
      hd: e,
      tl: el$p
    };
    var extremities = function (e) {
      return [
              Curry._1(funarg.G.E.src, e),
              Curry._1(funarg.G.E.dst, e)
            ];
    };
    var match = List.split(List.map(extremities, el$1));
    var destinations = match[1];
    var sources = match[0];
    var remove = function (accu, e) {
      try {
        return Curry._2(funarg.remove_edge_e, accu, e);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Invalid_argument") {
          return g;
        }
        throw exn;
      }
    };
    var g$1 = List.fold_left(remove, g, el$1);
    if (List.exists((function (v) {
              return mem(v, destinations);
            }), sources)) {
      var v = src !== undefined ? Caml_option.valFromOption(src) : (
          dst !== undefined ? Caml_option.valFromOption(dst) : List.hd(sources)
        );
      var g$2 = merge_vertex(g$1, Pervasives.$at({
                hd: v,
                tl: sources
              }, destinations));
      return Curry._2(funarg.add_edge_e, g$2, Curry._3(funarg.G.E.create, v, Curry._1(funarg.G.E.label, e), v));
    }
    var v$1 = src !== undefined ? Caml_option.valFromOption(src) : List.hd(sources);
    var w = src !== undefined ? Caml_option.valFromOption(src) : List.hd(destinations);
    var g$3 = merge_vertex(g$1, sources);
    var g$4 = merge_vertex(g$3, destinations);
    return Curry._2(funarg.add_edge_e, g$4, Curry._3(funarg.G.E.create, v$1, Curry._1(funarg.G.E.label, e), w));
  };
  var merge_edges_with_label = function (src, dst, label, g, l) {
    var update_label = function (e) {
      if (label !== undefined) {
        return Curry._3(funarg.G.E.create, Curry._1(funarg.G.E.src, e), Caml_option.valFromOption(label), Curry._1(funarg.G.E.dst, e));
      } else {
        return e;
      }
    };
    var collect_edge = function (e, accu) {
      if (Caml_obj.caml_equal(Curry._1(funarg.G.E.label, e), l)) {
        return {
                hd: update_label(e),
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var edges_to_be_merged = Curry._3(funarg.G.fold_edges_e, collect_edge, g, /* [] */0);
    return merge_edges_e(src, dst, g, edges_to_be_merged);
  };
  var compare_label = function (g) {
    try {
      var a_vertex_of_g = {
        contents: undefined
      };
      try {
        Curry._2(funarg.G.iter_vertex, (function (v) {
                a_vertex_of_g.contents = Caml_option.some(v);
                throw {
                      RE_EXN_ID: Pervasives.Exit,
                      Error: new Error()
                    };
              }), g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID !== Pervasives.Exit) {
          throw exn;
        }
        
      }
      var v = a_vertex_of_g.contents;
      var default_vertex;
      if (v !== undefined) {
        default_vertex = Caml_option.valFromOption(v);
      } else {
        throw {
              RE_EXN_ID: Pervasives.Exit,
              Error: new Error()
            };
      }
      return function (l1, l2) {
        var e1 = Curry._3(funarg.G.E.create, default_vertex, l1, default_vertex);
        var e2 = Curry._3(funarg.G.E.create, default_vertex, l2, default_vertex);
        return Curry._2(funarg.G.E.compare, e1, e2);
      };
    }
    catch (raw_exn$1){
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.RE_EXN_ID === Pervasives.Exit) {
        return function (param, param$1) {
          return 0;
        };
      }
      throw exn$1;
    }
  };
  var merge_isolabelled_edges = function (g) {
    var S = $$Set.Make(funarg.G.V);
    var do_meet = function (s1, s2) {
      return Curry._2(S.exists, (function (x) {
                    return Curry._2(S.mem, x, s2);
                  }), s1);
    };
    var compare = compare_label(g);
    var M = $$Map.Make({
          compare: compare
        });
    var accumulating = function (e, accu) {
      var l = Curry._1(funarg.G.E.label, e);
      try {
        var match = Curry._2(M.find, l, accu);
        var s = Curry._2(S.add, Curry._1(funarg.G.E.src, e), match[0]);
        var d = Curry._2(S.add, Curry._1(funarg.G.E.dst, e), match[1]);
        return Curry._3(M.add, l, [
                    s,
                    d
                  ], accu);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return Curry._3(M.add, l, [
                      Curry._1(S.singleton, Curry._1(funarg.G.E.src, e)),
                      Curry._1(S.singleton, Curry._1(funarg.G.E.dst, e))
                    ], accu);
        }
        throw exn;
      }
    };
    var to_be_identified = Curry._3(funarg.G.fold_edges_e, accumulating, g, M.empty);
    var gathering = function (param, param$1, accu) {
      var d = param$1[1];
      var s = param$1[0];
      var match = List.partition((function (param) {
              return do_meet(s, param);
            }), accu);
      var accu_0 = List.fold_left((function (accu, x) {
              return Curry._2(S.union, accu, x);
            }), s, match[0]);
      var accu_1 = match[1];
      var accu$1 = {
        hd: accu_0,
        tl: accu_1
      };
      var match$1 = List.partition((function (param) {
              return do_meet(d, param);
            }), accu$1);
      return {
              hd: List.fold_left((function (accu, x) {
                      return Curry._2(S.union, accu, x);
                    }), d, match$1[0]),
              tl: match$1[1]
            };
    };
    var to_be_identified$1 = Curry._3(M.fold, gathering, to_be_identified, /* [] */0);
    return List.fold_left((function (accu, s) {
                  return merge_vertex(accu, Curry._1(S.elements, s));
                }), g, to_be_identified$1);
  };
  var merge_ends = function (strictOpt, specified_vertex, g) {
    var strict = strictOpt !== undefined ? strictOpt : false;
    var accumulator = function (v, accu) {
      var out_d = Curry._2(funarg.G.out_degree, g, v);
      if (out_d === 0 || !strict && out_d === List.length(Curry._3(funarg.G.find_all_edges, g, v, v))) {
        return {
                hd: v,
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var ends = Curry._3(funarg.G.fold_vertex, accumulator, g, /* [] */0);
    var to_be_merged = specified_vertex !== undefined ? ({
          hd: Caml_option.valFromOption(specified_vertex),
          tl: ends
        }) : ends;
    return merge_vertex(g, to_be_merged);
  };
  var merge_starts = function (strictOpt, specified_vertex, g) {
    var strict = strictOpt !== undefined ? strictOpt : false;
    var accumulator = function (v, accu) {
      var in_d = Curry._2(funarg.G.in_degree, g, v);
      if (in_d === 0 || !strict && in_d === List.length(Curry._3(funarg.G.find_all_edges, g, v, v))) {
        return {
                hd: v,
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var starts = Curry._3(funarg.G.fold_vertex, accumulator, g, /* [] */0);
    var to_be_merged = specified_vertex !== undefined ? ({
          hd: Caml_option.valFromOption(specified_vertex),
          tl: starts
        }) : starts;
    return merge_vertex(g, to_be_merged);
  };
  var merge_scc = function (loop_killerOpt, specified_vertex, g) {
    var loop_killer = loop_killerOpt !== undefined ? loop_killerOpt : false;
    var $$let = funarg.G;
    var C = Components.Make({
          V: $$let.V,
          iter_vertex: $$let.iter_vertex,
          iter_succ: $$let.iter_succ
        });
    var components = Curry._1(C.scc_list, g);
    var alter = function (accu, to_be_identified) {
      var to_be_identified$1 = specified_vertex !== undefined ? ({
            hd: Curry._1(specified_vertex, to_be_identified),
            tl: to_be_identified
          }) : to_be_identified;
      var v = List.hd(to_be_identified$1);
      var accu$1 = merge_vertex(accu, to_be_identified$1);
      if (loop_killer) {
        return Curry._3(funarg.remove_edge, accu$1, v, v);
      } else {
        return accu$1;
      }
    };
    return List.fold_left(alter, g, components);
  };
  return {
          merge_vertex: merge_vertex,
          merge_edges_e: merge_edges_e,
          merge_edges_with_label: merge_edges_with_label,
          merge_isolabelled_edges: merge_isolabelled_edges,
          merge_ends: merge_ends,
          merge_starts: merge_starts,
          merge_scc: merge_scc
        };
}

function P(funarg) {
  var B = Builder.P(funarg);
  var mem = function (x, ec) {
    return List.exists((function (y) {
                  return Curry._2(B.G.V.equal, x, y);
                }), ec);
  };
  var identify = function (x, ec) {
    if (ec && mem(x, ec.tl)) {
      return [
              true,
              ec.hd
            ];
    } else {
      return [
              false,
              x
            ];
    }
  };
  var identify_extremities = function (g, vl) {
    var f = function (e, accu) {
      var match = identify(Curry._1(B.G.E.src, e), vl);
      var match$1 = identify(Curry._1(B.G.E.dst, e), vl);
      if (match[0] || match$1[0]) {
        return {
                hd: Curry._3(B.G.E.create, match[1], Curry._1(B.G.E.label, e), match$1[1]),
                tl: accu
              };
      } else {
        return accu;
      }
    };
    return Curry._3(B.G.fold_edges_e, f, g, /* [] */0);
  };
  var merge_vertex = function (g, vl) {
    if (!vl) {
      return g;
    }
    var to_be_added = identify_extremities(g, vl);
    var g$1 = List.fold_left(B.remove_vertex, g, vl.tl);
    if (to_be_added === /* [] */0) {
      return Curry._2(B.add_vertex, g$1, vl.hd);
    } else {
      return List.fold_left(B.add_edge_e, g$1, to_be_added);
    }
  };
  var merge_edges_e = function (src, dst, g, el) {
    if (!el) {
      return g;
    }
    var e = el.hd;
    var el$p = List.filter(Curry._1(B.G.mem_edge_e, g))(el.tl);
    if (el$p === /* [] */0) {
      return g;
    }
    var el$1 = {
      hd: e,
      tl: el$p
    };
    var extremities = function (e) {
      return [
              Curry._1(B.G.E.src, e),
              Curry._1(B.G.E.dst, e)
            ];
    };
    var match = List.split(List.map(extremities, el$1));
    var destinations = match[1];
    var sources = match[0];
    var remove = function (accu, e) {
      try {
        return Curry._2(B.remove_edge_e, accu, e);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Invalid_argument") {
          return g;
        }
        throw exn;
      }
    };
    var g$1 = List.fold_left(remove, g, el$1);
    if (List.exists((function (v) {
              return mem(v, destinations);
            }), sources)) {
      var v = src !== undefined ? Caml_option.valFromOption(src) : (
          dst !== undefined ? Caml_option.valFromOption(dst) : List.hd(sources)
        );
      var g$2 = merge_vertex(g$1, Pervasives.$at({
                hd: v,
                tl: sources
              }, destinations));
      return Curry._2(B.add_edge_e, g$2, Curry._3(B.G.E.create, v, Curry._1(B.G.E.label, e), v));
    }
    var v$1 = src !== undefined ? Caml_option.valFromOption(src) : List.hd(sources);
    var w = src !== undefined ? Caml_option.valFromOption(src) : List.hd(destinations);
    var g$3 = merge_vertex(g$1, sources);
    var g$4 = merge_vertex(g$3, destinations);
    return Curry._2(B.add_edge_e, g$4, Curry._3(B.G.E.create, v$1, Curry._1(B.G.E.label, e), w));
  };
  var merge_edges_with_label = function (src, dst, label, g, l) {
    var update_label = function (e) {
      if (label !== undefined) {
        return Curry._3(B.G.E.create, Curry._1(B.G.E.src, e), Caml_option.valFromOption(label), Curry._1(B.G.E.dst, e));
      } else {
        return e;
      }
    };
    var collect_edge = function (e, accu) {
      if (Caml_obj.caml_equal(Curry._1(B.G.E.label, e), l)) {
        return {
                hd: update_label(e),
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var edges_to_be_merged = Curry._3(B.G.fold_edges_e, collect_edge, g, /* [] */0);
    return merge_edges_e(src, dst, g, edges_to_be_merged);
  };
  var compare_label = function (g) {
    try {
      var a_vertex_of_g = {
        contents: undefined
      };
      try {
        Curry._2(B.G.iter_vertex, (function (v) {
                a_vertex_of_g.contents = Caml_option.some(v);
                throw {
                      RE_EXN_ID: Pervasives.Exit,
                      Error: new Error()
                    };
              }), g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID !== Pervasives.Exit) {
          throw exn;
        }
        
      }
      var v = a_vertex_of_g.contents;
      var default_vertex;
      if (v !== undefined) {
        default_vertex = Caml_option.valFromOption(v);
      } else {
        throw {
              RE_EXN_ID: Pervasives.Exit,
              Error: new Error()
            };
      }
      return function (l1, l2) {
        var e1 = Curry._3(B.G.E.create, default_vertex, l1, default_vertex);
        var e2 = Curry._3(B.G.E.create, default_vertex, l2, default_vertex);
        return Curry._2(B.G.E.compare, e1, e2);
      };
    }
    catch (raw_exn$1){
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.RE_EXN_ID === Pervasives.Exit) {
        return function (param, param$1) {
          return 0;
        };
      }
      throw exn$1;
    }
  };
  var merge_isolabelled_edges = function (g) {
    var S = $$Set.Make(B.G.V);
    var do_meet = function (s1, s2) {
      return Curry._2(S.exists, (function (x) {
                    return Curry._2(S.mem, x, s2);
                  }), s1);
    };
    var compare = compare_label(g);
    var M = $$Map.Make({
          compare: compare
        });
    var accumulating = function (e, accu) {
      var l = Curry._1(B.G.E.label, e);
      try {
        var match = Curry._2(M.find, l, accu);
        var s = Curry._2(S.add, Curry._1(B.G.E.src, e), match[0]);
        var d = Curry._2(S.add, Curry._1(B.G.E.dst, e), match[1]);
        return Curry._3(M.add, l, [
                    s,
                    d
                  ], accu);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return Curry._3(M.add, l, [
                      Curry._1(S.singleton, Curry._1(B.G.E.src, e)),
                      Curry._1(S.singleton, Curry._1(B.G.E.dst, e))
                    ], accu);
        }
        throw exn;
      }
    };
    var to_be_identified = Curry._3(B.G.fold_edges_e, accumulating, g, M.empty);
    var gathering = function (param, param$1, accu) {
      var d = param$1[1];
      var s = param$1[0];
      var match = List.partition((function (param) {
              return do_meet(s, param);
            }), accu);
      var accu_0 = List.fold_left((function (accu, x) {
              return Curry._2(S.union, accu, x);
            }), s, match[0]);
      var accu_1 = match[1];
      var accu$1 = {
        hd: accu_0,
        tl: accu_1
      };
      var match$1 = List.partition((function (param) {
              return do_meet(d, param);
            }), accu$1);
      return {
              hd: List.fold_left((function (accu, x) {
                      return Curry._2(S.union, accu, x);
                    }), d, match$1[0]),
              tl: match$1[1]
            };
    };
    var to_be_identified$1 = Curry._3(M.fold, gathering, to_be_identified, /* [] */0);
    return List.fold_left((function (accu, s) {
                  return merge_vertex(accu, Curry._1(S.elements, s));
                }), g, to_be_identified$1);
  };
  var merge_ends = function (strictOpt, specified_vertex, g) {
    var strict = strictOpt !== undefined ? strictOpt : false;
    var accumulator = function (v, accu) {
      var out_d = Curry._2(B.G.out_degree, g, v);
      if (out_d === 0 || !strict && out_d === List.length(Curry._3(B.G.find_all_edges, g, v, v))) {
        return {
                hd: v,
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var ends = Curry._3(B.G.fold_vertex, accumulator, g, /* [] */0);
    var to_be_merged = specified_vertex !== undefined ? ({
          hd: Caml_option.valFromOption(specified_vertex),
          tl: ends
        }) : ends;
    return merge_vertex(g, to_be_merged);
  };
  var merge_starts = function (strictOpt, specified_vertex, g) {
    var strict = strictOpt !== undefined ? strictOpt : false;
    var accumulator = function (v, accu) {
      var in_d = Curry._2(B.G.in_degree, g, v);
      if (in_d === 0 || !strict && in_d === List.length(Curry._3(B.G.find_all_edges, g, v, v))) {
        return {
                hd: v,
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var starts = Curry._3(B.G.fold_vertex, accumulator, g, /* [] */0);
    var to_be_merged = specified_vertex !== undefined ? ({
          hd: Caml_option.valFromOption(specified_vertex),
          tl: starts
        }) : starts;
    return merge_vertex(g, to_be_merged);
  };
  var merge_scc = function (loop_killerOpt, specified_vertex, g) {
    var loop_killer = loop_killerOpt !== undefined ? loop_killerOpt : false;
    var $$let = B.G;
    var C = Components.Make({
          V: $$let.V,
          iter_vertex: $$let.iter_vertex,
          iter_succ: $$let.iter_succ
        });
    var components = Curry._1(C.scc_list, g);
    var alter = function (accu, to_be_identified) {
      var to_be_identified$1 = specified_vertex !== undefined ? ({
            hd: Curry._1(specified_vertex, to_be_identified),
            tl: to_be_identified
          }) : to_be_identified;
      var v = List.hd(to_be_identified$1);
      var accu$1 = merge_vertex(accu, to_be_identified$1);
      if (loop_killer) {
        return Curry._3(B.remove_edge, accu$1, v, v);
      } else {
        return accu$1;
      }
    };
    return List.fold_left(alter, g, components);
  };
  return {
          merge_vertex: merge_vertex,
          merge_edges_e: merge_edges_e,
          merge_edges_with_label: merge_edges_with_label,
          merge_isolabelled_edges: merge_isolabelled_edges,
          merge_ends: merge_ends,
          merge_starts: merge_starts,
          merge_scc: merge_scc
        };
}

function I(funarg) {
  var B = Builder.I(funarg);
  var mem = function (x, ec) {
    return List.exists((function (y) {
                  return Curry._2(B.G.V.equal, x, y);
                }), ec);
  };
  var identify = function (x, ec) {
    if (ec && mem(x, ec.tl)) {
      return [
              true,
              ec.hd
            ];
    } else {
      return [
              false,
              x
            ];
    }
  };
  var identify_extremities = function (g, vl) {
    var f = function (e, accu) {
      var match = identify(Curry._1(B.G.E.src, e), vl);
      var match$1 = identify(Curry._1(B.G.E.dst, e), vl);
      if (match[0] || match$1[0]) {
        return {
                hd: Curry._3(B.G.E.create, match[1], Curry._1(B.G.E.label, e), match$1[1]),
                tl: accu
              };
      } else {
        return accu;
      }
    };
    return Curry._3(B.G.fold_edges_e, f, g, /* [] */0);
  };
  var merge_vertex = function (g, vl) {
    if (!vl) {
      return g;
    }
    var to_be_added = identify_extremities(g, vl);
    var g$1 = List.fold_left(B.remove_vertex, g, vl.tl);
    if (to_be_added === /* [] */0) {
      return Curry._2(B.add_vertex, g$1, vl.hd);
    } else {
      return List.fold_left(B.add_edge_e, g$1, to_be_added);
    }
  };
  var merge_edges_e = function (src, dst, g, el) {
    if (!el) {
      return g;
    }
    var e = el.hd;
    var el$p = List.filter(Curry._1(B.G.mem_edge_e, g))(el.tl);
    if (el$p === /* [] */0) {
      return g;
    }
    var el$1 = {
      hd: e,
      tl: el$p
    };
    var extremities = function (e) {
      return [
              Curry._1(B.G.E.src, e),
              Curry._1(B.G.E.dst, e)
            ];
    };
    var match = List.split(List.map(extremities, el$1));
    var destinations = match[1];
    var sources = match[0];
    var remove = function (accu, e) {
      try {
        return Curry._2(B.remove_edge_e, accu, e);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Invalid_argument") {
          return g;
        }
        throw exn;
      }
    };
    var g$1 = List.fold_left(remove, g, el$1);
    if (List.exists((function (v) {
              return mem(v, destinations);
            }), sources)) {
      var v = src !== undefined ? Caml_option.valFromOption(src) : (
          dst !== undefined ? Caml_option.valFromOption(dst) : List.hd(sources)
        );
      var g$2 = merge_vertex(g$1, Pervasives.$at({
                hd: v,
                tl: sources
              }, destinations));
      return Curry._2(B.add_edge_e, g$2, Curry._3(B.G.E.create, v, Curry._1(B.G.E.label, e), v));
    }
    var v$1 = src !== undefined ? Caml_option.valFromOption(src) : List.hd(sources);
    var w = src !== undefined ? Caml_option.valFromOption(src) : List.hd(destinations);
    var g$3 = merge_vertex(g$1, sources);
    var g$4 = merge_vertex(g$3, destinations);
    return Curry._2(B.add_edge_e, g$4, Curry._3(B.G.E.create, v$1, Curry._1(B.G.E.label, e), w));
  };
  var merge_edges_with_label = function (src, dst, label, g, l) {
    var update_label = function (e) {
      if (label !== undefined) {
        return Curry._3(B.G.E.create, Curry._1(B.G.E.src, e), Caml_option.valFromOption(label), Curry._1(B.G.E.dst, e));
      } else {
        return e;
      }
    };
    var collect_edge = function (e, accu) {
      if (Caml_obj.caml_equal(Curry._1(B.G.E.label, e), l)) {
        return {
                hd: update_label(e),
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var edges_to_be_merged = Curry._3(B.G.fold_edges_e, collect_edge, g, /* [] */0);
    return merge_edges_e(src, dst, g, edges_to_be_merged);
  };
  var compare_label = function (g) {
    try {
      var a_vertex_of_g = {
        contents: undefined
      };
      try {
        Curry._2(B.G.iter_vertex, (function (v) {
                a_vertex_of_g.contents = Caml_option.some(v);
                throw {
                      RE_EXN_ID: Pervasives.Exit,
                      Error: new Error()
                    };
              }), g);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID !== Pervasives.Exit) {
          throw exn;
        }
        
      }
      var v = a_vertex_of_g.contents;
      var default_vertex;
      if (v !== undefined) {
        default_vertex = Caml_option.valFromOption(v);
      } else {
        throw {
              RE_EXN_ID: Pervasives.Exit,
              Error: new Error()
            };
      }
      return function (l1, l2) {
        var e1 = Curry._3(B.G.E.create, default_vertex, l1, default_vertex);
        var e2 = Curry._3(B.G.E.create, default_vertex, l2, default_vertex);
        return Curry._2(B.G.E.compare, e1, e2);
      };
    }
    catch (raw_exn$1){
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.RE_EXN_ID === Pervasives.Exit) {
        return function (param, param$1) {
          return 0;
        };
      }
      throw exn$1;
    }
  };
  var merge_isolabelled_edges = function (g) {
    var S = $$Set.Make(B.G.V);
    var do_meet = function (s1, s2) {
      return Curry._2(S.exists, (function (x) {
                    return Curry._2(S.mem, x, s2);
                  }), s1);
    };
    var compare = compare_label(g);
    var M = $$Map.Make({
          compare: compare
        });
    var accumulating = function (e, accu) {
      var l = Curry._1(B.G.E.label, e);
      try {
        var match = Curry._2(M.find, l, accu);
        var s = Curry._2(S.add, Curry._1(B.G.E.src, e), match[0]);
        var d = Curry._2(S.add, Curry._1(B.G.E.dst, e), match[1]);
        return Curry._3(M.add, l, [
                    s,
                    d
                  ], accu);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          return Curry._3(M.add, l, [
                      Curry._1(S.singleton, Curry._1(B.G.E.src, e)),
                      Curry._1(S.singleton, Curry._1(B.G.E.dst, e))
                    ], accu);
        }
        throw exn;
      }
    };
    var to_be_identified = Curry._3(B.G.fold_edges_e, accumulating, g, M.empty);
    var gathering = function (param, param$1, accu) {
      var d = param$1[1];
      var s = param$1[0];
      var match = List.partition((function (param) {
              return do_meet(s, param);
            }), accu);
      var accu_0 = List.fold_left((function (accu, x) {
              return Curry._2(S.union, accu, x);
            }), s, match[0]);
      var accu_1 = match[1];
      var accu$1 = {
        hd: accu_0,
        tl: accu_1
      };
      var match$1 = List.partition((function (param) {
              return do_meet(d, param);
            }), accu$1);
      return {
              hd: List.fold_left((function (accu, x) {
                      return Curry._2(S.union, accu, x);
                    }), d, match$1[0]),
              tl: match$1[1]
            };
    };
    var to_be_identified$1 = Curry._3(M.fold, gathering, to_be_identified, /* [] */0);
    return List.fold_left((function (accu, s) {
                  return merge_vertex(accu, Curry._1(S.elements, s));
                }), g, to_be_identified$1);
  };
  var merge_ends = function (strictOpt, specified_vertex, g) {
    var strict = strictOpt !== undefined ? strictOpt : false;
    var accumulator = function (v, accu) {
      var out_d = Curry._2(B.G.out_degree, g, v);
      if (out_d === 0 || !strict && out_d === List.length(Curry._3(B.G.find_all_edges, g, v, v))) {
        return {
                hd: v,
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var ends = Curry._3(B.G.fold_vertex, accumulator, g, /* [] */0);
    var to_be_merged = specified_vertex !== undefined ? ({
          hd: Caml_option.valFromOption(specified_vertex),
          tl: ends
        }) : ends;
    return merge_vertex(g, to_be_merged);
  };
  var merge_starts = function (strictOpt, specified_vertex, g) {
    var strict = strictOpt !== undefined ? strictOpt : false;
    var accumulator = function (v, accu) {
      var in_d = Curry._2(B.G.in_degree, g, v);
      if (in_d === 0 || !strict && in_d === List.length(Curry._3(B.G.find_all_edges, g, v, v))) {
        return {
                hd: v,
                tl: accu
              };
      } else {
        return accu;
      }
    };
    var starts = Curry._3(B.G.fold_vertex, accumulator, g, /* [] */0);
    var to_be_merged = specified_vertex !== undefined ? ({
          hd: Caml_option.valFromOption(specified_vertex),
          tl: starts
        }) : starts;
    return merge_vertex(g, to_be_merged);
  };
  var merge_scc = function (loop_killerOpt, specified_vertex, g) {
    var loop_killer = loop_killerOpt !== undefined ? loop_killerOpt : false;
    var $$let = B.G;
    var C = Components.Make({
          V: $$let.V,
          iter_vertex: $$let.iter_vertex,
          iter_succ: $$let.iter_succ
        });
    var components = Curry._1(C.scc_list, g);
    var alter = function (accu, to_be_identified) {
      var to_be_identified$1 = specified_vertex !== undefined ? ({
            hd: Curry._1(specified_vertex, to_be_identified),
            tl: to_be_identified
          }) : to_be_identified;
      var v = List.hd(to_be_identified$1);
      var accu$1 = merge_vertex(accu, to_be_identified$1);
      if (loop_killer) {
        return Curry._3(B.remove_edge, accu$1, v, v);
      } else {
        return accu$1;
      }
    };
    return List.fold_left(alter, g, components);
  };
  var merge_vertex$1 = function (g, vl) {
    merge_vertex(g, vl);
    
  };
  var merge_edges_e$1 = function (src, dst, g, el) {
    merge_edges_e(src, dst, g, el);
    
  };
  var merge_edges_with_label$1 = function (src, dst, label, g, l) {
    merge_edges_with_label(src, dst, label, g, l);
    
  };
  var merge_isolabelled_edges$1 = function (g) {
    merge_isolabelled_edges(g);
    
  };
  var merge_ends$1 = function (strict, specified_vertex, g) {
    merge_ends(strict, specified_vertex, g);
    
  };
  var merge_starts$1 = function (strict, specified_vertex, g) {
    merge_starts(strict, specified_vertex, g);
    
  };
  var merge_scc$1 = function (loop_killer, specified_vertex, g) {
    merge_scc(loop_killer, specified_vertex, g);
    
  };
  return {
          merge_vertex: merge_vertex$1,
          merge_edges_e: merge_edges_e$1,
          merge_edges_with_label: merge_edges_with_label$1,
          merge_isolabelled_edges: merge_isolabelled_edges$1,
          merge_ends: merge_ends$1,
          merge_starts: merge_starts$1,
          merge_scc: merge_scc$1
        };
}

export {
  B ,
  P ,
  I ,
  
}
/* No side effect */
