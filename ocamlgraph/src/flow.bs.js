// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Map from "../../node_modules/rescript/lib/es6/map.js";
import * as List from "../../node_modules/rescript/lib/es6/list.js";
import * as Util from "./util.bs.js";
import * as Curry from "../../node_modules/rescript/lib/es6/curry.js";
import * as Queue from "../../node_modules/rescript/lib/es6/queue.js";
import * as Hashtbl from "../../node_modules/rescript/lib/es6/hashtbl.js";
import * as Caml_obj from "../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Caml_int32 from "../../node_modules/rescript/lib/es6/caml_int32.js";
import * as Pervasives from "../../node_modules/rescript/lib/es6/pervasives.js";
import * as Caml_option from "../../node_modules/rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "../../node_modules/rescript/lib/es6/caml_exceptions.js";
import * as PersistentQueue from "./lib/persistentQueue.bs.js";
import * as Caml_js_exceptions from "../../node_modules/rescript/lib/es6/caml_js_exceptions.js";

function Goldberg_Tarjan(funarg, funarg$1) {
  var $$let = funarg.V;
  var VH = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var EM = $$Map.Make(funarg.E);
  var create = VH.create;
  var find = function (tbl, key) {
    try {
      return Caml_option.some(Curry._2(VH.find, tbl, key));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return ;
      }
      throw exn;
    }
  };
  var add = function (tbl, v) {
    if (!Curry._2(VH.mem, tbl, v)) {
      return Curry._3(VH.add, tbl, v, undefined);
    }
    
  };
  var elements = function (tbl) {
    return Curry._3(VH.fold, (function (v, param, list) {
                  return {
                          hd: v,
                          tl: list
                        };
                }), tbl, /* [] */0);
  };
  var add$1 = function (map, edge, value) {
    map.contents = Curry._3(EM.add, edge, value, map.contents);
    
  };
  var find$1 = function (map, edge) {
    try {
      return Caml_option.some(Curry._2(EM.find, edge, map.contents));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return ;
      }
      throw exn;
    }
  };
  var min_flow = function (a, b) {
    if (Curry._2(funarg$1.compare, a, b) < 0) {
      return a;
    } else {
      return b;
    }
  };
  var $plus$neg = funarg$1.add;
  var $neg$neg = funarg$1.sub;
  var is_positive = function (a) {
    return Curry._2(funarg$1.compare, a, funarg$1.zero) > 0;
  };
  var max_capacity = function (e) {
    return Curry._1(funarg$1.max_capacity, Curry._1(funarg.E.label, e));
  };
  var get_excess = function (ctxt, vertex) {
    var value = find(ctxt.excess, vertex);
    if (value !== undefined) {
      return Caml_option.valFromOption(value);
    } else {
      return funarg$1.zero;
    }
  };
  var get_potential = function (ctxt, vertex) {
    var value = find(ctxt.potential, vertex);
    if (value !== undefined) {
      return value;
    } else {
      return (ctxt.nb_vertices << 1);
    }
  };
  var set_excess = function (ctxt, vertex, value) {
    Curry._2(VH.remove, ctxt.excess, vertex);
    return Curry._3(VH.add, ctxt.excess, vertex, value);
  };
  var set_potential = function (ctxt, vertex, pi) {
    Curry._2(VH.remove, ctxt.potential, vertex);
    return Curry._3(VH.add, ctxt.potential, vertex, pi);
  };
  var extract_excessives = function (ctxt) {
    var in_excess = elements(ctxt.excessives);
    ctxt.excessives = Curry._1(VH.create, 16);
    return in_excess;
  };
  var get_flow = function (context, arc) {
    var value = find$1(context.flow, arc);
    if (value !== undefined) {
      return Caml_option.valFromOption(value);
    } else {
      return funarg$1.zero;
    }
  };
  var set_flow = function (context, arc, value) {
    return add$1(context.flow, arc, value);
  };
  var origin = function (arc) {
    if (arc.TAG === /* Forward */0) {
      return Curry._1(funarg.E.src, arc._0);
    } else {
      return Curry._1(funarg.E.dst, arc._0);
    }
  };
  var destination = function (arc) {
    if (arc.TAG === /* Forward */0) {
      return Curry._1(funarg.E.dst, arc._0);
    } else {
      return Curry._1(funarg.E.src, arc._0);
    }
  };
  var forward = function (arc) {
    return {
            TAG: /* Forward */0,
            _0: arc
          };
  };
  var backward = function (arc) {
    return {
            TAG: /* Backward */1,
            _0: arc
          };
  };
  var residual_capacity = function (context, residual_arc) {
    var match = context.reversed;
    if (match) {
      if (residual_arc.TAG === /* Forward */0) {
        return get_flow(context, residual_arc._0);
      }
      
    } else if (residual_arc.TAG !== /* Forward */0) {
      return get_flow(context, residual_arc._0);
    }
    var arc = residual_arc._0;
    return Curry._2(funarg$1.sub, Curry._1(context.max_capacity, arc), get_flow(context, arc));
  };
  var is_forward = function (context, arc) {
    return is_positive(Curry._2($neg$neg, Curry._1(context.max_capacity, arc), get_flow(context, arc)));
  };
  var augment = function (context, residual_arc, delta) {
    var match = context.reversed;
    var exit = 0;
    var arc;
    if (match) {
      if (residual_arc.TAG === /* Forward */0) {
        exit = 1;
      } else {
        arc = residual_arc._0;
        exit = 2;
      }
    } else if (residual_arc.TAG === /* Forward */0) {
      arc = residual_arc._0;
      exit = 2;
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 :
          var arc$1 = residual_arc._0;
          return set_flow(context, arc$1, Curry._2($neg$neg, get_flow(context, arc$1), delta));
      case 2 :
          return set_flow(context, arc, Curry._2($plus$neg, get_flow(context, arc), delta));
      
    }
  };
  var cons = function (e, l) {
    return {
            hd: e,
            tl: l
          };
  };
  var incidence_residual = function (graph, context, vertex) {
    return Pervasives.$at(List.map(forward, List.filter(function (param) {
                          return is_forward(context, param);
                        })(Curry._4(funarg.fold_succ_e, cons, graph, vertex, /* [] */0))), List.map(backward, List.filter(function (param) {
                          return is_positive(get_flow(context, param));
                        })(Curry._4(funarg.fold_pred_e, cons, graph, vertex, /* [] */0))));
  };
  var incidence_reversal = function (graph, context, vertex) {
    return Pervasives.$at(List.map(forward, List.filter(function (param) {
                          return is_positive(get_flow(context, param));
                        })(Curry._4(funarg.fold_succ_e, cons, graph, vertex, /* [] */0))), List.map(backward, List.filter(function (param) {
                          return is_forward(context, param);
                        })(Curry._4(funarg.fold_pred_e, cons, graph, vertex, /* [] */0))));
  };
  var generic_bfs = function (nb_vertices, incidence, iter_fun, source) {
    var reached = Curry._1(create, nb_vertices);
    var frontier = {
      contents: PersistentQueue.empty
    };
    var add_arc = function (arc) {
      var dest = destination(arc);
      if (find(reached, dest) === undefined) {
        Curry._3(VH.add, reached, dest, undefined);
        Curry._1(iter_fun, arc);
        frontier.contents = PersistentQueue.add(frontier.contents, dest);
        return ;
      }
      
    };
    Curry._3(VH.add, reached, source, undefined);
    List.iter(add_arc, Curry._1(incidence, source));
    while(!PersistentQueue.is_empty(frontier.contents)) {
      var vertex = PersistentQueue.head(frontier.contents);
      List.iter(add_arc, Curry._1(incidence, vertex));
      frontier.contents = PersistentQueue.tail(frontier.contents);
    };
    
  };
  var initialize_potential = function (context, sink) {
    var update = function (arc) {
      var partial_arg = destination(arc);
      return set_potential(context, partial_arg, get_potential(context, origin(arc)) + 1 | 0);
    };
    set_potential(context, sink, 0);
    return generic_bfs(context.nb_vertices, Curry._1(context.reverse_incident, context), update, sink);
  };
  var Break = /* @__PURE__ */Caml_exceptions.create("Flow.Goldberg_Tarjan(G)(F).Break");
  var push = function (context, arc) {
    var u = origin(arc);
    var v = destination(arc);
    var exc_u = get_excess(context, u);
    if (!is_positive(exc_u)) {
      return ;
    }
    var delta = min_flow(exc_u, residual_capacity(context, arc));
    set_excess(context, u, Curry._2($neg$neg, exc_u, delta));
    set_excess(context, v, Curry._2($plus$neg, get_excess(context, v), delta));
    augment(context, arc, delta);
    return add(context.excessives, v);
  };
  var relabel = function (context, vertex) {
    var partial_arg = get_potential(context, vertex);
    var param = Curry._2(context.incident, context, vertex);
    var param$1 = List.map((function (arc) {
            return get_potential(context, destination(arc));
          }), param);
    var pi = List.fold_left((function (prim0, prim1) {
            if (prim0 < prim1) {
              return prim0;
            } else {
              return prim1;
            }
          }), partial_arg, param$1);
    return set_potential(context, vertex, pi + 1 | 0);
  };
  var augmenting_step = function (context, currently_in_excess) {
    context.excessives = Curry._1(VH.create, 16);
    var param = List.filter(function (param) {
            if (Caml_obj.caml_notequal(param, context.source) && Caml_obj.caml_notequal(param, context.sink)) {
              return is_positive(get_excess(context, param));
            } else {
              return false;
            }
          })(currently_in_excess);
    var param$1 = List.sort((function (param, param$1) {
            return get_potential(context, param$1) - get_potential(context, param) | 0;
          }), param);
    return List.iter((function (param) {
                  var param$1 = List.filter(function (param) {
                          var u = origin(param);
                          var v = destination(param);
                          return (get_potential(context, v) - get_potential(context, u) | 0) === -1;
                        })(Curry._2(context.incident, context, param));
                  List.iter((function (param) {
                          return push(context, param);
                        }), param$1);
                  if (is_positive(get_excess(context, param))) {
                    relabel(context, param);
                    return add(context.excessives, param);
                  }
                  
                }), param$1);
  };
  var param_freq_check_preflow = {
    contents: 1000
  };
  var compute_max_preflow = function (context) {
    var nb_steps = {
      contents: 0
    };
    var in_excess = {
      contents: extract_excessives(context)
    };
    var check_freq = Caml_int32.div(context.nb_vertices, param_freq_check_preflow.contents) + 1 | 0;
    var is_maximum = function (param) {
      if (in_excess.contents === /* [] */0) {
        return true;
      } else if (Caml_int32.mod_(nb_steps.contents, check_freq) === 0) {
        var check_arc = function (arc) {
          if (Curry._2(funarg$1.compare, get_excess(context, destination(arc)), funarg$1.zero) === 0) {
            return ;
          }
          throw {
                RE_EXN_ID: Break,
                Error: new Error()
              };
        };
        try {
          generic_bfs(context.nb_vertices, Curry._1(context.reverse_incident, context), check_arc, context.sink);
          return true;
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === Break) {
            return false;
          }
          throw exn;
        }
      } else {
        return false;
      }
    };
    while(!is_maximum(undefined)) {
      augmenting_step(context, in_excess.contents);
      in_excess.contents = extract_excessives(context);
      nb_steps.contents = nb_steps.contents + 1 | 0;
    };
    
  };
  var new_context = function (graph, source, sink, reversed, max_capacity, flow) {
    var nb_vertices = Curry._1(funarg.nb_vertex, graph);
    var context = {
      nb_vertices: nb_vertices,
      source: source,
      sink: sink,
      reversed: reversed,
      incident: reversed ? (function (param, param$1) {
            return incidence_reversal(graph, param, param$1);
          }) : (function (param, param$1) {
            return incidence_residual(graph, param, param$1);
          }),
      reverse_incident: reversed ? (function (param, param$1) {
            return incidence_residual(graph, param, param$1);
          }) : (function (param, param$1) {
            return incidence_reversal(graph, param, param$1);
          }),
      max_capacity: max_capacity,
      excess: Curry._1(create, nb_vertices),
      potential: Curry._1(create, nb_vertices),
      excessives: Curry._1(VH.create, 16),
      flow: flow
    };
    var out_source = Curry._2(context.incident, context, context.source);
    initialize_potential(context, context.sink);
    set_potential(context, context.source, context.nb_vertices);
    var partial_arg = context.source;
    var param = List.map((function (param) {
            return Curry._1(context.max_capacity, param._0);
          }), out_source);
    set_excess(context, partial_arg, List.fold_left(funarg$1.add, funarg$1.zero, param));
    List.iter((function (param) {
            return push(context, param);
          }), out_source);
    return context;
  };
  var maxflow = function (graph, source, sink) {
    var init_flow = function (param) {
      Curry._1(funarg.nb_edges, graph);
      var flow = {
        contents: EM.empty
      };
      Curry._3(funarg.fold_edges_e, (function (e, param) {
              return add$1(flow, e, funarg$1.zero);
            }), graph, undefined);
      return flow;
    };
    var forward_context = new_context(graph, source, sink, false, max_capacity, init_flow(undefined));
    compute_max_preflow(forward_context);
    var backward_context = new_context(graph, sink, source, true, (function (param) {
            return get_flow(forward_context, param);
          }), init_flow(undefined));
    compute_max_preflow(backward_context);
    var param = Curry._4(funarg.fold_succ_e, cons, graph, source, /* [] */0);
    var param$1 = List.map((function (param) {
            return get_flow(backward_context, param);
          }), param);
    var max_flow_value = List.fold_left(funarg$1.add, funarg$1.zero, param$1);
    var f = function (e) {
      var x = find$1(backward_context.flow, e);
      if (x !== undefined) {
        return Caml_option.valFromOption(x);
      } else {
        return funarg$1.zero;
      }
    };
    return [
            f,
            max_flow_value
          ];
  };
  return {
          maxflow: maxflow
        };
}

function Ford_Fulkerson(funarg, funarg$1) {
  var max_capacity = funarg$1.max_capacity;
  var flow = funarg$1.flow;
  var add = funarg$1.add;
  var sub = funarg$1.sub;
  var zero = funarg$1.zero;
  var compare = funarg$1.compare;
  var min_capacity = funarg$1.min_capacity;
  var min = function (x, y) {
    if (x && !(y && Curry._2(funarg$1.compare, x._0, y._0) >= 0)) {
      return x;
    } else {
      return y;
    }
  };
  var $$let = funarg.V;
  var H = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var marked = Curry._1(H.create, 97);
  var unvisited = Queue.create(undefined);
  var mem = Curry._1(H.mem, marked);
  var set = function (s, e, tag) {
    if (Curry._1(mem, s)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "flow.ml",
              571,
              6
            ],
            Error: new Error()
          };
    }
    Curry._3(H.add, marked, s, [
          e,
          tag
        ]);
    return Queue.add(s, unvisited);
  };
  var get = function (s) {
    var match = Curry._2(H.find, marked, s);
    var e = match[0];
    var tmp;
    if (e !== undefined) {
      tmp = Caml_option.valFromOption(e);
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "flow.ml",
              577,
              28
            ],
            Error: new Error()
          };
    }
    return [
            tmp,
            match[1]
          ];
  };
  var U = Util.HTProduct(funarg.V, funarg.V);
  var equal = function (e1, e2) {
    return Curry._2(U.equal, [
                Curry._1(funarg.E.src, e1),
                Curry._1(funarg.E.dst, e1)
              ], [
                Curry._1(funarg.E.src, e2),
                Curry._1(funarg.E.dst, e2)
              ]);
  };
  var hash = function (e) {
    return Curry._1(U.hash, [
                Curry._1(funarg.E.src, e),
                Curry._1(funarg.E.dst, e)
              ]);
  };
  var H$1 = Hashtbl.Make({
        equal: equal,
        hash: hash
      });
  var find = H$1.find;
  var flow$1 = function (r, e) {
    try {
      return Curry._2(find, r, e);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        var f = Curry._1(flow, Curry._1(funarg.E.label, e));
        Curry._3(H$1.add, r, e, f);
        return f;
      }
      throw exn;
    }
  };
  var change = function (op, r, e, f) {
    try {
      return Curry._3(H$1.replace, r, e, Curry._2(op, Curry._2(find, r, e), f));
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "flow.ml",
                609,
                8
              ],
              Error: new Error()
            };
      }
      throw exn;
    }
  };
  var grow = function (param, param$1, param$2) {
    return change(add, param, param$1, param$2);
  };
  var reduce = function (param, param$1, param$2) {
    return change(sub, param, param$1, param$2);
  };
  var is_full = function (r, e) {
    return Curry._2(compare, Curry._1(max_capacity, Curry._1(funarg.E.label, e)), flow$1(r, e)) === 0;
  };
  var is_empty = function (r, e) {
    return Curry._2(compare, Curry._1(min_capacity, Curry._1(funarg.E.label, e)), flow$1(r, e)) === 0;
  };
  var set_flow = function (r, s, t, a) {
    var _t = t;
    while(true) {
      var t$1 = _t;
      if (Curry._2(funarg.V.equal, s, t$1)) {
        return ;
      }
      var match = get(t$1);
      var e = match[0];
      if (match[1]) {
        reduce(r, e, a);
        _t = Curry._1(funarg.E.dst, e);
        continue ;
      }
      grow(r, e, a);
      _t = Curry._1(funarg.E.src, e);
      continue ;
    };
  };
  var maxflow = function (g, s, t) {
    var r = Curry._1(H$1.create, 97);
    var succ = function (s) {
      return Curry._3(funarg.iter_succ_e, (function (e) {
                    if (!Curry._2(funarg.V.equal, s, Curry._1(funarg.E.src, e))) {
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "flow.ml",
                              661,
                              11
                            ],
                            Error: new Error()
                          };
                    }
                    var t = Curry._1(funarg.E.dst, e);
                    if (!(Curry._1(mem, t) || is_full(r, e))) {
                      return set(t, Caml_option.some(e), /* Plus */0);
                    }
                    
                  }), g, s);
    };
    var pred = function (s) {
      return Curry._3(funarg.iter_pred_e, (function (e) {
                    if (!Curry._2(funarg.V.equal, s, Curry._1(funarg.E.dst, e))) {
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "flow.ml",
                              670,
                              11
                            ],
                            Error: new Error()
                          };
                    }
                    var t = Curry._1(funarg.E.src, e);
                    if (!(Curry._1(mem, t) || is_empty(r, e))) {
                      return set(t, Caml_option.some(e), /* Minus */1);
                    }
                    
                  }), g, s);
    };
    var internal_loop = function (a) {
      try {
        while(true) {
          var s$1 = Queue.pop(unvisited);
          succ(s$1);
          pred(s$1);
        };
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "flow.ml",
                679,
                8
              ],
              Error: new Error()
            };
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === Queue.Empty) {
          if (Curry._1(mem, t)) {
            var _u = t;
            var _b = /* Infinity */0;
            while(true) {
              var b = _b;
              var u = _u;
              if (Curry._2(funarg.V.equal, s, u)) {
                if (b) {
                  var f = b._0;
                  set_flow(r, s, t, f);
                  return Curry._2(add, a, f);
                }
                if (!Curry._2(funarg.V.equal, s, t)) {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "flow.ml",
                          636,
                          10
                        ],
                        Error: new Error()
                      };
                }
                return a;
              }
              var match = get(u);
              var e = match[0];
              var l = Curry._1(funarg.E.label, e);
              if (match[1]) {
                _b = min(b, /* Flow */{
                      _0: Curry._2(sub, flow$1(r, e), Curry._1(min_capacity, l))
                    });
                _u = Curry._1(funarg.E.dst, e);
                continue ;
              }
              _b = min(b, /* Flow */{
                    _0: Curry._2(sub, Curry._1(max_capacity, l), flow$1(r, e))
                  });
              _u = Curry._1(funarg.E.src, e);
              continue ;
            };
          } else {
            return a;
          }
        }
        throw exn;
      }
    };
    var external_loop = function (_a) {
      while(true) {
        var a = _a;
        Curry._1(H.clear, marked);
        set(s, undefined, /* Plus */0);
        var a$p = internal_loop(a);
        if (Caml_obj.caml_equal(a, a$p)) {
          return a;
        }
        _a = a$p;
        continue ;
      };
    };
    var a = external_loop(zero);
    return [
            (function (e) {
                try {
                  return Curry._2(find, r, e);
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === "Not_found") {
                    return Curry._1(flow, Curry._1(funarg.E.label, e));
                  }
                  throw exn;
                }
              }),
            a
          ];
  };
  return {
          maxflow: maxflow
        };
}

export {
  Goldberg_Tarjan ,
  Ford_Fulkerson ,
  
}
/* No side effect */
