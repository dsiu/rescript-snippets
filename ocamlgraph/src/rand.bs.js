// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "../../node_modules/rescript/lib/es6/caml.js";
import * as $$Array from "../../node_modules/rescript/lib/es6/array.js";
import * as Curry from "../../node_modules/rescript/lib/es6/curry.js";
import * as Int64 from "../../node_modules/rescript/lib/es6/int64.js";
import * as Random from "../../node_modules/rescript/lib/es6/random.js";
import * as Builder from "./builder.bs.js";
import * as Delaunay from "./delaunay.bs.js";
import * as Caml_array from "../../node_modules/rescript/lib/es6/caml_array.js";
import * as Caml_int64 from "../../node_modules/rescript/lib/es6/caml_int64.js";
import * as Pervasives from "../../node_modules/rescript/lib/es6/pervasives.js";

function Make(funarg) {
  var max_edges = function (loops, v, e) {
    if (v <= 0 || e < 0) {
      Pervasives.invalid_arg("random");
    }
    var v64 = Caml_int64.of_int32(v);
    var max_e = Caml_int64.mul(v64, Int64.pred(v64));
    var max_e$1 = funarg.G.is_directed ? max_e : Caml_int64.div(max_e, [
            0,
            2
          ]);
    var max_e$2 = loops ? Caml_int64.add(max_e$1, v64) : max_e$1;
    if (Caml.i64_gt(Caml_int64.of_int32(e), max_e$2)) {
      Pervasives.invalid_arg("random: too many edges");
    }
    return max_e$2;
  };
  var fold_for = function (i0, i1, f) {
    return function (param) {
      var _i = i0;
      var _v = param;
      while(true) {
        var v = _v;
        var i = _i;
        if (i > i1) {
          return v;
        }
        _v = Curry._2(f, v, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
  };
  var random_few_edges = function (add_edge, loops, v, e) {
    max_edges(loops, v, e);
    var a = $$Array.init(v, funarg.G.V.create);
    var g = $$Array.fold_left(funarg.add_vertex, Curry._1(funarg.empty, undefined), a);
    return fold_for(1, e, (function (g, param) {
                    while(true) {
                      var i = Random.$$int(v);
                      var j = Random.$$int(v);
                      if (!(i === j && !loops || Curry._3(funarg.G.mem_edge, g, Caml_array.get(a, i), Caml_array.get(a, j)))) {
                        return Curry._3(add_edge, g, Caml_array.get(a, i), Caml_array.get(a, j));
                      }
                      continue ;
                    };
                  }))(g);
  };
  var random_many_edges = function (add_edge, loops, v, e) {
    var v64 = Caml_int64.of_int32(v);
    var max_e = max_edges(loops, v, e);
    var a = $$Array.init(v, funarg.G.V.create);
    var g = $$Array.fold_left(funarg.add_vertex, Curry._1(funarg.empty, undefined), a);
    var add_edges = function (i, j, max, nb, g) {
      var tmp = false;
      if (Caml.i64_ge(max, Caml_int64.zero)) {
        var match = funarg.G.is_directed;
        tmp = Caml.i64_eq(max_e, Caml_int64.add(max, Caml_int64.add(Caml_int64.mul(Caml_int64.of_int32(i), v64), Caml_int64.of_int32(j - (
                          match ? (
                              loops ? 0 : (
                                  j > i ? i + 1 | 0 : i
                                )
                            ) : (
                              loops ? (Math.imul(i, i - 1 | 0) / 2 | 0) + (
                                  j > i ? i : j
                                ) | 0 : (Math.imul(i, i + 1 | 0) / 2 | 0) + (
                                  j > i ? i + 1 | 0 : j
                                ) | 0
                            )
                        ) | 0))));
      }
      if (!tmp) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "rand.ml",
                81,
                6
              ],
              Error: new Error()
            };
      }
      if (nb === 0) {
        return g;
      }
      var match$1 = j === (v - 1 | 0) ? [
          i + 1 | 0,
          0
        ] : [
          i,
          j + 1 | 0
        ];
      var j$1 = match$1[1];
      var i$1 = match$1[0];
      var add_edges$1 = function (param, param$1, param$2) {
        return add_edges(i$1, j$1, param, param$1, param$2);
      };
      if (i === j && !loops || !funarg.G.is_directed && i > j) {
        return add_edges$1(max, nb, g);
      }
      var partial_arg = Int64.pred(max);
      var add_edges$2 = function (param, param$1) {
        return add_edges$1(partial_arg, param, param$1);
      };
      if (Caml.i64_lt(Random.int64(max), Caml_int64.of_int32(nb))) {
        return Curry._2(add_edges$2, nb - 1 | 0, Curry._3(add_edge, g, Caml_array.get(a, i), Caml_array.get(a, j)));
      } else {
        return Curry._2(add_edges$2, nb, g);
      }
    };
    return add_edges(0, 0, max_e, e, g);
  };
  var random = function (loops, v, e) {
    var r = e / (v * v);
    var func = r < 0.4 ? random_few_edges : random_many_edges;
    return function (param) {
      return Curry._4(func, param, loops, v, e);
    };
  };
  var graph = function (loopsOpt, v, e, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return random(loops, v, e)(funarg.add_edge);
  };
  var labeled = function (f, loopsOpt, v, e, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return random(loops, v, e)(function (g, v1, v2) {
                return Curry._2(funarg.add_edge_e, g, Curry._3(funarg.G.E.create, v1, Curry._2(f, v1, v2), v2));
              });
  };
  var random_few_edges$1 = function (param, param$1, param$2) {
    return random_few_edges(funarg.add_edge, param, param$1, param$2);
  };
  var random_many_edges$1 = function (param, param$1, param$2) {
    return random_many_edges(funarg.add_edge, param, param$1, param$2);
  };
  var gnp_generic = function (add_edge, loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    if (!(0.0 <= prob && prob <= 1.0)) {
      Pervasives.invalid_arg("gnp");
    }
    var vertices = $$Array.init(v, (function (i) {
            return Curry._1(funarg.G.V.create, i);
          }));
    var g = $$Array.fold_left(funarg.add_vertex, Curry._1(funarg.empty, undefined), vertices);
    var g$1 = g;
    for(var i = 0; i < v; ++i){
      for(var j = 0 ,j_finish = funarg.G.is_directed ? v - 1 | 0 : i; j <= j_finish; ++j){
        if ((loops || j !== i) && (prob === 1.0 || Random.$$float(1.0) < prob)) {
          g$1 = Curry._3(add_edge, g$1, Caml_array.get(vertices, i), Caml_array.get(vertices, j));
        }
        
      }
    }
    return g$1;
  };
  var gnp = function (loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return gnp_generic(funarg.add_edge, loops, v, prob, undefined);
  };
  var gnp_labeled = function (f, loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return gnp_generic((function (g, v1, v2) {
                  return Curry._2(funarg.add_edge_e, g, Curry._3(funarg.G.E.create, v1, Curry._2(f, v1, v2), v2));
                }), loops, v, prob, undefined);
  };
  return {
          graph: graph,
          labeled: labeled,
          random_few_edges: random_few_edges$1,
          random_many_edges: random_many_edges$1,
          gnp: gnp,
          gnp_labeled: gnp_labeled
        };
}

function P(funarg) {
  var B = Builder.P(funarg);
  var max_edges = function (loops, v, e) {
    if (v <= 0 || e < 0) {
      Pervasives.invalid_arg("random");
    }
    var v64 = Caml_int64.of_int32(v);
    var max_e = Caml_int64.mul(v64, Int64.pred(v64));
    var max_e$1 = B.G.is_directed ? max_e : Caml_int64.div(max_e, [
            0,
            2
          ]);
    var max_e$2 = loops ? Caml_int64.add(max_e$1, v64) : max_e$1;
    if (Caml.i64_gt(Caml_int64.of_int32(e), max_e$2)) {
      Pervasives.invalid_arg("random: too many edges");
    }
    return max_e$2;
  };
  var fold_for = function (i0, i1, f) {
    return function (param) {
      var _i = i0;
      var _v = param;
      while(true) {
        var v = _v;
        var i = _i;
        if (i > i1) {
          return v;
        }
        _v = Curry._2(f, v, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
  };
  var random_few_edges = function (add_edge, loops, v, e) {
    max_edges(loops, v, e);
    var a = $$Array.init(v, B.G.V.create);
    var g = $$Array.fold_left(B.add_vertex, Curry._1(B.empty, undefined), a);
    return fold_for(1, e, (function (g, param) {
                    while(true) {
                      var i = Random.$$int(v);
                      var j = Random.$$int(v);
                      if (!(i === j && !loops || Curry._3(B.G.mem_edge, g, Caml_array.get(a, i), Caml_array.get(a, j)))) {
                        return Curry._3(add_edge, g, Caml_array.get(a, i), Caml_array.get(a, j));
                      }
                      continue ;
                    };
                  }))(g);
  };
  var random_many_edges = function (add_edge, loops, v, e) {
    var v64 = Caml_int64.of_int32(v);
    var max_e = max_edges(loops, v, e);
    var a = $$Array.init(v, B.G.V.create);
    var g = $$Array.fold_left(B.add_vertex, Curry._1(B.empty, undefined), a);
    var add_edges = function (i, j, max, nb, g) {
      var tmp = false;
      if (Caml.i64_ge(max, Caml_int64.zero)) {
        var match = B.G.is_directed;
        tmp = Caml.i64_eq(max_e, Caml_int64.add(max, Caml_int64.add(Caml_int64.mul(Caml_int64.of_int32(i), v64), Caml_int64.of_int32(j - (
                          match ? (
                              loops ? 0 : (
                                  j > i ? i + 1 | 0 : i
                                )
                            ) : (
                              loops ? (Math.imul(i, i - 1 | 0) / 2 | 0) + (
                                  j > i ? i : j
                                ) | 0 : (Math.imul(i, i + 1 | 0) / 2 | 0) + (
                                  j > i ? i + 1 | 0 : j
                                ) | 0
                            )
                        ) | 0))));
      }
      if (!tmp) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "rand.ml",
                81,
                6
              ],
              Error: new Error()
            };
      }
      if (nb === 0) {
        return g;
      }
      var match$1 = j === (v - 1 | 0) ? [
          i + 1 | 0,
          0
        ] : [
          i,
          j + 1 | 0
        ];
      var j$1 = match$1[1];
      var i$1 = match$1[0];
      var add_edges$1 = function (param, param$1, param$2) {
        return add_edges(i$1, j$1, param, param$1, param$2);
      };
      if (i === j && !loops || !B.G.is_directed && i > j) {
        return add_edges$1(max, nb, g);
      }
      var partial_arg = Int64.pred(max);
      var add_edges$2 = function (param, param$1) {
        return add_edges$1(partial_arg, param, param$1);
      };
      if (Caml.i64_lt(Random.int64(max), Caml_int64.of_int32(nb))) {
        return Curry._2(add_edges$2, nb - 1 | 0, Curry._3(add_edge, g, Caml_array.get(a, i), Caml_array.get(a, j)));
      } else {
        return Curry._2(add_edges$2, nb, g);
      }
    };
    return add_edges(0, 0, max_e, e, g);
  };
  var random = function (loops, v, e) {
    var r = e / (v * v);
    var func = r < 0.4 ? random_few_edges : random_many_edges;
    return function (param) {
      return Curry._4(func, param, loops, v, e);
    };
  };
  var graph = function (loopsOpt, v, e, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return random(loops, v, e)(B.add_edge);
  };
  var labeled = function (f, loopsOpt, v, e, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return random(loops, v, e)(function (g, v1, v2) {
                return Curry._2(B.add_edge_e, g, Curry._3(B.G.E.create, v1, Curry._2(f, v1, v2), v2));
              });
  };
  var random_few_edges$1 = function (param, param$1, param$2) {
    return random_few_edges(B.add_edge, param, param$1, param$2);
  };
  var random_many_edges$1 = function (param, param$1, param$2) {
    return random_many_edges(B.add_edge, param, param$1, param$2);
  };
  var gnp_generic = function (add_edge, loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    if (!(0.0 <= prob && prob <= 1.0)) {
      Pervasives.invalid_arg("gnp");
    }
    var vertices = $$Array.init(v, (function (i) {
            return Curry._1(B.G.V.create, i);
          }));
    var g = $$Array.fold_left(B.add_vertex, Curry._1(B.empty, undefined), vertices);
    var g$1 = g;
    for(var i = 0; i < v; ++i){
      for(var j = 0 ,j_finish = B.G.is_directed ? v - 1 | 0 : i; j <= j_finish; ++j){
        if ((loops || j !== i) && (prob === 1.0 || Random.$$float(1.0) < prob)) {
          g$1 = Curry._3(add_edge, g$1, Caml_array.get(vertices, i), Caml_array.get(vertices, j));
        }
        
      }
    }
    return g$1;
  };
  var gnp = function (loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return gnp_generic(B.add_edge, loops, v, prob, undefined);
  };
  var gnp_labeled = function (f, loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return gnp_generic((function (g, v1, v2) {
                  return Curry._2(B.add_edge_e, g, Curry._3(B.G.E.create, v1, Curry._2(f, v1, v2), v2));
                }), loops, v, prob, undefined);
  };
  return {
          graph: graph,
          labeled: labeled,
          random_few_edges: random_few_edges$1,
          random_many_edges: random_many_edges$1,
          gnp: gnp,
          gnp_labeled: gnp_labeled
        };
}

function I(funarg) {
  var B = Builder.I(funarg);
  var max_edges = function (loops, v, e) {
    if (v <= 0 || e < 0) {
      Pervasives.invalid_arg("random");
    }
    var v64 = Caml_int64.of_int32(v);
    var max_e = Caml_int64.mul(v64, Int64.pred(v64));
    var max_e$1 = B.G.is_directed ? max_e : Caml_int64.div(max_e, [
            0,
            2
          ]);
    var max_e$2 = loops ? Caml_int64.add(max_e$1, v64) : max_e$1;
    if (Caml.i64_gt(Caml_int64.of_int32(e), max_e$2)) {
      Pervasives.invalid_arg("random: too many edges");
    }
    return max_e$2;
  };
  var fold_for = function (i0, i1, f) {
    return function (param) {
      var _i = i0;
      var _v = param;
      while(true) {
        var v = _v;
        var i = _i;
        if (i > i1) {
          return v;
        }
        _v = Curry._2(f, v, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
  };
  var random_few_edges = function (add_edge, loops, v, e) {
    max_edges(loops, v, e);
    var a = $$Array.init(v, B.G.V.create);
    var g = $$Array.fold_left(B.add_vertex, Curry._1(B.empty, undefined), a);
    return fold_for(1, e, (function (g, param) {
                    while(true) {
                      var i = Random.$$int(v);
                      var j = Random.$$int(v);
                      if (!(i === j && !loops || Curry._3(B.G.mem_edge, g, Caml_array.get(a, i), Caml_array.get(a, j)))) {
                        return Curry._3(add_edge, g, Caml_array.get(a, i), Caml_array.get(a, j));
                      }
                      continue ;
                    };
                  }))(g);
  };
  var random_many_edges = function (add_edge, loops, v, e) {
    var v64 = Caml_int64.of_int32(v);
    var max_e = max_edges(loops, v, e);
    var a = $$Array.init(v, B.G.V.create);
    var g = $$Array.fold_left(B.add_vertex, Curry._1(B.empty, undefined), a);
    var add_edges = function (i, j, max, nb, g) {
      var tmp = false;
      if (Caml.i64_ge(max, Caml_int64.zero)) {
        var match = B.G.is_directed;
        tmp = Caml.i64_eq(max_e, Caml_int64.add(max, Caml_int64.add(Caml_int64.mul(Caml_int64.of_int32(i), v64), Caml_int64.of_int32(j - (
                          match ? (
                              loops ? 0 : (
                                  j > i ? i + 1 | 0 : i
                                )
                            ) : (
                              loops ? (Math.imul(i, i - 1 | 0) / 2 | 0) + (
                                  j > i ? i : j
                                ) | 0 : (Math.imul(i, i + 1 | 0) / 2 | 0) + (
                                  j > i ? i + 1 | 0 : j
                                ) | 0
                            )
                        ) | 0))));
      }
      if (!tmp) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "rand.ml",
                81,
                6
              ],
              Error: new Error()
            };
      }
      if (nb === 0) {
        return g;
      }
      var match$1 = j === (v - 1 | 0) ? [
          i + 1 | 0,
          0
        ] : [
          i,
          j + 1 | 0
        ];
      var j$1 = match$1[1];
      var i$1 = match$1[0];
      var add_edges$1 = function (param, param$1, param$2) {
        return add_edges(i$1, j$1, param, param$1, param$2);
      };
      if (i === j && !loops || !B.G.is_directed && i > j) {
        return add_edges$1(max, nb, g);
      }
      var partial_arg = Int64.pred(max);
      var add_edges$2 = function (param, param$1) {
        return add_edges$1(partial_arg, param, param$1);
      };
      if (Caml.i64_lt(Random.int64(max), Caml_int64.of_int32(nb))) {
        return Curry._2(add_edges$2, nb - 1 | 0, Curry._3(add_edge, g, Caml_array.get(a, i), Caml_array.get(a, j)));
      } else {
        return Curry._2(add_edges$2, nb, g);
      }
    };
    return add_edges(0, 0, max_e, e, g);
  };
  var random = function (loops, v, e) {
    var r = e / (v * v);
    var func = r < 0.4 ? random_few_edges : random_many_edges;
    return function (param) {
      return Curry._4(func, param, loops, v, e);
    };
  };
  var graph = function (loopsOpt, v, e, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return random(loops, v, e)(B.add_edge);
  };
  var labeled = function (f, loopsOpt, v, e, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return random(loops, v, e)(function (g, v1, v2) {
                return Curry._2(B.add_edge_e, g, Curry._3(B.G.E.create, v1, Curry._2(f, v1, v2), v2));
              });
  };
  var random_few_edges$1 = function (param, param$1, param$2) {
    return random_few_edges(B.add_edge, param, param$1, param$2);
  };
  var random_many_edges$1 = function (param, param$1, param$2) {
    return random_many_edges(B.add_edge, param, param$1, param$2);
  };
  var gnp_generic = function (add_edge, loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    if (!(0.0 <= prob && prob <= 1.0)) {
      Pervasives.invalid_arg("gnp");
    }
    var vertices = $$Array.init(v, (function (i) {
            return Curry._1(B.G.V.create, i);
          }));
    var g = $$Array.fold_left(B.add_vertex, Curry._1(B.empty, undefined), vertices);
    var g$1 = g;
    for(var i = 0; i < v; ++i){
      for(var j = 0 ,j_finish = B.G.is_directed ? v - 1 | 0 : i; j <= j_finish; ++j){
        if ((loops || j !== i) && (prob === 1.0 || Random.$$float(1.0) < prob)) {
          g$1 = Curry._3(add_edge, g$1, Caml_array.get(vertices, i), Caml_array.get(vertices, j));
        }
        
      }
    }
    return g$1;
  };
  var gnp = function (loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return gnp_generic(B.add_edge, loops, v, prob, undefined);
  };
  var gnp_labeled = function (f, loopsOpt, v, prob, param) {
    var loops = loopsOpt !== undefined ? loopsOpt : false;
    return gnp_generic((function (g, v1, v2) {
                  return Curry._2(B.add_edge_e, g, Curry._3(B.G.E.create, v1, Curry._2(f, v1, v2), v2));
                }), loops, v, prob, undefined);
  };
  return {
          graph: graph,
          labeled: labeled,
          random_few_edges: random_few_edges$1,
          random_many_edges: random_many_edges$1,
          gnp: gnp,
          gnp_labeled: gnp_labeled
        };
}

function Planar_Make(funarg) {
  var ccw = function (v1, v2, v3) {
    return Delaunay.IntPoints.ccw(Curry._1(funarg.G.V.label, v1), Curry._1(funarg.G.V.label, v2), Curry._1(funarg.G.V.label, v3));
  };
  var in_circle = function (v1, v2, v3, v4) {
    return Delaunay.IntPoints.in_circle(Curry._1(funarg.G.V.label, v1), Curry._1(funarg.G.V.label, v2), Curry._1(funarg.G.V.label, v3), Curry._1(funarg.G.V.label, v4));
  };
  var distance = function (v1, v2) {
    var match = Curry._1(funarg.G.V.label, v1);
    var match$1 = Curry._1(funarg.G.V.label, v2);
    var sqr = function (x) {
      var x$1 = x;
      return x$1 * x$1;
    };
    return Math.sqrt(sqr(match[0] - match$1[0] | 0) + sqr(match[1] - match$1[1] | 0)) | 0;
  };
  var Point = {
    ccw: ccw,
    in_circle: in_circle,
    distance: distance
  };
  var Triangulation = Delaunay.Make(Point);
  var graph = function ($staropt$star, param, param$1, prob, v) {
    var ymax = param$1[1];
    var ymin = param$1[0];
    var xmax = param[1];
    var xmin = param[0];
    var loops = $staropt$star !== undefined ? $staropt$star : false;
    if (!(0.0 <= prob && prob <= 1.0)) {
      Pervasives.invalid_arg("Planar.graph");
    }
    if (v < 2) {
      Pervasives.invalid_arg("Planar.graph");
    }
    var random_point = function (param) {
      return [
              xmin + Random.$$int((1 + xmax | 0) - xmin | 0) | 0,
              ymin + Random.$$int((1 + ymax | 0) - ymin | 0) | 0
            ];
    };
    var vertices = $$Array.init(v, (function (param) {
            return Curry._1(funarg.G.V.create, random_point(undefined));
          }));
    var t = Curry._1(Triangulation.triangulate, vertices);
    var g = $$Array.fold_left(funarg.add_vertex, Curry._1(funarg.empty, undefined), vertices);
    var g$1 = loops ? $$Array.fold_left((function (g, v) {
              if (Random.$$float(1.0) < prob) {
                return g;
              }
              var e = Curry._3(funarg.G.E.create, v, 0, v);
              return Curry._2(funarg.add_edge_e, g, e);
            }), g, vertices) : g;
    var add_edge = function (v1, v2, g) {
      if (Random.$$float(1.0) < prob) {
        return g;
      }
      var e = Curry._3(funarg.G.E.create, v1, distance(v1, v2), v2);
      return Curry._2(funarg.add_edge_e, g, e);
    };
    return Curry._3(Triangulation.fold, (function (v1, v2, g) {
                  var g$1 = add_edge(v1, v2, g);
                  if (funarg.G.is_directed) {
                    return add_edge(v2, v1, g$1);
                  } else {
                    return g$1;
                  }
                }), t, g$1);
  };
  return {
          graph: graph
        };
}

function Planar_P(funarg) {
  var B = Builder.P(funarg);
  var ccw = function (v1, v2, v3) {
    return Delaunay.IntPoints.ccw(Curry._1(B.G.V.label, v1), Curry._1(B.G.V.label, v2), Curry._1(B.G.V.label, v3));
  };
  var in_circle = function (v1, v2, v3, v4) {
    return Delaunay.IntPoints.in_circle(Curry._1(B.G.V.label, v1), Curry._1(B.G.V.label, v2), Curry._1(B.G.V.label, v3), Curry._1(B.G.V.label, v4));
  };
  var distance = function (v1, v2) {
    var match = Curry._1(B.G.V.label, v1);
    var match$1 = Curry._1(B.G.V.label, v2);
    var sqr = function (x) {
      var x$1 = x;
      return x$1 * x$1;
    };
    return Math.sqrt(sqr(match[0] - match$1[0] | 0) + sqr(match[1] - match$1[1] | 0)) | 0;
  };
  var Point = {
    ccw: ccw,
    in_circle: in_circle,
    distance: distance
  };
  var Triangulation = Delaunay.Make(Point);
  var graph = function ($staropt$star, param, param$1, prob, v) {
    var ymax = param$1[1];
    var ymin = param$1[0];
    var xmax = param[1];
    var xmin = param[0];
    var loops = $staropt$star !== undefined ? $staropt$star : false;
    if (!(0.0 <= prob && prob <= 1.0)) {
      Pervasives.invalid_arg("Planar.graph");
    }
    if (v < 2) {
      Pervasives.invalid_arg("Planar.graph");
    }
    var random_point = function (param) {
      return [
              xmin + Random.$$int((1 + xmax | 0) - xmin | 0) | 0,
              ymin + Random.$$int((1 + ymax | 0) - ymin | 0) | 0
            ];
    };
    var vertices = $$Array.init(v, (function (param) {
            return Curry._1(B.G.V.create, random_point(undefined));
          }));
    var t = Curry._1(Triangulation.triangulate, vertices);
    var g = $$Array.fold_left(B.add_vertex, Curry._1(B.empty, undefined), vertices);
    var g$1 = loops ? $$Array.fold_left((function (g, v) {
              if (Random.$$float(1.0) < prob) {
                return g;
              }
              var e = Curry._3(B.G.E.create, v, 0, v);
              return Curry._2(B.add_edge_e, g, e);
            }), g, vertices) : g;
    var add_edge = function (v1, v2, g) {
      if (Random.$$float(1.0) < prob) {
        return g;
      }
      var e = Curry._3(B.G.E.create, v1, distance(v1, v2), v2);
      return Curry._2(B.add_edge_e, g, e);
    };
    return Curry._3(Triangulation.fold, (function (v1, v2, g) {
                  var g$1 = add_edge(v1, v2, g);
                  if (B.G.is_directed) {
                    return add_edge(v2, v1, g$1);
                  } else {
                    return g$1;
                  }
                }), t, g$1);
  };
  return {
          graph: graph
        };
}

function Planar_I(funarg) {
  var B = Builder.I(funarg);
  var ccw = function (v1, v2, v3) {
    return Delaunay.IntPoints.ccw(Curry._1(B.G.V.label, v1), Curry._1(B.G.V.label, v2), Curry._1(B.G.V.label, v3));
  };
  var in_circle = function (v1, v2, v3, v4) {
    return Delaunay.IntPoints.in_circle(Curry._1(B.G.V.label, v1), Curry._1(B.G.V.label, v2), Curry._1(B.G.V.label, v3), Curry._1(B.G.V.label, v4));
  };
  var distance = function (v1, v2) {
    var match = Curry._1(B.G.V.label, v1);
    var match$1 = Curry._1(B.G.V.label, v2);
    var sqr = function (x) {
      var x$1 = x;
      return x$1 * x$1;
    };
    return Math.sqrt(sqr(match[0] - match$1[0] | 0) + sqr(match[1] - match$1[1] | 0)) | 0;
  };
  var Point = {
    ccw: ccw,
    in_circle: in_circle,
    distance: distance
  };
  var Triangulation = Delaunay.Make(Point);
  var graph = function ($staropt$star, param, param$1, prob, v) {
    var ymax = param$1[1];
    var ymin = param$1[0];
    var xmax = param[1];
    var xmin = param[0];
    var loops = $staropt$star !== undefined ? $staropt$star : false;
    if (!(0.0 <= prob && prob <= 1.0)) {
      Pervasives.invalid_arg("Planar.graph");
    }
    if (v < 2) {
      Pervasives.invalid_arg("Planar.graph");
    }
    var random_point = function (param) {
      return [
              xmin + Random.$$int((1 + xmax | 0) - xmin | 0) | 0,
              ymin + Random.$$int((1 + ymax | 0) - ymin | 0) | 0
            ];
    };
    var vertices = $$Array.init(v, (function (param) {
            return Curry._1(B.G.V.create, random_point(undefined));
          }));
    var t = Curry._1(Triangulation.triangulate, vertices);
    var g = $$Array.fold_left(B.add_vertex, Curry._1(B.empty, undefined), vertices);
    var g$1 = loops ? $$Array.fold_left((function (g, v) {
              if (Random.$$float(1.0) < prob) {
                return g;
              }
              var e = Curry._3(B.G.E.create, v, 0, v);
              return Curry._2(B.add_edge_e, g, e);
            }), g, vertices) : g;
    var add_edge = function (v1, v2, g) {
      if (Random.$$float(1.0) < prob) {
        return g;
      }
      var e = Curry._3(B.G.E.create, v1, distance(v1, v2), v2);
      return Curry._2(B.add_edge_e, g, e);
    };
    return Curry._3(Triangulation.fold, (function (v1, v2, g) {
                  var g$1 = add_edge(v1, v2, g);
                  if (B.G.is_directed) {
                    return add_edge(v2, v1, g$1);
                  } else {
                    return g$1;
                  }
                }), t, g$1);
  };
  return {
          graph: graph
        };
}

var Planar = {
  Make: Planar_Make,
  P: Planar_P,
  I: Planar_I
};

export {
  Make ,
  P ,
  I ,
  Planar ,
  
}
/* No side effect */
