// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as ReludeParse_Parser from "relude-parse/src/ReludeParse_Parser.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function make(a, b, c, d) {
  return {
          TAG: "IPv4",
          _0: a,
          _1: b,
          _2: c,
          _3: d
        };
}

var parseWithTuple = Curry._2(ReludeParse_Parser.mapTuple4, make, [
      Curry._2(ReludeParse_Parser.Infix.$less$star, ReludeParse_Parser.anyPositiveShort, ReludeParse_Parser.str(".")),
      Curry._2(ReludeParse_Parser.Infix.$less$star, ReludeParse_Parser.anyPositiveShort, ReludeParse_Parser.str(".")),
      Curry._2(ReludeParse_Parser.Infix.$less$star, ReludeParse_Parser.anyPositiveShort, ReludeParse_Parser.str(".")),
      ReludeParse_Parser.anyPositiveShort
    ]);

var prim1 = ReludeParse_Parser.runParser("127.0.0.1", parseWithTuple);

console.log("with tuple\n", prim1);

var parseWithNestedFlatMaps = Curry._2(ReludeParse_Parser.Infix.$great$great$eq, ReludeParse_Parser.anyPositiveShort, (function (a) {
        return Curry._2(ReludeParse_Parser.Infix.$great$great$eq, ReludeParse_Parser.str("."), (function (param) {
                      return Curry._2(ReludeParse_Parser.Infix.$great$great$eq, ReludeParse_Parser.anyPositiveShort, (function (b) {
                                    return Curry._2(ReludeParse_Parser.Infix.$great$great$eq, ReludeParse_Parser.str("."), (function (param) {
                                                  return Curry._2(ReludeParse_Parser.Infix.$great$great$eq, ReludeParse_Parser.anyPositiveShort, (function (c) {
                                                                return Curry._2(ReludeParse_Parser.Infix.$great$great$eq, ReludeParse_Parser.str("."), (function (param) {
                                                                              return ReludeParse_Parser.Infix.$less$hash$great(ReludeParse_Parser.anyPositiveShort, (function (d) {
                                                                                            return make(a, b, c, d);
                                                                                          }));
                                                                            }));
                                                              }));
                                                }));
                                  }));
                    }));
      }));

var prim1$1 = ReludeParse_Parser.runParser("127.0.0.1", parseWithNestedFlatMaps);

console.log("with nested flatMaps\n", prim1$1);

var parseWithMonadicFlow = Curry._2(ReludeParse_Parser.Infix.$less$star$great, Curry._2(ReludeParse_Parser.Infix.$less$star, Curry._2(ReludeParse_Parser.Infix.$less$star$great, Curry._2(ReludeParse_Parser.Infix.$less$star, Curry._2(ReludeParse_Parser.Infix.$less$star$great, Curry._2(ReludeParse_Parser.Infix.$less$star, Curry._2(ReludeParse_Parser.Infix.$less$$great, make, ReludeParse_Parser.anyPositiveShort), ReludeParse_Parser.str(".")), ReludeParse_Parser.anyPositiveShort), ReludeParse_Parser.str(".")), ReludeParse_Parser.anyPositiveShort), ReludeParse_Parser.str(".")), ReludeParse_Parser.anyPositiveShort);

var prim1$2 = ReludeParse_Parser.runParser("127.0.0.1", parseWithMonadicFlow);

console.log("with monadic flow\n", prim1$2);

var parseWithSepBy = Curry._2(ReludeParse_Parser.Infix.$great$great$eq, ReludeParse_Parser.sepBy(ReludeParse_Parser.str("."), ReludeParse_Parser.anyPositiveShort), (function (shorts) {
        if (!shorts) {
          return ReludeParse_Parser.fail("Expected exactly 4 shorts separated by .");
        }
        var match = shorts.tl;
        if (!match) {
          return ReludeParse_Parser.fail("Expected exactly 4 shorts separated by .");
        }
        var match$1 = match.tl;
        if (!match$1) {
          return ReludeParse_Parser.fail("Expected exactly 4 shorts separated by .");
        }
        var match$2 = match$1.tl;
        if (match$2 && !match$2.tl) {
          return ReludeParse_Parser.pure(make(shorts.hd, match.hd, match$1.hd, match$2.hd));
        } else {
          return ReludeParse_Parser.fail("Expected exactly 4 shorts separated by .");
        }
      }));

var prim1$3 = ReludeParse_Parser.runParser("127.0.0.1", parseWithSepBy);

console.log("with sepBy\n", prim1$3);

var P;

export {
  log ,
  log2 ,
  P ,
  make ,
  parseWithTuple ,
  parseWithNestedFlatMaps ,
  parseWithMonadicFlow ,
  parseWithSepBy ,
}
/* parseWithTuple Not a pure module */
