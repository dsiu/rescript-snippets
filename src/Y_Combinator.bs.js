// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "../node_modules/rescript/lib/es6/curry.js";
import * as Printf from "../node_modules/rescript/lib/es6/printf.js";

function fix(x) {
  return /* Fix */{
          _0: x
        };
}

function unfix(x) {
  return x._0;
}

function y(f) {
  var g = function (x, a) {
    return Curry._2(f, Curry._1(x._0, x), a);
  };
  var partial_arg = /* Fix */{
    _0: g
  };
  return function (param) {
    return g(partial_arg, param);
  };
}

function fact(self, n) {
  if (n === 0) {
    return 1;
  } else {
    return Math.imul(n, Curry._1(self, n - 1 | 0));
  }
}

function int2nat(self, n) {
  if (n === 0) {
    return /* Zero */0;
  } else {
    return /* Succ */{
            _0: Curry._1(self, n - 1 | 0)
          };
  }
}

function string_of_nat(x) {
  if (x) {
    return Curry._1(Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Succ(",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* Char_literal */12,
                          _0: /* ')' */41,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Succ(%s)"
                  }), string_of_nat(x._0));
  } else {
    return "Zero";
  }
}

var result = y(fact)(6);

Curry._1(Printf.printf(/* Format */{
          _0: {
            TAG: /* Int */4,
            _0: /* Int_d */0,
            _1: /* No_padding */0,
            _2: /* No_precision */0,
            _3: {
              TAG: /* Char_literal */12,
              _0: /* '\n' */10,
              _1: {
                TAG: /* Flush */10,
                _0: /* End_of_format */0
              }
            }
          },
          _1: "%d\n%!"
        }), result);

var result$1 = y(int2nat)(6);

Curry._1(Printf.printf(/* Format */{
          _0: {
            TAG: /* String */2,
            _0: /* No_padding */0,
            _1: {
              TAG: /* Char_literal */12,
              _0: /* '\n' */10,
              _1: {
                TAG: /* Flush */10,
                _0: /* End_of_format */0
              }
            }
          },
          _1: "%s\n%!"
        }), string_of_nat(result$1));

export {
  fix ,
  unfix ,
  y ,
  fact ,
  int2nat ,
  string_of_nat ,
  
}
/* result Not a pure module */
