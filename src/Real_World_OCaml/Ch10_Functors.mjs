// Generated by ReScript, PLEASE EDIT WITH CARE


function Increment(M) {
  let x = M.x + 1 | 0;
  return {
    x: x
  };
}

let Three = {
  x: 3
};

let x = 4;

let Four = {
  x: x
};

console.log(x - 3 | 0);

let Three_and_more = {
  x: 3,
  y: "three"
};

let x$1 = 4;

let Four_1 = {
  x: x$1
};

let A_Trivial_Example = {
  Increment: Increment,
  Three: Three,
  Four: Four,
  Three_and_more: Three_and_more,
  Four_1: Four_1
};

function Make_interval(Endpoint) {
  let create = (low, high) => {
    if (Endpoint.compare(low, high) > 0) {
      return "Empty";
    } else {
      return {
        TAG: "Interval",
        _0: low,
        _1: high
      };
    }
  };
  let is_empty = x => typeof x !== "object";
  let contains = (t, x) => {
    if (typeof t !== "object" || Endpoint.compare(x, t._0) < 0) {
      return false;
    } else {
      return Endpoint.compare(x, t._1) <= 0;
    }
  };
  let intersect = (t1, t2) => {
    let min = (x, y) => {
      if (Endpoint.compare(x, y) <= 0) {
        return x;
      } else {
        return y;
      }
    };
    let max = (x, y) => {
      if (Endpoint.compare(x, y) >= 0) {
        return x;
      } else {
        return y;
      }
    };
    if (typeof t1 !== "object" || typeof t2 !== "object") {
      return "Empty";
    } else {
      return create(max(t1._0, t2._0), min(t1._1, t2._1));
    }
  };
  return {
    create: create,
    is_empty: is_empty,
    contains: contains,
    intersect: intersect
  };
}

function create(low, high) {
  if (low > high) {
    return "Empty";
  } else {
    return {
      TAG: "Interval",
      _0: low,
      _1: high
    };
  }
}

function is_empty(x) {
  return typeof x !== "object";
}

function contains(t, x) {
  if (typeof t !== "object" || x < t._0) {
    return false;
  } else {
    return x <= t._1;
  }
}

function intersect(t1, t2) {
  let min = (x, y) => {
    if (x <= y) {
      return x;
    } else {
      return y;
    }
  };
  let max = (x, y) => {
    if (x >= y) {
      return x;
    } else {
      return y;
    }
  };
  if (typeof t1 !== "object" || typeof t2 !== "object") {
    return "Empty";
  } else {
    return create(max(t1._0, t2._0), min(t1._1, t2._1));
  }
}

let Int_interval = {
  create: create,
  is_empty: is_empty,
  contains: contains,
  intersect: intersect
};

function create$1(low, high) {
  if (low > high) {
    return "Empty";
  } else {
    return {
      TAG: "Interval",
      _0: low,
      _1: high
    };
  }
}

function is_empty$1(x) {
  return typeof x !== "object";
}

function contains$1(t, x) {
  if (typeof t !== "object" || x < t._0) {
    return false;
  } else {
    return x <= t._1;
  }
}

function intersect$1(t1, t2) {
  let min = (x, y) => {
    if (x <= y) {
      return x;
    } else {
      return y;
    }
  };
  let max = (x, y) => {
    if (x >= y) {
      return x;
    } else {
      return y;
    }
  };
  if (typeof t1 !== "object" || typeof t2 !== "object") {
    return "Empty";
  } else {
    return create$1(max(t1._0, t2._0), min(t1._1, t2._1));
  }
}

let String_interval = {
  create: create$1,
  is_empty: is_empty$1,
  contains: contains$1,
  intersect: intersect$1
};

function compare(param, param$1) {
  return 0;
}

let My_Str = {
  compare: compare
};

function create$2(low, high) {
  return {
    TAG: "Interval",
    _0: low,
    _1: high
  };
}

function is_empty$2(x) {
  return typeof x !== "object";
}

function contains$2(t, x) {
  return typeof t === "object";
}

function intersect$2(t1, t2) {
  let min = (x, y) => x;
  let max = (x, y) => x;
  if (typeof t1 !== "object" || typeof t2 !== "object") {
    return "Empty";
  } else {
    return create$2(max(t1._0, t2._0), min(t1._1, t2._1));
  }
}

let My_Str_interval = {
  create: create$2,
  is_empty: is_empty$2,
  contains: contains$2,
  intersect: intersect$2
};

let i1 = create(3, 8);

let i2 = create(4, 10);

console.log(intersect(i1, i2));

function create$3(low, high) {
  if ((low - high | 0) > 0) {
    return "Empty";
  } else {
    return {
      TAG: "Interval",
      _0: low,
      _1: high
    };
  }
}

function is_empty$3(x) {
  return typeof x !== "object";
}

function contains$3(t, x) {
  if (typeof t !== "object" || (x - t._0 | 0) < 0) {
    return false;
  } else {
    return (x - t._1 | 0) <= 0;
  }
}

function intersect$3(t1, t2) {
  let min = (x, y) => {
    if ((x - y | 0) <= 0) {
      return x;
    } else {
      return y;
    }
  };
  let max = (x, y) => {
    if ((x - y | 0) >= 0) {
      return x;
    } else {
      return y;
    }
  };
  if (typeof t1 !== "object" || typeof t2 !== "object") {
    return "Empty";
  } else {
    return create$3(max(t1._0, t2._0), min(t1._1, t2._1));
  }
}

let Rev_int_interval = {
  create: create$3,
  is_empty: is_empty$3,
  contains: contains$3,
  intersect: intersect$3
};

console.log(is_empty({
  TAG: "Interval",
  _0: 4,
  _1: 3
}));

let A_Bigger_Example = {
  Make_interval: Make_interval,
  Int_interval: Int_interval,
  String_interval: String_interval,
  My_Str: My_Str,
  My_Str_interval: My_Str_interval,
  i1: i1,
  i2: i2,
  Rev_int_interval: Rev_int_interval
};

function Make_interval$1(Endpoint) {
  let create = (low, high) => {
    if (Endpoint.compare(low, high) > 0) {
      return "Empty";
    } else {
      return {
        TAG: "Interval",
        _0: low,
        _1: high
      };
    }
  };
  let is_empty = x => typeof x !== "object";
  let contains = (t, x) => {
    if (typeof t !== "object" || Endpoint.compare(x, t._0) < 0) {
      return false;
    } else {
      return Endpoint.compare(x, t._1) <= 0;
    }
  };
  let intersect = (t1, t2) => {
    let min = (x, y) => {
      if (Endpoint.compare(x, y) <= 0) {
        return x;
      } else {
        return y;
      }
    };
    let max = (x, y) => {
      if (Endpoint.compare(x, y) >= 0) {
        return x;
      } else {
        return y;
      }
    };
    if (typeof t1 !== "object" || typeof t2 !== "object") {
      return "Empty";
    } else {
      return create(max(t1._0, t2._0), min(t1._1, t2._1));
    }
  };
  return {
    create: create,
    is_empty: is_empty,
    contains: contains,
    intersect: intersect
  };
}

function create$4(low, high) {
  if (low > high) {
    return "Empty";
  } else {
    return {
      TAG: "Interval",
      _0: low,
      _1: high
    };
  }
}

function is_empty$4(x) {
  return typeof x !== "object";
}

function contains$4(t, x) {
  if (typeof t !== "object" || x < t._0) {
    return false;
  } else {
    return x <= t._1;
  }
}

function intersect$4(t1, t2) {
  let min = (x, y) => {
    if (x <= y) {
      return x;
    } else {
      return y;
    }
  };
  let max = (x, y) => {
    if (x >= y) {
      return x;
    } else {
      return y;
    }
  };
  if (typeof t1 !== "object" || typeof t2 !== "object") {
    return "Empty";
  } else {
    return create$4(max(t1._0, t2._0), min(t1._1, t2._1));
  }
}

let Int_interval$1 = {
  create: create$4,
  is_empty: is_empty$4,
  contains: contains$4,
  intersect: intersect$4
};

let i = create$4(3, 4);

console.log(contains$4(i, 5));

let Sharing_Constraints = {
  Make_interval: Make_interval$1,
  Int_interval: Int_interval$1,
  i: i
};

function Make_interval$2(Endpoint) {
  let create = (low, high) => {
    if (Endpoint.compare(low, high) > 0) {
      return "Empty";
    } else {
      return {
        TAG: "Interval",
        _0: low,
        _1: high
      };
    }
  };
  let is_empty = x => typeof x !== "object";
  let contains = (t, x) => {
    if (typeof t !== "object" || Endpoint.compare(x, t._0) < 0) {
      return false;
    } else {
      return Endpoint.compare(x, t._1) <= 0;
    }
  };
  let intersect = (t1, t2) => {
    let min = (x, y) => {
      if (Endpoint.compare(x, y) <= 0) {
        return x;
      } else {
        return y;
      }
    };
    let max = (x, y) => {
      if (Endpoint.compare(x, y) >= 0) {
        return x;
      } else {
        return y;
      }
    };
    if (typeof t1 !== "object" || typeof t2 !== "object") {
      return "Empty";
    } else {
      return create(max(t1._0, t2._0), min(t1._1, t2._1));
    }
  };
  return {
    create: create,
    is_empty: is_empty,
    contains: contains,
    intersect: intersect
  };
}

function create$5(low, high) {
  if (low > high) {
    return "Empty";
  } else {
    return {
      TAG: "Interval",
      _0: low,
      _1: high
    };
  }
}

function is_empty$5(x) {
  return typeof x !== "object";
}

function contains$5(t, x) {
  if (typeof t !== "object" || x < t._0) {
    return false;
  } else {
    return x <= t._1;
  }
}

function intersect$5(t1, t2) {
  let min = (x, y) => {
    if (x <= y) {
      return x;
    } else {
      return y;
    }
  };
  let max = (x, y) => {
    if (x >= y) {
      return x;
    } else {
      return y;
    }
  };
  if (typeof t1 !== "object" || typeof t2 !== "object") {
    return "Empty";
  } else {
    return create$5(max(t1._0, t2._0), min(t1._1, t2._1));
  }
}

let Int_interval$2 = {
  create: create$5,
  is_empty: is_empty$5,
  contains: contains$5,
  intersect: intersect$5
};

console.log(is_empty$5(create$5(3, 4)));

let Destructive_Substitution = {
  Make_interval: Make_interval$2,
  Int_interval: Int_interval$2
};

let Sexp = {};

let Sexpable = {};

function Make_interval$3(Endpoint) {
  let create = (low, high) => {
    if (Endpoint.compare(low, high) > 0) {
      return "Empty";
    } else {
      return {
        TAG: "Interval",
        _0: low,
        _1: high
      };
    }
  };
  let is_empty = x => typeof x !== "object";
  let contains = (t, x) => {
    if (typeof t !== "object" || Endpoint.compare(x, t._0) < 0) {
      return false;
    } else {
      return Endpoint.compare(x, t._1) <= 0;
    }
  };
  let intersect = (t1, t2) => {
    let min = (x, y) => {
      if (Endpoint.compare(x, y) <= 0) {
        return x;
      } else {
        return y;
      }
    };
    let max = (x, y) => {
      if (Endpoint.compare(x, y) >= 0) {
        return x;
      } else {
        return y;
      }
    };
    if (typeof t1 !== "object" || typeof t2 !== "object") {
      return "Empty";
    } else {
      return create(max(t1._0, t2._0), min(t1._1, t2._1));
    }
  };
  return {
    create: create,
    is_empty: is_empty,
    contains: contains,
    intersect: intersect
  };
}

let Using_Multiple_Interfaces = {
  Sexp: Sexp,
  Sexpable: Sexpable,
  Make_interval: Make_interval$3
};

let Extending_Modules = {};

export {
  A_Trivial_Example,
  A_Bigger_Example,
  Sharing_Constraints,
  Destructive_Substitution,
  Using_Multiple_Interfaces,
  Extending_Modules,
}
/*  Not a pure module */
