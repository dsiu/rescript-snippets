// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function flatMapList(xs, f) {
  return Belt_List.reduce(Belt_List.map(xs, f), /* [] */0, Belt_List.concat);
}

function listToOption(l) {
  if (l) {
    return Caml_option.some(l.hd);
  }
  
}

function combinationIfList2(a, b, f) {
  return Belt_List.reduceU(a, /* [] */0, (function (acc, x) {
                return Belt_List.concat(acc, Belt_List.reduceU(b, /* [] */0, (function (acc, y) {
                                  var r = f(x, y);
                                  if (r !== undefined) {
                                    return Belt_List.concat(acc, {
                                                hd: Caml_option.valFromOption(r),
                                                tl: /* [] */0
                                              });
                                  } else {
                                    return acc;
                                  }
                                })));
              }));
}

function combinationList2(a, b, f) {
  return combinationIfList2(a, b, (function (x, y) {
                return Caml_option.some(f(x, y));
              }));
}

function flatMapArray(xs, f) {
  return Belt_Array.reduce(Belt_Array.map(xs, f), [], Belt_Array.concat);
}

function arrayToOption(__x) {
  return Belt_Array.get(__x, 0);
}

function foldLeftArray(xs, f) {
  var init = Belt_Array.getExn(xs, 0);
  var rest = Belt_Array.sliceToEnd(xs, 1);
  return Belt_Array.reduce(rest, init, f);
}

function foldRightArray(xs, f) {
  var end = xs.length - 1 | 0;
  var init = Belt_Array.getExn(xs, end);
  var rest = Belt_Array.slice(xs, 0, end);
  return Belt_Array.reduceReverse(rest, init, f);
}

function combinationIfArray2(a, b, f) {
  var ret = {
    contents: []
  };
  a.forEach(function (x) {
        b.forEach(function (y) {
              var r = f(x, y);
              if (r !== undefined) {
                ret.contents = ret.contents.concat([Caml_option.valFromOption(r)]);
                return ;
              }
              
            });
      });
  return ret.contents;
}

function combinationArray2(a, b, f) {
  return combinationIfArray2(a, b, (function (x, y) {
                return Caml_option.some(f(x, y));
              }));
}

function combinationIfArray3(a, b, c, f) {
  var ret = {
    contents: []
  };
  a.forEach(function (x) {
        b.forEach(function (y) {
              c.forEach(function (z) {
                    var r = f(x, y, z);
                    if (r !== undefined) {
                      ret.contents = ret.contents.concat([Caml_option.valFromOption(r)]);
                      return ;
                    }
                    
                  });
            });
      });
  return ret.contents;
}

function combinationArray3(a, b, c, f) {
  return combinationIfArray3(a, b, c, (function (x, y, z) {
                return Caml_option.some(f(x, y, z));
              }));
}

function combinationIfArray4(a, b, c, d, f) {
  var ret = {
    contents: []
  };
  a.forEach(function (x) {
        b.forEach(function (y) {
              c.forEach(function (z) {
                    d.forEach(function (w) {
                          var r = f(x, y, z, w);
                          if (r !== undefined) {
                            ret.contents = ret.contents.concat([Caml_option.valFromOption(r)]);
                            return ;
                          }
                          
                        });
                  });
            });
      });
  return ret.contents;
}

function combinationArray4(a, b, c, d, f) {
  return combinationIfArray4(a, b, c, d, (function (x, y, z, w) {
                return Caml_option.some(f(x, y, z, w));
              }));
}

function optionOr(a, b) {
  if (a !== undefined) {
    return a;
  } else {
    return b;
  }
}

function identity(a) {
  return a;
}

function eq(x, y) {
  return x === y;
}

function composeU(f, g, x) {
  return g(f(x));
}

function compose(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function compose3(f, g, h, x) {
  return Curry._1(h, Curry._1(g, Curry._1(f, x)));
}

function compose4(f, g, h, i, x) {
  return Curry._1(i, Curry._1(h, Curry._1(g, Curry._1(f, x))));
}

function composeN(fs) {
  return foldLeftArray(fs, compose);
}

export {
  flatMapList ,
  listToOption ,
  combinationIfList2 ,
  combinationList2 ,
  flatMapArray ,
  arrayToOption ,
  foldLeftArray ,
  foldRightArray ,
  combinationIfArray2 ,
  combinationArray2 ,
  combinationIfArray3 ,
  combinationArray3 ,
  combinationIfArray4 ,
  combinationArray4 ,
  optionOr ,
  identity ,
  eq ,
  composeU ,
  compose ,
  compose3 ,
  compose4 ,
  composeN ,
}
/* No side effect */
