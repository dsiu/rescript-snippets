// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Relude_Int from "rescript-relude/src/Relude_Int.res.mjs";
import * as Relude_Tuple from "rescript-relude/src/Relude_Tuple.res.mjs";
import * as Relude_String from "rescript-relude/src/Relude_String.res.mjs";
import * as Relude_Tuple2 from "rescript-relude/src/Relude_Tuple2.res.mjs";
import * as Relude_ReaderT from "rescript-relude/src/Relude_ReaderT.res.mjs";
import * as Relude_Array_Base from "rescript-relude/src/array/Relude_Array_Base.res.mjs";
import * as Relude_Array_Instances from "rescript-relude/src/array/Relude_Array_Instances.res.mjs";
import * as Relude_Array_Specializations from "rescript-relude/src/array/Relude_Array_Specializations.res.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

let testEnv = {
  intValue: 42,
  stringValue: "abc"
};

let Reader = Relude_ReaderT.Reader.WithEnv({});

let __x = Reader.make(r => (r.intValue << 1));

let r = Reader.runReaderT(testEnv, __x);

console.log(r);

let $$let = Relude_Tuple2.WithOrds(Relude_Int.Ord)(Relude_String.Ord);

let include = Relude_Array_Specializations.ArrayOrdExtensions({
  eq: $$let.eq,
  compare: $$let.compare
});

let sort = include.sort;

let AT_StrInt_contains = include.contains;

let AT_StrInt_indexOf = include.indexOf;

let AT_StrInt_distinct = include.distinct;

let AT_StrInt_removeFirst = include.removeFirst;

let AT_StrInt_removeEach = include.removeEach;

let AT_StrInt_eq = include.eq;

let AT_StrInt_min = include.min;

let AT_StrInt_max = include.max;

let AT_StrInt = {
  concat: Relude_Array_Instances.concat,
  SemigroupAny: Relude_Array_Instances.SemigroupAny,
  concatNamed: Relude_Array_Instances.concatNamed,
  map: Relude_Array_Instances.map,
  Functor: Relude_Array_Instances.Functor,
  BsFunctorExtensions: Relude_Array_Instances.BsFunctorExtensions,
  flipMap: Relude_Array_Instances.flipMap,
  $$void: Relude_Array_Instances.$$void,
  voidRight: Relude_Array_Instances.voidRight,
  voidLeft: Relude_Array_Instances.voidLeft,
  flap: Relude_Array_Instances.flap,
  apply: Relude_Array_Instances.apply,
  Apply: Relude_Array_Instances.Apply,
  BsApplyExtensions: Relude_Array_Instances.BsApplyExtensions,
  applyFirst: Relude_Array_Instances.applyFirst,
  applySecond: Relude_Array_Instances.applySecond,
  map2: Relude_Array_Instances.map2,
  map3: Relude_Array_Instances.map3,
  map4: Relude_Array_Instances.map4,
  map5: Relude_Array_Instances.map5,
  tuple2: Relude_Array_Instances.tuple2,
  tuple3: Relude_Array_Instances.tuple3,
  tuple4: Relude_Array_Instances.tuple4,
  tuple5: Relude_Array_Instances.tuple5,
  mapTuple2: Relude_Array_Instances.mapTuple2,
  mapTuple3: Relude_Array_Instances.mapTuple3,
  mapTuple4: Relude_Array_Instances.mapTuple4,
  mapTuple5: Relude_Array_Instances.mapTuple5,
  pure: Relude_Array_Instances.pure,
  Applicative: Relude_Array_Instances.Applicative,
  BsApplicativeExtensions: Relude_Array_Instances.BsApplicativeExtensions,
  liftA1: Relude_Array_Instances.liftA1,
  bind: Relude_Array_Instances.bind,
  Monad: Relude_Array_Instances.Monad,
  BsMonadExtensions: Relude_Array_Instances.BsMonadExtensions,
  flatMap: Relude_Array_Instances.flatMap,
  flatten: Relude_Array_Instances.flatten,
  composeKleisli: Relude_Array_Instances.composeKleisli,
  flipComposeKleisli: Relude_Array_Instances.flipComposeKleisli,
  liftM1: Relude_Array_Instances.liftM1,
  when_: Relude_Array_Instances.when_,
  unless: Relude_Array_Instances.unless,
  alt: Relude_Array_Instances.alt,
  Alt: Relude_Array_Instances.Alt,
  orElse: Relude_Array_Instances.orElse,
  imap: Relude_Array_Instances.imap,
  Invariant: Relude_Array_Instances.Invariant,
  extend: Relude_Array_Instances.extend,
  Extend: Relude_Array_Instances.Extend,
  foldLeft: Relude_Array_Instances.foldLeft,
  foldRight: Relude_Array_Instances.foldRight,
  Foldable: Relude_Array_Instances.Foldable,
  BsFoldableExtensions: Relude_Array_Instances.BsFoldableExtensions,
  any: Relude_Array_Instances.any,
  all: Relude_Array_Instances.all,
  containsBy: Relude_Array_Instances.containsBy,
  indexOfBy: Relude_Array_Instances.indexOfBy,
  minBy: Relude_Array_Instances.minBy,
  maxBy: Relude_Array_Instances.maxBy,
  countBy: Relude_Array_Instances.countBy,
  size: Relude_Array_Instances.size,
  count: Relude_Array_Instances.count,
  forEach: Relude_Array_Instances.forEach,
  forEachWithIndex: Relude_Array_Instances.forEachWithIndex,
  find: Relude_Array_Instances.find,
  findWithIndex: Relude_Array_Instances.findWithIndex,
  toArray: Relude_Array_Instances.toArray,
  FoldableSemigroupExtensions: Relude_Array_Instances.FoldableSemigroupExtensions,
  FoldableMonoidExtensions: Relude_Array_Instances.FoldableMonoidExtensions,
  foldMap: Relude_Array_Instances.foldMap,
  foldWithMonoid: Relude_Array_Instances.foldWithMonoid,
  intercalate: Relude_Array_Instances.intercalate,
  FoldableApplicativeExtensions: Relude_Array_Instances.FoldableApplicativeExtensions,
  FoldableMonadExtensions: Relude_Array_Instances.FoldableMonadExtensions,
  FoldableEqExtensions: Relude_Array_Instances.FoldableEqExtensions,
  FoldableOrdExtensions: Relude_Array_Instances.FoldableOrdExtensions,
  Traversable: Relude_Array_Instances.Traversable,
  eqBy: Relude_Array_Instances.eqBy,
  Eq: Relude_Array_Instances.Eq,
  Ord: Relude_Array_Instances.Ord,
  showBy: Relude_Array_Instances.showBy,
  show: Relude_Array_Instances.show,
  Show: Relude_Array_Instances.Show,
  fromList: Relude_Array_Instances.fromList,
  toList: Relude_Array_Instances.toList,
  IsoList: Relude_Array_Instances.IsoList,
  Fn: Relude_Array_Base.Fn,
  cons: Relude_Array_Base.cons,
  prepend: Relude_Array_Base.prepend,
  uncons: Relude_Array_Base.uncons,
  append: Relude_Array_Base.append,
  repeat: Relude_Array_Base.repeat,
  makeWithIndex: Relude_Array_Base.makeWithIndex,
  mapWithIndex: Relude_Array_Base.mapWithIndex,
  reverse: Relude_Array_Base.reverse,
  shuffleInPlace: Relude_Array_Base.shuffleInPlace,
  shuffle: Relude_Array_Base.shuffle,
  length: Relude_Array_Base.length,
  isEmpty: Relude_Array_Base.isEmpty,
  isNotEmpty: Relude_Array_Base.isNotEmpty,
  at: Relude_Array_Base.at,
  setAt: Relude_Array_Base.setAt,
  head: Relude_Array_Base.head,
  tail: Relude_Array_Base.tail,
  tailOrEmpty: Relude_Array_Base.tailOrEmpty,
  init: Relude_Array_Base.init,
  initOrEmpty: Relude_Array_Base.initOrEmpty,
  last: Relude_Array_Base.last,
  take: Relude_Array_Base.take,
  takeExactly: Relude_Array_Base.takeExactly,
  takeWhile: Relude_Array_Base.takeWhile,
  drop: Relude_Array_Base.drop,
  dropExactly: Relude_Array_Base.dropExactly,
  dropWhile: Relude_Array_Base.dropWhile,
  filter: Relude_Array_Base.filter,
  keep: Relude_Array_Base.keep,
  filterWithIndex: Relude_Array_Base.filterWithIndex,
  keepWithIndex: Relude_Array_Base.keepWithIndex,
  filterNot: Relude_Array_Base.filterNot,
  reject: Relude_Array_Base.reject,
  filterNotWithIndex: Relude_Array_Base.filterNotWithIndex,
  rejectWithIndex: Relude_Array_Base.rejectWithIndex,
  mapOption: Relude_Array_Base.mapOption,
  catOption: Relude_Array_Base.catOption,
  partition: Relude_Array_Base.partition,
  splitAt: Relude_Array_Base.splitAt,
  prependToAll: Relude_Array_Base.prependToAll,
  intersperse: Relude_Array_Base.intersperse,
  replicate: Relude_Array_Base.replicate,
  zip: Relude_Array_Base.zip,
  zipWith: Relude_Array_Base.zipWith,
  zipWithIndex: Relude_Array_Base.zipWithIndex,
  unzip: Relude_Array_Base.unzip,
  sortWithInt: Relude_Array_Base.sortWithInt,
  sortBy: Relude_Array_Base.sortBy,
  distinctBy: Relude_Array_Base.distinctBy,
  removeFirstBy: Relude_Array_Base.removeFirstBy,
  removeEachBy: Relude_Array_Base.removeEachBy,
  replaceAt: Relude_Array_Base.replaceAt,
  scanLeft: Relude_Array_Base.scanLeft,
  scanRight: Relude_Array_Base.scanRight,
  insertAt: Relude_Array_Base.insertAt,
  updateAt: Relude_Array_Base.updateAt,
  swapAt: Relude_Array_Base.swapAt,
  removeAt: Relude_Array_Base.removeAt,
  chunk: Relude_Array_Base.chunk,
  contains: AT_StrInt_contains,
  indexOf: AT_StrInt_indexOf,
  distinct: AT_StrInt_distinct,
  removeFirst: AT_StrInt_removeFirst,
  removeEach: AT_StrInt_removeEach,
  eq: AT_StrInt_eq,
  min: AT_StrInt_min,
  max: AT_StrInt_max,
  sort: sort
};

let arr = [
  [
    3,
    "c"
  ],
  [
    26,
    "z"
  ],
  [
    1,
    "a"
  ],
  [
    2,
    "b"
  ]
];

let sorted = sort(arr);

console.log(arr);

console.log(sorted);

function plus1(param) {
  let s = param[1];
  return Relude_Array_Instances.pure([
    param[0] + 1 | 0,
    s + s
  ]);
}

function reverseTuple(param) {
  return Relude_Array_Instances.pure([
    param[1],
    param[0]
  ]);
}

let prim = Relude_Array_Instances.bind(arr, plus1);

console.log(prim);

let arr_rev = Relude_Array_Instances.bind(arr, reverseTuple);

let $$let$1 = Relude_Tuple2.WithOrds(Relude_String.Ord)(Relude_Int.Ord);

let include$1 = Relude_Array_Specializations.ArrayOrdExtensions({
  eq: $$let$1.eq,
  compare: $$let$1.compare
});

let sort$1 = include$1.sort;

let AT_IntStr_contains = include$1.contains;

let AT_IntStr_indexOf = include$1.indexOf;

let AT_IntStr_distinct = include$1.distinct;

let AT_IntStr_removeFirst = include$1.removeFirst;

let AT_IntStr_removeEach = include$1.removeEach;

let AT_IntStr_eq = include$1.eq;

let AT_IntStr_min = include$1.min;

let AT_IntStr_max = include$1.max;

let AT_IntStr = {
  concat: Relude_Array_Instances.concat,
  SemigroupAny: Relude_Array_Instances.SemigroupAny,
  concatNamed: Relude_Array_Instances.concatNamed,
  map: Relude_Array_Instances.map,
  Functor: Relude_Array_Instances.Functor,
  BsFunctorExtensions: Relude_Array_Instances.BsFunctorExtensions,
  flipMap: Relude_Array_Instances.flipMap,
  $$void: Relude_Array_Instances.$$void,
  voidRight: Relude_Array_Instances.voidRight,
  voidLeft: Relude_Array_Instances.voidLeft,
  flap: Relude_Array_Instances.flap,
  apply: Relude_Array_Instances.apply,
  Apply: Relude_Array_Instances.Apply,
  BsApplyExtensions: Relude_Array_Instances.BsApplyExtensions,
  applyFirst: Relude_Array_Instances.applyFirst,
  applySecond: Relude_Array_Instances.applySecond,
  map2: Relude_Array_Instances.map2,
  map3: Relude_Array_Instances.map3,
  map4: Relude_Array_Instances.map4,
  map5: Relude_Array_Instances.map5,
  tuple2: Relude_Array_Instances.tuple2,
  tuple3: Relude_Array_Instances.tuple3,
  tuple4: Relude_Array_Instances.tuple4,
  tuple5: Relude_Array_Instances.tuple5,
  mapTuple2: Relude_Array_Instances.mapTuple2,
  mapTuple3: Relude_Array_Instances.mapTuple3,
  mapTuple4: Relude_Array_Instances.mapTuple4,
  mapTuple5: Relude_Array_Instances.mapTuple5,
  pure: Relude_Array_Instances.pure,
  Applicative: Relude_Array_Instances.Applicative,
  BsApplicativeExtensions: Relude_Array_Instances.BsApplicativeExtensions,
  liftA1: Relude_Array_Instances.liftA1,
  bind: Relude_Array_Instances.bind,
  Monad: Relude_Array_Instances.Monad,
  BsMonadExtensions: Relude_Array_Instances.BsMonadExtensions,
  flatMap: Relude_Array_Instances.flatMap,
  flatten: Relude_Array_Instances.flatten,
  composeKleisli: Relude_Array_Instances.composeKleisli,
  flipComposeKleisli: Relude_Array_Instances.flipComposeKleisli,
  liftM1: Relude_Array_Instances.liftM1,
  when_: Relude_Array_Instances.when_,
  unless: Relude_Array_Instances.unless,
  alt: Relude_Array_Instances.alt,
  Alt: Relude_Array_Instances.Alt,
  orElse: Relude_Array_Instances.orElse,
  imap: Relude_Array_Instances.imap,
  Invariant: Relude_Array_Instances.Invariant,
  extend: Relude_Array_Instances.extend,
  Extend: Relude_Array_Instances.Extend,
  foldLeft: Relude_Array_Instances.foldLeft,
  foldRight: Relude_Array_Instances.foldRight,
  Foldable: Relude_Array_Instances.Foldable,
  BsFoldableExtensions: Relude_Array_Instances.BsFoldableExtensions,
  any: Relude_Array_Instances.any,
  all: Relude_Array_Instances.all,
  containsBy: Relude_Array_Instances.containsBy,
  indexOfBy: Relude_Array_Instances.indexOfBy,
  minBy: Relude_Array_Instances.minBy,
  maxBy: Relude_Array_Instances.maxBy,
  countBy: Relude_Array_Instances.countBy,
  size: Relude_Array_Instances.size,
  count: Relude_Array_Instances.count,
  forEach: Relude_Array_Instances.forEach,
  forEachWithIndex: Relude_Array_Instances.forEachWithIndex,
  find: Relude_Array_Instances.find,
  findWithIndex: Relude_Array_Instances.findWithIndex,
  toArray: Relude_Array_Instances.toArray,
  FoldableSemigroupExtensions: Relude_Array_Instances.FoldableSemigroupExtensions,
  FoldableMonoidExtensions: Relude_Array_Instances.FoldableMonoidExtensions,
  foldMap: Relude_Array_Instances.foldMap,
  foldWithMonoid: Relude_Array_Instances.foldWithMonoid,
  intercalate: Relude_Array_Instances.intercalate,
  FoldableApplicativeExtensions: Relude_Array_Instances.FoldableApplicativeExtensions,
  FoldableMonadExtensions: Relude_Array_Instances.FoldableMonadExtensions,
  FoldableEqExtensions: Relude_Array_Instances.FoldableEqExtensions,
  FoldableOrdExtensions: Relude_Array_Instances.FoldableOrdExtensions,
  Traversable: Relude_Array_Instances.Traversable,
  eqBy: Relude_Array_Instances.eqBy,
  Eq: Relude_Array_Instances.Eq,
  Ord: Relude_Array_Instances.Ord,
  showBy: Relude_Array_Instances.showBy,
  show: Relude_Array_Instances.show,
  Show: Relude_Array_Instances.Show,
  fromList: Relude_Array_Instances.fromList,
  toList: Relude_Array_Instances.toList,
  IsoList: Relude_Array_Instances.IsoList,
  Fn: Relude_Array_Base.Fn,
  cons: Relude_Array_Base.cons,
  prepend: Relude_Array_Base.prepend,
  uncons: Relude_Array_Base.uncons,
  append: Relude_Array_Base.append,
  repeat: Relude_Array_Base.repeat,
  makeWithIndex: Relude_Array_Base.makeWithIndex,
  mapWithIndex: Relude_Array_Base.mapWithIndex,
  reverse: Relude_Array_Base.reverse,
  shuffleInPlace: Relude_Array_Base.shuffleInPlace,
  shuffle: Relude_Array_Base.shuffle,
  length: Relude_Array_Base.length,
  isEmpty: Relude_Array_Base.isEmpty,
  isNotEmpty: Relude_Array_Base.isNotEmpty,
  at: Relude_Array_Base.at,
  setAt: Relude_Array_Base.setAt,
  head: Relude_Array_Base.head,
  tail: Relude_Array_Base.tail,
  tailOrEmpty: Relude_Array_Base.tailOrEmpty,
  init: Relude_Array_Base.init,
  initOrEmpty: Relude_Array_Base.initOrEmpty,
  last: Relude_Array_Base.last,
  take: Relude_Array_Base.take,
  takeExactly: Relude_Array_Base.takeExactly,
  takeWhile: Relude_Array_Base.takeWhile,
  drop: Relude_Array_Base.drop,
  dropExactly: Relude_Array_Base.dropExactly,
  dropWhile: Relude_Array_Base.dropWhile,
  filter: Relude_Array_Base.filter,
  keep: Relude_Array_Base.keep,
  filterWithIndex: Relude_Array_Base.filterWithIndex,
  keepWithIndex: Relude_Array_Base.keepWithIndex,
  filterNot: Relude_Array_Base.filterNot,
  reject: Relude_Array_Base.reject,
  filterNotWithIndex: Relude_Array_Base.filterNotWithIndex,
  rejectWithIndex: Relude_Array_Base.rejectWithIndex,
  mapOption: Relude_Array_Base.mapOption,
  catOption: Relude_Array_Base.catOption,
  partition: Relude_Array_Base.partition,
  splitAt: Relude_Array_Base.splitAt,
  prependToAll: Relude_Array_Base.prependToAll,
  intersperse: Relude_Array_Base.intersperse,
  replicate: Relude_Array_Base.replicate,
  zip: Relude_Array_Base.zip,
  zipWith: Relude_Array_Base.zipWith,
  zipWithIndex: Relude_Array_Base.zipWithIndex,
  unzip: Relude_Array_Base.unzip,
  sortWithInt: Relude_Array_Base.sortWithInt,
  sortBy: Relude_Array_Base.sortBy,
  distinctBy: Relude_Array_Base.distinctBy,
  removeFirstBy: Relude_Array_Base.removeFirstBy,
  removeEachBy: Relude_Array_Base.removeEachBy,
  replaceAt: Relude_Array_Base.replaceAt,
  scanLeft: Relude_Array_Base.scanLeft,
  scanRight: Relude_Array_Base.scanRight,
  insertAt: Relude_Array_Base.insertAt,
  updateAt: Relude_Array_Base.updateAt,
  swapAt: Relude_Array_Base.swapAt,
  removeAt: Relude_Array_Base.removeAt,
  chunk: Relude_Array_Base.chunk,
  contains: AT_IntStr_contains,
  indexOf: AT_IntStr_indexOf,
  distinct: AT_IntStr_distinct,
  removeFirst: AT_IntStr_removeFirst,
  removeEach: AT_IntStr_removeEach,
  eq: AT_IntStr_eq,
  min: AT_IntStr_min,
  max: AT_IntStr_max,
  sort: sort$1
};

let prim$1 = sort$1(arr_rev);

console.log(prim$1);

let prim$2 = Relude_Array_Instances.showBy(extra => Relude_Tuple.showBy2(Relude_String.show, Relude_Int.show, extra), arr_rev);

console.log(prim$2);

let ReaderT;

let Tuple;

let $$Array;

let $$String;

let Int;

export {
  log,
  log2,
  testEnv,
  ReaderT,
  Reader,
  r,
  Tuple,
  $$Array,
  $$String,
  Int,
  AT_StrInt,
  arr,
  sorted,
  plus1,
  reverseTuple,
  arr_rev,
  AT_IntStr,
}
/* Reader Not a pure module */
