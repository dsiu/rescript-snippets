// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Char from "rescript/lib/es6/Char.js";
import * as Pervasives from "rescript/lib/es6/Pervasives.js";
import * as Stdlib_List from "rescript/lib/es6/Stdlib_List.js";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

function log(prim) {
  console.log(prim);
}

function logList(l) {
  let prim = Stdlib_List.toArray(l);
  console.log(prim);
}

function log2(x, y) {
  console.log(y, x);
}

function logList2(l, str) {
  let x = Stdlib_List.toArray(l);
  console.log(str, x);
}

function lseq(n) {
  return {
    TAG: "Cons",
    _0: n,
    _1: () => lseq(n + 1 | 0)
  };
}

function lhd(param) {
  return param._0;
}

function ltl(param) {
  return param._1();
}

function ltake(param, n) {
  if (n !== 0) {
    return {
      hd: param._0,
      tl: ltake(param._1(), n - 1 | 0)
    };
  } else {
    return /* [] */0;
  }
}

function ldrop(_ll, _n) {
  while (true) {
    let n = _n;
    let ll = _ll;
    if (n === 0) {
      return ll;
    }
    _n = n - 1 | 0;
    _ll = ll._1();
    continue;
  };
}

let prim = lseq(3);

console.log(prim);

logList(ltake(lseq(3), 20));

function lmap(f, param) {
  let tf = param._1;
  return {
    TAG: "Cons",
    _0: f(param._0),
    _1: () => lmap(f, tf())
  };
}

function lfilter(f, _param) {
  while (true) {
    let param = _param;
    let tf = param._1;
    let h = param._0;
    if (f(h)) {
      return {
        TAG: "Cons",
        _0: h,
        _1: () => lfilter(f, tf())
      };
    }
    _param = tf();
    continue;
  };
}

let cubes = lfilter(x => x % 5 === 0, lmap(x => (x * x | 0) * x | 0, lseq(1)));

logList(ltake(cubes, 20));

function mkprimes(param) {
  let tf = param._1;
  let h = param._0;
  return {
    TAG: "Cons",
    _0: h,
    _1: () => mkprimes(lfilter(x => Primitive_int.mod_(x, h) !== 0, tf()))
  };
}

let primes = mkprimes(lseq(2));

logList(ltake(primes, 10));

function interleave(param, l) {
  let tf = param._1;
  return {
    TAG: "Cons",
    _0: param._0,
    _1: () => interleave(l, tf())
  };
}

logList(ltake(interleave(lseq(20), lseq(30)), 5));

function lconst(n) {
  return {
    TAG: "Cons",
    _0: n,
    _1: () => lconst(n)
  };
}

let interleaved = interleave(lconst(0), lconst(1));

logList(ltake(interleaved, 9));

function allfrom(l) {
  return {
    TAG: "Cons",
    _0: l,
    _1: () => interleave(allfrom({
      hd: 0,
      tl: l
    }), allfrom({
      hd: 1,
      tl: l
    }))
  };
}

let allones = allfrom(/* [] */0);

logList(ltake(allones, 20));

function q1_ldouble(n) {
  return {
    TAG: "Cons",
    _0: n,
    _1: () => q1_ldouble((n << 1))
  };
}

let l = ltake(q1_ldouble(2), 10);

let x = Stdlib_List.toArray(l);

console.log("q1_ldouble", x);

function q2_lnth(_param, _n) {
  while (true) {
    let param = _param;
    let n = _n;
    if (n === 0) {
      return param._0;
    }
    _n = n - 1 | 0;
    _param = param._1();
    continue;
  };
}

let Invalid_argument = /* @__PURE__ */Primitive_exceptions.create("MO_Ch2_Being_Lazy.Invalid_argument");

function q3_lrepeating(l) {
  let lrepeating_inner = (c, l) => {
    if (c !== 0) {
      let t = c.tl;
      let x = c.hd;
      if (t !== 0) {
        return {
          TAG: "Cons",
          _0: x,
          _1: () => lrepeating_inner(t, l)
        };
      } else {
        return {
          TAG: "Cons",
          _0: x,
          _1: () => lrepeating_inner(l, l)
        };
      }
    }
    throw {
      RE_EXN_ID: Invalid_argument,
      _1: "empty list",
      Error: new Error()
    };
  };
  return lrepeating_inner(l, l);
}

let l$1 = ltake(q3_lrepeating({
  hd: 2,
  tl: {
    hd: 8,
    tl: {
      hd: 4,
      tl: /* [] */0
    }
  }
}), 10);

let x$1 = Stdlib_List.toArray(l$1);

console.log("q3_lrepeating", x$1);

function fibonacci_inner(x, y) {
  return {
    TAG: "Cons",
    _0: x,
    _1: () => fibonacci_inner(y, x + y | 0)
  };
}

let q4_fibonacci = fibonacci_inner(0, 1);

let l$2 = ltake(q4_fibonacci, 10);

let x$2 = Stdlib_List.toArray(l$2);

console.log("q4 fibonacci", x$2);

function q5_unleave(param) {
  let match = param._1();
  let t = match._1();
  return [
    {
      TAG: "Cons",
      _0: param._0,
      _1: () => q5_unleave(t)[0]
    },
    {
      TAG: "Cons",
      _0: match._0,
      _1: () => q5_unleave(t)[1]
    }
  ];
}

let match = q5_unleave(lseq(0));

let q5_b = match[1];

let q5_a = match[0];

let l$3 = ltake(q5_a, 10);

let x$3 = Stdlib_List.toArray(l$3);

console.log("q5_unleave", x$3);

let l$4 = ltake(q5_b, 10);

let x$4 = Stdlib_List.toArray(l$4);

console.log("q5_unleave", x$4);

function q6_letter_string(n) {
  if (n <= 26) {
    return Char.escaped(Pervasives.char_of_int(n + 64 | 0));
  } else {
    return q6_letter_string((n - 1 | 0) / 26 | 0) + q6_letter_string((n - 1 | 0) % 26 + 1 | 0);
  }
}

let alphas = lmap(q6_letter_string, lseq(1));

logList(ltake(alphas, 100));

export {
  log,
  logList,
  log2,
  logList2,
  lseq,
  lhd,
  ltl,
  ltake,
  ldrop,
  lmap,
  lfilter,
  cubes,
  mkprimes,
  primes,
  interleave,
  lconst,
  interleaved,
  allfrom,
  allones,
  q1_ldouble,
  q2_lnth,
  Invalid_argument,
  q3_lrepeating,
  q4_fibonacci,
  q5_unleave,
  q5_a,
  q5_b,
  q6_letter_string,
  alphas,
}
/* prim Not a pure module */
