// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Char from "rescript/lib/es6/char.js";
import * as Js_list from "rescript/lib/es6/js_list.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

function log(prim) {
  console.log(prim);
}

function logList(l) {
  var prim = Js_list.toVector(l);
  console.log(prim);
}

function log2(x, y) {
  console.log(y, x);
}

function logList2(l, str) {
  var x = Js_list.toVector(l);
  console.log(str, x);
}

function lseq(n) {
  return {
          TAG: "Cons",
          _0: n,
          _1: (function () {
              return lseq(n + 1 | 0);
            })
        };
}

function lhd(param) {
  return param._0;
}

function ltl(param) {
  return param._1();
}

function ltake(param, n) {
  if (n !== 0) {
    return {
            hd: param._0,
            tl: ltake(param._1(), n - 1 | 0)
          };
  } else {
    return /* [] */0;
  }
}

function ldrop(_ll, _n) {
  while(true) {
    var n = _n;
    var ll = _ll;
    if (n === 0) {
      return ll;
    }
    _n = n - 1 | 0;
    _ll = ll._1();
    continue ;
  };
}

var prim = lseq(3);

console.log(prim);

logList(ltake(lseq(3), 20));

function lmap(f, param) {
  var tf = param._1;
  return {
          TAG: "Cons",
          _0: f(param._0),
          _1: (function () {
              return lmap(f, tf());
            })
        };
}

function lfilter(f, _param) {
  while(true) {
    var param = _param;
    var tf = param._1;
    var h = param._0;
    if (f(h)) {
      return {
              TAG: "Cons",
              _0: h,
              _1: (function(tf){
              return function () {
                return lfilter(f, tf());
              }
              }(tf))
            };
    }
    _param = tf();
    continue ;
  };
}

var cubes = lfilter((function (x) {
        return x % 5 === 0;
      }), lmap((function (x) {
            return Math.imul(Math.imul(x, x), x);
          }), lseq(1)));

logList(ltake(cubes, 20));

function mkprimes(param) {
  var tf = param._1;
  var h = param._0;
  return {
          TAG: "Cons",
          _0: h,
          _1: (function () {
              return mkprimes(lfilter((function (x) {
                                return Caml_int32.mod_(x, h) !== 0;
                              }), tf()));
            })
        };
}

var primes = mkprimes(lseq(2));

logList(ltake(primes, 10));

function interleave(param, l) {
  var tf = param._1;
  return {
          TAG: "Cons",
          _0: param._0,
          _1: (function () {
              return interleave(l, tf());
            })
        };
}

logList(ltake(interleave(lseq(20), lseq(30)), 5));

function lconst(n) {
  return {
          TAG: "Cons",
          _0: n,
          _1: (function () {
              return lconst(n);
            })
        };
}

var interleaved = interleave(lconst(0), lconst(1));

logList(ltake(interleaved, 9));

function allfrom(l) {
  return {
          TAG: "Cons",
          _0: l,
          _1: (function () {
              return interleave(allfrom({
                              hd: 0,
                              tl: l
                            }), allfrom({
                              hd: 1,
                              tl: l
                            }));
            })
        };
}

var allones = allfrom(/* [] */0);

logList(ltake(allones, 20));

function q1_ldouble(n) {
  return {
          TAG: "Cons",
          _0: n,
          _1: (function () {
              return q1_ldouble((n << 1));
            })
        };
}

logList2(ltake(q1_ldouble(2), 10), "q1_ldouble");

function q2_lnth(_param, _n) {
  while(true) {
    var param = _param;
    var n = _n;
    if (n === 0) {
      return param._0;
    }
    _n = n - 1 | 0;
    _param = param._1();
    continue ;
  };
}

var Invalid_argument = /* @__PURE__ */Caml_exceptions.create("MO_Ch2_Being_Lazy.Invalid_argument");

function q3_lrepeating(l) {
  var lrepeating_inner = function (c, l) {
    if (c) {
      var t = c.tl;
      var x = c.hd;
      if (t) {
        return {
                TAG: "Cons",
                _0: x,
                _1: (function () {
                    return lrepeating_inner(t, l);
                  })
              };
      } else {
        return {
                TAG: "Cons",
                _0: x,
                _1: (function () {
                    return lrepeating_inner(l, l);
                  })
              };
      }
    }
    throw {
          RE_EXN_ID: Invalid_argument,
          _1: "empty list",
          Error: new Error()
        };
  };
  return lrepeating_inner(l, l);
}

logList2(ltake(q3_lrepeating({
              hd: 2,
              tl: {
                hd: 8,
                tl: {
                  hd: 4,
                  tl: /* [] */0
                }
              }
            }), 10), "q3_lrepeating");

function fibonacci_inner(x, y) {
  return {
          TAG: "Cons",
          _0: x,
          _1: (function () {
              return fibonacci_inner(y, x + y | 0);
            })
        };
}

var q4_fibonacci = fibonacci_inner(0, 1);

logList2(ltake(q4_fibonacci, 10), "q4 fibonacci");

function q5_unleave(param) {
  var match = param._1();
  var t = match._1();
  return [
          {
            TAG: "Cons",
            _0: param._0,
            _1: (function () {
                return q5_unleave(t)[0];
              })
          },
          {
            TAG: "Cons",
            _0: match._0,
            _1: (function () {
                return q5_unleave(t)[1];
              })
          }
        ];
}

var match = q5_unleave(lseq(0));

var q5_b = match[1];

var q5_a = match[0];

logList2(ltake(q5_a, 10), "q5_unleave");

logList2(ltake(q5_b, 10), "q5_unleave");

function q6_letter_string(n) {
  if (n <= 26) {
    return Char.escaped(PervasivesU.char_of_int(n + 64 | 0));
  } else {
    return q6_letter_string((n - 1 | 0) / 26 | 0) + q6_letter_string((n - 1 | 0) % 26 + 1 | 0);
  }
}

var alphas = lmap(q6_letter_string, lseq(1));

logList(ltake(alphas, 100));

var List;

export {
  List ,
  log ,
  logList ,
  log2 ,
  logList2 ,
  lseq ,
  lhd ,
  ltl ,
  ltake ,
  ldrop ,
  lmap ,
  lfilter ,
  cubes ,
  mkprimes ,
  primes ,
  interleave ,
  lconst ,
  interleaved ,
  allfrom ,
  allones ,
  q1_ldouble ,
  q2_lnth ,
  Invalid_argument ,
  q3_lrepeating ,
  q4_fibonacci ,
  q5_unleave ,
  q5_a ,
  q5_b ,
  q6_letter_string ,
  alphas ,
}
/* prim Not a pure module */
