// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib from "@rescript/runtime/lib/es6/Stdlib.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

let Types = {};

function unit(param) {
  return {
    TAG: "Ok",
    _0: undefined
  };
}

function fromOptionOr(opt, err) {
  if (opt !== undefined) {
    return {
      TAG: "Ok",
      _0: Primitive_option.valFromOption(opt)
    };
  } else {
    return {
      TAG: "Err",
      _0: err
    };
  }
}

function fromOptionOrElse(opt, fn) {
  if (opt !== undefined) {
    return {
      TAG: "Ok",
      _0: Primitive_option.valFromOption(opt)
    };
  } else {
    return {
      TAG: "Err",
      _0: fn()
    };
  }
}

function ok(res) {
  if (res.TAG === "Ok") {
    return Primitive_option.some(res._0);
  }
  
}

function okExn(res, message) {
  if (res.TAG === "Ok") {
    return res._0;
  } else {
    return Stdlib.panic(Stdlib_Option.getOr(message, "R.okExn called for Err value"));
  }
}

function err(res) {
  if (res.TAG === "Ok") {
    return;
  } else {
    return Primitive_option.some(res._0);
  }
}

function errExn(res, message) {
  if (res.TAG === "Ok") {
    return Stdlib.panic(Stdlib_Option.getOr(message, "R.errExn called for Err value"));
  } else {
    return res._0;
  }
}

function getOr(res, err) {
  if (res.TAG === "Ok") {
    return res._0;
  } else {
    return err;
  }
}

function getOrElse(res, fn) {
  if (res.TAG === "Ok") {
    return res._0;
  } else {
    return fn();
  }
}

function map(res, fn) {
  if (res.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: fn(res._0)
    };
  } else {
    return {
      TAG: "Err",
      _0: res._0
    };
  }
}

function mapErr(res, fn) {
  if (res.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: res._0
    };
  } else {
    return {
      TAG: "Err",
      _0: fn(res._0)
    };
  }
}

function andThen(res, fn) {
  if (res.TAG === "Ok") {
    return fn(res._0);
  } else {
    return {
      TAG: "Err",
      _0: res._0
    };
  }
}

function orElse(res, fn) {
  if (res.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: res._0
    };
  } else {
    return fn(res._0);
  }
}

function isOk(res) {
  return res.TAG === "Ok";
}

function isErr(res) {
  return res.TAG !== "Ok";
}

function flatten(res) {
  if (res.TAG !== "Ok") {
    return {
      TAG: "Err",
      _0: res._0
    };
  }
  let x = res._0;
  if (x.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: x._0
    };
  } else {
    return {
      TAG: "Err",
      _0: x._0
    };
  }
}

function transpose(res) {
  if (res.TAG !== "Ok") {
    return {
      TAG: "Err",
      _0: res._0
    };
  }
  let x = res._0;
  if (x !== undefined) {
    return {
      TAG: "Ok",
      _0: Primitive_option.valFromOption(x)
    };
  }
  
}

function tap(res, fn) {
  if (res.TAG !== "Ok") {
    return {
      TAG: "Err",
      _0: res._0
    };
  }
  let x = res._0;
  fn(x);
  return {
    TAG: "Ok",
    _0: x
  };
}

function repeat(_res, fn) {
  while (true) {
    let res = _res;
    if (res.TAG !== "Ok") {
      return {
        TAG: "Err",
        _0: res._0
      };
    }
    let x = fn(res._0);
    if (x.TAG !== "Ok") {
      return {
        TAG: "Err",
        _0: x._0
      };
    }
    let x$1 = x._0;
    if (x$1 === undefined) {
      return res;
    }
    _res = {
      TAG: "Ok",
      _0: Primitive_option.valFromOption(x$1)
    };
    continue;
  };
}

function forEachWithIndex(res, fn) {
  if (res.TAG !== "Ok") {
    return {
      TAG: "Err",
      _0: res._0
    };
  }
  let a = res._0;
  repeat({
    TAG: "Ok",
    _0: 0
  }, i => {
    let v = a[i];
    return map(v !== undefined ? fn(Primitive_option.valFromOption(v), i) : ({
        TAG: "Ok",
        _0: undefined
      }), () => {
      if (i < a.length) {
        return i + 1 | 0;
      }
      
    });
  });
  return {
    TAG: "Ok",
    _0: a
  };
}

function forEach(res, fn) {
  return forEachWithIndex(res, (x, param) => fn(x));
}

export {
  Types,
  unit,
  fromOptionOr,
  fromOptionOrElse,
  ok,
  okExn,
  err,
  errExn,
  getOr,
  getOrElse,
  map,
  mapErr,
  andThen,
  orElse,
  isOk,
  isErr,
  flatten,
  transpose,
  tap,
  repeat,
  forEachWithIndex,
  forEach,
}
/* No side effect */
