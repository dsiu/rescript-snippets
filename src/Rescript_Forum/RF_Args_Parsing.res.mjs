// Generated by ReScript, PLEASE EDIT WITH CARE

import * as RF_Result from "./RF_Result.res.mjs";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

function string(name, requiredOpt) {
  let required = requiredOpt !== undefined ? requiredOpt : false;
  return {
    t: "String",
    name: name,
    minCount: required ? 1 : 0,
    maxCount: 1
  };
}

let InvalidConfig = /* @__PURE__ */Primitive_exceptions.create("RF_Args_Parsing.InvalidConfig");

function checkConfig(args) {
  let argNames = new Set();
  let checkArg = arg => {
    if (argNames.has(arg.name)) {
      throw {
        RE_EXN_ID: InvalidConfig,
        _1: arg.name + ": argument names must be unique",
        Error: new Error()
      };
    }
    argNames.add(arg.name);
    let min = Stdlib_Option.getOr(arg.minCount, 0);
    let max = Stdlib_Option.getOr(arg.maxCount, 1);
    if (min < 0) {
      throw {
        RE_EXN_ID: InvalidConfig,
        _1: arg.name + ": minCount cannot be negative",
        Error: new Error()
      };
    }
    if (max < 1) {
      throw {
        RE_EXN_ID: InvalidConfig,
        _1: arg.name + ": maxCount must be at least 1",
        Error: new Error()
      };
    }
    if (min > max) {
      throw {
        RE_EXN_ID: InvalidConfig,
        _1: arg.name + ": minCount cannot exceed maxCount",
        Error: new Error()
      };
    }
    return {
      TAG: "Ok",
      _0: undefined
    };
  };
  return RF_Result.forEach({
    TAG: "Ok",
    _0: args
  }, checkArg);
}

function parseArgs(argv, args) {
  let argv$1 = argv.toReversed();
  let argMap = Object.fromEntries(args.map(arg => [
    arg.name,
    arg
  ]));
  let argParams = {};
  let parseStringArg = arg => {
    let param = argv$1.pop();
    if (param !== undefined) {
      return {
        TAG: "Ok",
        _0: param
      };
    } else {
      return {
        TAG: "Err",
        _0: {
          TAG: "MissingParam",
          _0: "Argument '" + arg.name + "' requires exactly one parameter"
        }
      };
    }
  };
  let parseArg = argv => {
    let name = argv.pop();
    if (name === undefined) {
      return {
        TAG: "Ok",
        _0: undefined
      };
    }
    let arg = argMap[name];
    let param = parseStringArg(arg);
    return RF_Result.map(RF_Result.tap(param, __x => {
      let p = argParams[arg.name];
      if (p !== undefined) {
        if (Array.isArray(p)) {
          p.push(__x);
          return;
        }
        argParams[arg.name] = [
          p,
          __x
        ];
        return;
      }
      argParams[arg.name] = __x;
    }), param => argv);
  };
  return RF_Result.map(RF_Result.repeat({
    TAG: "Ok",
    _0: argv$1
  }, parseArg), param => argParams);
}

function parse(argv, args) {
  return RF_Result.andThen(RF_Result.andThen({
    TAG: "Ok",
    _0: args
  }, checkConfig), __x => parseArgs(argv, __x));
}

let R;

export {
  R,
  string,
  InvalidConfig,
  checkConfig,
  parseArgs,
  parse,
}
/* No side effect */
