// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/Belt_List.js";
import * as Stdlib_Math from "rescript/lib/es6/Stdlib_Math.js";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function last(_l) {
  while (true) {
    let l = _l;
    if (l === 0) {
      return;
    }
    let rest = l.tl;
    if (rest === 0) {
      return Primitive_option.some(l.hd);
    }
    _l = rest;
    continue;
  };
}

function last_two(_l) {
  while (true) {
    let l = _l;
    if (l === 0) {
      return;
    }
    let match = l.tl;
    if (match === 0) {
      return;
    }
    let rest = match.tl;
    if (rest === 0) {
      return l;
    }
    _l = rest;
    continue;
  };
}

function at(_l, _k) {
  while (true) {
    let k = _k;
    let l = _l;
    if (l === 0) {
      return;
    }
    if (k === 1) {
      return Primitive_option.some(l.hd);
    }
    _k = k - 1 | 0;
    _l = l.tl;
    continue;
  };
}

function length(l) {
  if (l !== 0) {
    return 1 + length(l.tl) | 0;
  } else {
    return 0;
  }
}

function rev(l) {
  let _l$p = l;
  let _acc = /* [] */0;
  while (true) {
    let acc = _acc;
    let l$p = _l$p;
    if (l$p === 0) {
      return acc;
    }
    _acc = {
      hd: l$p.hd,
      tl: acc
    };
    _l$p = l$p.tl;
    continue;
  };
}

function is_palindrome(l) {
  return Belt_List.eq(l, rev(l), (a, b) => a === b);
}

function flatten(l) {
  let aux = (_l$p, _acc) => {
    while (true) {
      let acc = _acc;
      let l$p = _l$p;
      if (l$p === 0) {
        return acc;
      }
      let x = l$p.hd;
      if (x.TAG === "One") {
        _acc = {
          hd: x._0,
          tl: acc
        };
        _l$p = l$p.tl;
        continue;
      }
      _acc = aux(x._0, acc);
      _l$p = l$p.tl;
      continue;
    };
  };
  return rev(aux(l, /* [] */0));
}

function compress(_l) {
  while (true) {
    let l = _l;
    if (l === 0) {
      return l;
    }
    let match = l.tl;
    if (match === 0) {
      return l;
    }
    let t = match.tl;
    let b = match.hd;
    let a = l.hd;
    if (!Primitive_object.equal(a, b)) {
      return {
        hd: a,
        tl: compress({
          hd: b,
          tl: t
        })
      };
    }
    _l = {
      hd: b,
      tl: t
    };
    continue;
  };
}

function pack(l) {
  let aux = (_l, _current, _acc) => {
    while (true) {
      let acc = _acc;
      let current = _current;
      let l = _l;
      if (l === 0) {
        return /* [] */0;
      }
      let match = l.tl;
      let x = l.hd;
      if (match === 0) {
        return {
          hd: {
            hd: x,
            tl: current
          },
          tl: acc
        };
      }
      let t = match.tl;
      let b = match.hd;
      if (Primitive_object.equal(x, b)) {
        _current = {
          hd: x,
          tl: current
        };
        _l = {
          hd: b,
          tl: t
        };
        continue;
      }
      _acc = {
        hd: {
          hd: x,
          tl: current
        },
        tl: acc
      };
      _current = /* [] */0;
      _l = {
        hd: b,
        tl: t
      };
      continue;
    };
  };
  return rev(aux(l, /* [] */0, /* [] */0));
}

function encode(l) {
  let aux = (_l, _count, _acc) => {
    while (true) {
      let acc = _acc;
      let count = _count;
      let l = _l;
      if (l === 0) {
        return /* [] */0;
      }
      let match = l.tl;
      let x = l.hd;
      if (match === 0) {
        return {
          hd: [
            count + 1 | 0,
            x
          ],
          tl: acc
        };
      }
      let t = match.tl;
      let b = match.hd;
      if (Primitive_object.equal(x, b)) {
        _count = count + 1 | 0;
        _l = {
          hd: b,
          tl: t
        };
        continue;
      }
      _acc = {
        hd: [
          count + 1 | 0,
          x
        ],
        tl: acc
      };
      _count = 0;
      _l = {
        hd: b,
        tl: t
      };
      continue;
    };
  };
  return rev(aux(l, 0, /* [] */0));
}

function encode_11(l) {
  let create_tuple = (cnt, elem) => {
    if (cnt === 1) {
      return {
        TAG: "One",
        _0: elem
      };
    } else {
      return {
        TAG: "Many",
        _0: cnt,
        _1: elem
      };
    }
  };
  let aux = (_l, _count, _acc) => {
    while (true) {
      let acc = _acc;
      let count = _count;
      let l = _l;
      if (l === 0) {
        return /* [] */0;
      }
      let match = l.tl;
      let x = l.hd;
      if (match === 0) {
        return {
          hd: create_tuple(count + 1 | 0, x),
          tl: acc
        };
      }
      let t = match.tl;
      let b = match.hd;
      if (Primitive_object.equal(x, b)) {
        _count = count + 1 | 0;
        _l = {
          hd: b,
          tl: t
        };
        continue;
      }
      _acc = {
        hd: create_tuple(count + 1 | 0, x),
        tl: acc
      };
      _count = 0;
      _l = {
        hd: b,
        tl: t
      };
      continue;
    };
  };
  return rev(aux(l, 0, /* [] */0));
}

function decode(l) {
  let many = (_acc, _n, x) => {
    while (true) {
      let n = _n;
      let acc = _acc;
      if (n === 0) {
        return acc;
      }
      _n = n - 1 | 0;
      _acc = {
        hd: x,
        tl: acc
      };
      continue;
    };
  };
  let _l = rev(l);
  let _acc = /* [] */0;
  while (true) {
    let acc = _acc;
    let l$1 = _l;
    if (l$1 === 0) {
      return acc;
    }
    let x = l$1.hd;
    if (x.TAG === "One") {
      _acc = {
        hd: x._0,
        tl: acc
      };
      _l = l$1.tl;
      continue;
    }
    _acc = many(acc, x._0, x._1);
    _l = l$1.tl;
    continue;
  };
}

function encode_13(l) {
  let rle = (count, x) => {
    if (count !== 0) {
      return {
        TAG: "Many",
        _0: count + 1 | 0,
        _1: x
      };
    } else {
      return {
        TAG: "One",
        _0: x
      };
    }
  };
  let aux = (_l, _count, _acc) => {
    while (true) {
      let acc = _acc;
      let count = _count;
      let l = _l;
      if (l === 0) {
        return /* [] */0;
      }
      let match = l.tl;
      let x = l.hd;
      if (match === 0) {
        return {
          hd: rle(count, x),
          tl: acc
        };
      }
      let t = match.tl;
      let b = match.hd;
      if (Primitive_object.equal(x, b)) {
        _count = count + 1 | 0;
        _l = {
          hd: b,
          tl: t
        };
        continue;
      }
      _acc = {
        hd: rle(count, x),
        tl: acc
      };
      _count = 0;
      _l = {
        hd: b,
        tl: t
      };
      continue;
    };
  };
  return rev(aux(l, 0, /* [] */0));
}

function duplicate(l) {
  if (l === 0) {
    return /* [] */0;
  }
  let h = l.hd;
  return {
    hd: h,
    tl: {
      hd: h,
      tl: duplicate(l.tl)
    }
  };
}

function replicate(l, n) {
  let prepend = (x, _n, _acc) => {
    while (true) {
      let acc = _acc;
      let n = _n;
      if (n === 0) {
        return acc;
      }
      _acc = {
        hd: x,
        tl: acc
      };
      _n = n - 1 | 0;
      continue;
    };
  };
  let _l = rev(l);
  let _acc = /* [] */0;
  while (true) {
    let acc = _acc;
    let l$1 = _l;
    if (l$1 === 0) {
      return acc;
    }
    _acc = prepend(l$1.hd, n, acc);
    _l = l$1.tl;
    continue;
  };
}

function drop(l, n) {
  let aux = (_l, _i) => {
    while (true) {
      let i = _i;
      let l = _l;
      if (l === 0) {
        return /* [] */0;
      }
      let t = l.tl;
      if (i !== n) {
        return {
          hd: l.hd,
          tl: aux(t, i + 1 | 0)
        };
      }
      _i = 1;
      _l = t;
      continue;
    };
  };
  return aux(l, 1);
}

function split(l, n) {
  let _l = l;
  let _i = n;
  let _acc = /* [] */0;
  while (true) {
    let acc = _acc;
    let i = _i;
    let l$1 = _l;
    if (l$1 === 0) {
      return [
        rev(acc),
        /* [] */0
      ];
    }
    if (i === 0) {
      return [
        rev(acc),
        l$1
      ];
    }
    _acc = {
      hd: l$1.hd,
      tl: acc
    };
    _i = i - 1 | 0;
    _l = l$1.tl;
    continue;
  };
}

function slice(l, i, k) {
  let take = (l, n) => {
    if (l !== 0 && n !== 0) {
      return {
        hd: l.hd,
        tl: take(l.tl, n - 1 | 0)
      };
    } else {
      return /* [] */0;
    }
  };
  let drop = (_l, _n) => {
    while (true) {
      let n = _n;
      let l = _l;
      if (l === 0) {
        return /* [] */0;
      }
      if (n === 0) {
        return l;
      }
      _n = n - 1 | 0;
      _l = l.tl;
      continue;
    };
  };
  return take(drop(l, i), (k - i | 0) + 1 | 0);
}

function rotate(l, n) {
  let len = length(l);
  let n$1 = len === 0 ? 0 : Primitive_int.mod_(Primitive_int.mod_(n, len) + len | 0, len);
  if (n$1 === 0) {
    return l;
  }
  let match = split(l, n$1);
  return Belt_List.concat(match[1], match[0]);
}

function remove_at(l, n) {
  if (l === 0) {
    return /* [] */0;
  }
  let t = l.tl;
  if (n === 0) {
    return t;
  } else {
    return {
      hd: l.hd,
      tl: remove_at(t, n - 1 | 0)
    };
  }
}

function insert_at(l, n, x) {
  if (l === 0) {
    return {
      hd: x,
      tl: /* [] */0
    };
  }
  let t = l.tl;
  let h = l.hd;
  if (n === 0) {
    return {
      hd: x,
      tl: {
        hd: h,
        tl: t
      }
    };
  } else {
    return {
      hd: h,
      tl: insert_at(t, n - 1 | 0, x)
    };
  }
}

function range(a, b) {
  let aux = (a, b) => {
    if (a > b) {
      return /* [] */0;
    } else {
      return {
        hd: a,
        tl: aux(a + 1 | 0, b)
      };
    }
  };
  if (a > b) {
    return aux(b, a);
  } else {
    return aux(a, b);
  }
}

function range_tail_recur(a, b) {
  let aux = (_acc, _high, low) => {
    while (true) {
      let high = _high;
      let acc = _acc;
      if (high < low) {
        return acc;
      }
      _high = high - 1 | 0;
      _acc = {
        hd: high,
        tl: acc
      };
      continue;
    };
  };
  if (b > a) {
    return aux(/* [] */0, b, a);
  } else {
    return aux(/* [] */0, a, b);
  }
}

function rand_select(list, n) {
  let extract_rand = (list, len) => {
    let _l = list;
    let _acc = /* [] */0;
    let _n = Stdlib_Math.Int.random(0, len);
    while (true) {
      let n = _n;
      let acc = _acc;
      let l = _l;
      if (l !== 0) {
        let t = l.tl;
        let h = l.hd;
        if (n === 0) {
          return [
            h,
            Belt_List.concat(acc, t)
          ];
        }
        _n = n - 1 | 0;
        _acc = {
          hd: h,
          tl: acc
        };
        _l = t;
        continue;
      }
      throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
    };
  };
  let len = length(list);
  let _n = Primitive_int.min(n, len);
  let _acc = /* [] */0;
  let _list = list;
  let _len = len;
  while (true) {
    let len$1 = _len;
    let list$1 = _list;
    let acc = _acc;
    let n$1 = _n;
    if (n$1 === 0) {
      return acc;
    }
    let match = extract_rand(list$1, len$1);
    _len = len$1 - 1 | 0;
    _list = match[1];
    _acc = {
      hd: match[0],
      tl: acc
    };
    _n = n$1 - 1 | 0;
    continue;
  };
}

export {
  last,
  last_two,
  at,
  length,
  rev,
  is_palindrome,
  flatten,
  compress,
  pack,
  encode,
  encode_11,
  decode,
  encode_13,
  duplicate,
  replicate,
  drop,
  split,
  slice,
  rotate,
  remove_at,
  insert_at,
  range,
  range_tail_recur,
  rand_select,
}
/* No side effect */
