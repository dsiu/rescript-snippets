// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function last(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    var rest = l.tl;
    if (!rest) {
      return Caml_option.some(l.hd);
    }
    _l = rest;
    continue ;
  };
}

function last_two(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    var match = l.tl;
    if (!match) {
      return ;
    }
    var rest = match.tl;
    if (!rest) {
      return l;
    }
    _l = rest;
    continue ;
  };
}

function at(_l, _k) {
  while(true) {
    var k = _k;
    var l = _l;
    if (!l) {
      return ;
    }
    if (k === 1) {
      return Caml_option.some(l.hd);
    }
    _k = k - 1 | 0;
    _l = l.tl;
    continue ;
  };
}

function length(l) {
  if (l) {
    return 1 + length(l.tl) | 0;
  } else {
    return 0;
  }
}

function rev(l) {
  var _l$p = l;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l$p = _l$p;
    if (!l$p) {
      return acc;
    }
    _acc = {
      hd: l$p.hd,
      tl: acc
    };
    _l$p = l$p.tl;
    continue ;
  };
}

function is_palindrome(l) {
  return Belt_List.eq(l, rev(l), (function (a, b) {
                return a === b;
              }));
}

function flatten(l) {
  var aux = function (_l$p, _acc) {
    while(true) {
      var acc = _acc;
      var l$p = _l$p;
      if (!l$p) {
        return acc;
      }
      var x = l$p.hd;
      if (x.TAG === /* One */0) {
        _acc = {
          hd: x._0,
          tl: acc
        };
        _l$p = l$p.tl;
        continue ;
      }
      _acc = aux(x._0, acc);
      _l$p = l$p.tl;
      continue ;
    };
  };
  return rev(aux(l, /* [] */0));
}

function compress(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return l;
    }
    var match = l.tl;
    if (!match) {
      return l;
    }
    var t = match.tl;
    var b = match.hd;
    var a = l.hd;
    if (!Caml_obj.caml_equal(a, b)) {
      return {
              hd: a,
              tl: compress({
                    hd: b,
                    tl: t
                  })
            };
    }
    _l = {
      hd: b,
      tl: t
    };
    continue ;
  };
}

function pack(l) {
  var aux = function (_l, _current, _acc) {
    while(true) {
      var acc = _acc;
      var current = _current;
      var l = _l;
      if (!l) {
        return /* [] */0;
      }
      var match = l.tl;
      var x = l.hd;
      if (!match) {
        return {
                hd: {
                  hd: x,
                  tl: current
                },
                tl: acc
              };
      }
      var t = match.tl;
      var b = match.hd;
      if (Caml_obj.caml_equal(x, b)) {
        _current = {
          hd: x,
          tl: current
        };
        _l = {
          hd: b,
          tl: t
        };
        continue ;
      }
      _acc = {
        hd: {
          hd: x,
          tl: current
        },
        tl: acc
      };
      _current = /* [] */0;
      _l = {
        hd: b,
        tl: t
      };
      continue ;
    };
  };
  return rev(aux(l, /* [] */0, /* [] */0));
}

function encode(l) {
  var aux = function (_l, _count, _acc) {
    while(true) {
      var acc = _acc;
      var count = _count;
      var l = _l;
      if (!l) {
        return /* [] */0;
      }
      var match = l.tl;
      var x = l.hd;
      if (!match) {
        return {
                hd: [
                  count + 1 | 0,
                  x
                ],
                tl: acc
              };
      }
      var t = match.tl;
      var b = match.hd;
      if (Caml_obj.caml_equal(x, b)) {
        _count = count + 1 | 0;
        _l = {
          hd: b,
          tl: t
        };
        continue ;
      }
      _acc = {
        hd: [
          count + 1 | 0,
          x
        ],
        tl: acc
      };
      _count = 0;
      _l = {
        hd: b,
        tl: t
      };
      continue ;
    };
  };
  return rev(aux(l, 0, /* [] */0));
}

exports.last = last;
exports.last_two = last_two;
exports.at = at;
exports.length = length;
exports.rev = rev;
exports.is_palindrome = is_palindrome;
exports.flatten = flatten;
exports.compress = compress;
exports.pack = pack;
exports.encode = encode;
/* No side effect */
