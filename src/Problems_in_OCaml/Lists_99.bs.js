// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function last(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    var rest = l.tl;
    if (!rest) {
      return Caml_option.some(l.hd);
    }
    _l = rest;
    continue ;
  };
}

function last_two(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return ;
    }
    var match = l.tl;
    if (!match) {
      return ;
    }
    var rest = match.tl;
    if (!rest) {
      return l;
    }
    _l = rest;
    continue ;
  };
}

function at(_l, _k) {
  while(true) {
    var k = _k;
    var l = _l;
    if (!l) {
      return ;
    }
    if (k === 1) {
      return Caml_option.some(l.hd);
    }
    _k = k - 1 | 0;
    _l = l.tl;
    continue ;
  };
}

function length(l) {
  if (l) {
    return 1 + length(l.tl) | 0;
  } else {
    return 0;
  }
}

function rev(l) {
  var _l$p = l;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l$p = _l$p;
    if (!l$p) {
      return acc;
    }
    _acc = {
      hd: l$p.hd,
      tl: acc
    };
    _l$p = l$p.tl;
    continue ;
  };
}

function is_palindrome(l) {
  return Belt_List.eq(l, rev(l), (function (a, b) {
                return a === b;
              }));
}

function flatten(l) {
  var aux = function (_l$p, _acc) {
    while(true) {
      var acc = _acc;
      var l$p = _l$p;
      if (!l$p) {
        return acc;
      }
      var x = l$p.hd;
      if (x.TAG === /* One */0) {
        _acc = {
          hd: x._0,
          tl: acc
        };
        _l$p = l$p.tl;
        continue ;
      }
      _acc = aux(x._0, acc);
      _l$p = l$p.tl;
      continue ;
    };
  };
  return rev(aux(l, /* [] */0));
}

function compress(_l) {
  while(true) {
    var l = _l;
    if (!l) {
      return l;
    }
    var match = l.tl;
    if (!match) {
      return l;
    }
    var t = match.tl;
    var b = match.hd;
    var a = l.hd;
    if (!Caml_obj.caml_equal(a, b)) {
      return {
              hd: a,
              tl: compress({
                    hd: b,
                    tl: t
                  })
            };
    }
    _l = {
      hd: b,
      tl: t
    };
    continue ;
  };
}

function pack(l) {
  var aux = function (_l, _current, _acc) {
    while(true) {
      var acc = _acc;
      var current = _current;
      var l = _l;
      if (!l) {
        return /* [] */0;
      }
      var match = l.tl;
      var x = l.hd;
      if (!match) {
        return {
                hd: {
                  hd: x,
                  tl: current
                },
                tl: acc
              };
      }
      var t = match.tl;
      var b = match.hd;
      if (Caml_obj.caml_equal(x, b)) {
        _current = {
          hd: x,
          tl: current
        };
        _l = {
          hd: b,
          tl: t
        };
        continue ;
      }
      _acc = {
        hd: {
          hd: x,
          tl: current
        },
        tl: acc
      };
      _current = /* [] */0;
      _l = {
        hd: b,
        tl: t
      };
      continue ;
    };
  };
  return rev(aux(l, /* [] */0, /* [] */0));
}

function encode(l) {
  var aux = function (_l, _count, _acc) {
    while(true) {
      var acc = _acc;
      var count = _count;
      var l = _l;
      if (!l) {
        return /* [] */0;
      }
      var match = l.tl;
      var x = l.hd;
      if (!match) {
        return {
                hd: [
                  count + 1 | 0,
                  x
                ],
                tl: acc
              };
      }
      var t = match.tl;
      var b = match.hd;
      if (Caml_obj.caml_equal(x, b)) {
        _count = count + 1 | 0;
        _l = {
          hd: b,
          tl: t
        };
        continue ;
      }
      _acc = {
        hd: [
          count + 1 | 0,
          x
        ],
        tl: acc
      };
      _count = 0;
      _l = {
        hd: b,
        tl: t
      };
      continue ;
    };
  };
  return rev(aux(l, 0, /* [] */0));
}

function encode_11(l) {
  var create_tuple = function (cnt, elem) {
    if (cnt === 1) {
      return {
              TAG: /* One */0,
              _0: elem
            };
    } else {
      return {
              TAG: /* Many */1,
              _0: cnt,
              _1: elem
            };
    }
  };
  var aux = function (_l, _count, _acc) {
    while(true) {
      var acc = _acc;
      var count = _count;
      var l = _l;
      if (!l) {
        return /* [] */0;
      }
      var match = l.tl;
      var x = l.hd;
      if (!match) {
        return {
                hd: create_tuple(count + 1 | 0, x),
                tl: acc
              };
      }
      var t = match.tl;
      var b = match.hd;
      if (Caml_obj.caml_equal(x, b)) {
        _count = count + 1 | 0;
        _l = {
          hd: b,
          tl: t
        };
        continue ;
      }
      _acc = {
        hd: create_tuple(count + 1 | 0, x),
        tl: acc
      };
      _count = 0;
      _l = {
        hd: b,
        tl: t
      };
      continue ;
    };
  };
  return rev(aux(l, 0, /* [] */0));
}

function decode(l) {
  var many = function (_acc, _n, x) {
    while(true) {
      var n = _n;
      var acc = _acc;
      if (n === 0) {
        return acc;
      }
      _n = n - 1 | 0;
      _acc = {
        hd: x,
        tl: acc
      };
      continue ;
    };
  };
  var _l = rev(l);
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l$1 = _l;
    if (!l$1) {
      return acc;
    }
    var x = l$1.hd;
    if (x.TAG === /* One */0) {
      _acc = {
        hd: x._0,
        tl: acc
      };
      _l = l$1.tl;
      continue ;
    }
    _acc = many(acc, x._0, x._1);
    _l = l$1.tl;
    continue ;
  };
}

function encode_13(l) {
  var rle = function (count, x) {
    if (count !== 0) {
      return {
              TAG: /* Many */1,
              _0: count + 1 | 0,
              _1: x
            };
    } else {
      return {
              TAG: /* One */0,
              _0: x
            };
    }
  };
  var aux = function (_l, _count, _acc) {
    while(true) {
      var acc = _acc;
      var count = _count;
      var l = _l;
      if (!l) {
        return /* [] */0;
      }
      var match = l.tl;
      var x = l.hd;
      if (!match) {
        return {
                hd: rle(count, x),
                tl: acc
              };
      }
      var t = match.tl;
      var b = match.hd;
      if (Caml_obj.caml_equal(x, b)) {
        _count = count + 1 | 0;
        _l = {
          hd: b,
          tl: t
        };
        continue ;
      }
      _acc = {
        hd: rle(count, x),
        tl: acc
      };
      _count = 0;
      _l = {
        hd: b,
        tl: t
      };
      continue ;
    };
  };
  return rev(aux(l, 0, /* [] */0));
}

function duplicate(l) {
  if (!l) {
    return /* [] */0;
  }
  var h = l.hd;
  return {
          hd: h,
          tl: {
            hd: h,
            tl: duplicate(l.tl)
          }
        };
}

function replicate(l, n) {
  var prepend = function (x, _n, _acc) {
    while(true) {
      var acc = _acc;
      var n = _n;
      if (n === 0) {
        return acc;
      }
      _acc = {
        hd: x,
        tl: acc
      };
      _n = n - 1 | 0;
      continue ;
    };
  };
  var _l = rev(l);
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l$1 = _l;
    if (!l$1) {
      return acc;
    }
    _acc = prepend(l$1.hd, n, acc);
    _l = l$1.tl;
    continue ;
  };
}

function drop(l, n) {
  var aux = function (_l, _i) {
    while(true) {
      var i = _i;
      var l = _l;
      if (!l) {
        return /* [] */0;
      }
      var t = l.tl;
      if (i !== n) {
        return {
                hd: l.hd,
                tl: aux(t, i + 1 | 0)
              };
      }
      _i = 1;
      _l = t;
      continue ;
    };
  };
  return aux(l, 1);
}

function split(l, n) {
  var _l = l;
  var _i = n;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var i = _i;
    var l$1 = _l;
    if (!l$1) {
      return [
              rev(acc),
              /* [] */0
            ];
    }
    if (i === 0) {
      return [
              rev(acc),
              l$1
            ];
    }
    _acc = {
      hd: l$1.hd,
      tl: acc
    };
    _i = i - 1 | 0;
    _l = l$1.tl;
    continue ;
  };
}

function slice(l, i, k) {
  var take = function (l, n) {
    if (l && n !== 0) {
      return {
              hd: l.hd,
              tl: take(l.tl, n - 1 | 0)
            };
    } else {
      return /* [] */0;
    }
  };
  var drop = function (_l, _n) {
    while(true) {
      var n = _n;
      var l = _l;
      if (!l) {
        return /* [] */0;
      }
      if (n === 0) {
        return l;
      }
      _n = n - 1 | 0;
      _l = l.tl;
      continue ;
    };
  };
  return take(drop(l, i), (k - i | 0) + 1 | 0);
}

function rotate(l, n) {
  var len = length(l);
  var n$1 = len === 0 ? 0 : Caml_int32.mod_(Caml_int32.mod_(n, len) + len | 0, len);
  if (n$1 === 0) {
    return l;
  }
  var match = split(l, n$1);
  return Belt_List.concat(match[1], match[0]);
}

exports.last = last;
exports.last_two = last_two;
exports.at = at;
exports.length = length;
exports.rev = rev;
exports.is_palindrome = is_palindrome;
exports.flatten = flatten;
exports.compress = compress;
exports.pack = pack;
exports.encode = encode;
exports.encode_11 = encode_11;
exports.decode = decode;
exports.encode_13 = encode_13;
exports.duplicate = duplicate;
exports.replicate = replicate;
exports.drop = drop;
exports.split = split;
exports.slice = slice;
exports.rotate = rotate;
/* No side effect */
