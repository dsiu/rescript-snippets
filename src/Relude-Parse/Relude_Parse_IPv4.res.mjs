// Generated by ReScript, PLEASE EDIT WITH CARE

import * as ReludeParse_Parser from "rescript-relude-parse/src/ReludeParse_Parser.res.mjs";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function make(a, b, c, d) {
  return {
    TAG: "IPv4",
    _0: a,
    _1: b,
    _2: c,
    _3: d
  };
}

function makeCurried(a) {
  return b => (c => (d => ({
    TAG: "IPv4",
    _0: a,
    _1: b,
    _2: c,
    _3: d
  })));
}

let parseWithTuple = ReludeParse_Parser.mapTuple4(make, [
  ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.anyPositiveShort, ReludeParse_Parser.str(".")),
  ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.anyPositiveShort, ReludeParse_Parser.str(".")),
  ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.anyPositiveShort, ReludeParse_Parser.str(".")),
  ReludeParse_Parser.anyPositiveShort
]);

let __x = ReludeParse_Parser.runParser("127.0.0.1", parseWithTuple);

console.log("with tuple\n", __x);

let parseWithNestedFlatMaps = ReludeParse_Parser.Infix.$great$great$eq(ReludeParse_Parser.anyPositiveShort, a => ReludeParse_Parser.Infix.$great$great$eq(ReludeParse_Parser.str("."), param => ReludeParse_Parser.Infix.$great$great$eq(ReludeParse_Parser.anyPositiveShort, b => ReludeParse_Parser.Infix.$great$great$eq(ReludeParse_Parser.str("."), param => ReludeParse_Parser.Infix.$great$great$eq(ReludeParse_Parser.anyPositiveShort, c => ReludeParse_Parser.Infix.$great$great$eq(ReludeParse_Parser.str("."), param => ReludeParse_Parser.Infix.$less$$$great(ReludeParse_Parser.anyPositiveShort, d => make(a, b, c, d))))))));

let __x$1 = ReludeParse_Parser.runParser("127.0.0.1", parseWithNestedFlatMaps);

console.log("with nested flatMaps\n", __x$1);

let parseWithMonadicFlow = ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$less$star$great(ReludeParse_Parser.Infix.$less$star(ReludeParse_Parser.Infix.$less$$great(makeCurried, ReludeParse_Parser.anyPositiveShort), ReludeParse_Parser.str(".")), ReludeParse_Parser.anyPositiveShort), ReludeParse_Parser.str(".")), ReludeParse_Parser.anyPositiveShort), ReludeParse_Parser.str(".")), ReludeParse_Parser.anyPositiveShort);

let __x$2 = ReludeParse_Parser.runParser("127.0.0.1", parseWithMonadicFlow);

console.log("with monadic flow\n", __x$2);

let parseWithSepBy = ReludeParse_Parser.Infix.$great$great$eq(ReludeParse_Parser.sepBy(ReludeParse_Parser.str("."), ReludeParse_Parser.anyPositiveShort), shorts => {
  if (!shorts) {
    return ReludeParse_Parser.fail("Expected exactly 4 shorts separated by .");
  }
  let match = shorts.tl;
  if (!match) {
    return ReludeParse_Parser.fail("Expected exactly 4 shorts separated by .");
  }
  let match$1 = match.tl;
  if (!match$1) {
    return ReludeParse_Parser.fail("Expected exactly 4 shorts separated by .");
  }
  let match$2 = match$1.tl;
  if (match$2 && !match$2.tl) {
    return ReludeParse_Parser.pure(make(shorts.hd, match.hd, match$1.hd, match$2.hd));
  } else {
    return ReludeParse_Parser.fail("Expected exactly 4 shorts separated by .");
  }
});

let __x$3 = ReludeParse_Parser.runParser("127.0.0.1", parseWithSepBy);

console.log("with sepBy\n", __x$3);

let P;

export {
  log,
  log2,
  P,
  make,
  makeCurried,
  parseWithTuple,
  parseWithNestedFlatMaps,
  parseWithMonadicFlow,
  parseWithSepBy,
}
/* parseWithTuple Not a pure module */
