// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as $$Array from "rescript/lib/es6/array.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function modify(l, f, a) {
  var value = Curry._1(l.get, a);
  var new_value = Curry._1(f, value);
  return Curry._2(l.set, new_value, a);
}

function _get(a, l) {
  return Curry._1(l.get, a);
}

function _set(v, a, l) {
  return Curry._2(l.set, v, a);
}

function _modify(f, l) {
  return function (param) {
    return modify(l, f, param);
  };
}

function compose(l1, l2) {
  var partial_arg = l1.get;
  var partial_arg$1 = l2.get;
  var partial_arg$2 = l1.set;
  return {
          get: (function (param) {
              return Curry._1(partial_arg, Curry._1(partial_arg$1, param));
            }),
          set: (function (param) {
              var partial_arg$3 = Curry._1(partial_arg$2, param);
              return function (param) {
                return modify(l2, partial_arg$3, param);
              };
            })
        };
}

function pair(l1, l2) {
  return {
          get: (function (param) {
              return [
                      Curry._1(l1.get, param[0]),
                      Curry._1(l2.get, param[1])
                    ];
            }),
          set: (function (param, param$1) {
              return [
                      Curry._2(l1.set, param[0], param$1[0]),
                      Curry._2(l2.set, param[1], param$1[1])
                    ];
            })
        };
}

function pair3(l1, l2, l3) {
  return {
          get: (function (param) {
              return [
                      Curry._1(l1.get, param[0]),
                      Curry._1(l2.get, param[1]),
                      Curry._1(l3.get, param[2])
                    ];
            }),
          set: (function (param, param$1) {
              return [
                      Curry._2(l1.set, param[0], param$1[0]),
                      Curry._2(l2.set, param[1], param$1[1]),
                      Curry._2(l3.set, param[2], param$1[2])
                    ];
            })
        };
}

function cond(pred, lt, lf) {
  var choose = function (a) {
    if (Curry._1(pred, a)) {
      return lt;
    } else {
      return lf;
    }
  };
  return {
          get: (function (a) {
              var l = choose(a);
              return Curry._1(l.get, a);
            }),
          set: (function (b, a) {
              var l = choose(a);
              return Curry._2(l.set, b, a);
            })
        };
}

function get_state(l, a) {
  return [
          Curry._1(l.get, a),
          a
        ];
}

function put_state(l, v, a) {
  return [
          undefined,
          Curry._2(l.set, v, a)
        ];
}

function modify_state(l, f, a) {
  return [
          undefined,
          modify(l, f, a)
        ];
}

function ignore_get(prim) {
  
}

function ignore_set(param, a) {
  return a;
}

var ignore = {
  get: ignore_get,
  set: ignore_set
};

function id_get(a) {
  return a;
}

function id_set(b, param) {
  return b;
}

var id = {
  get: id_get,
  set: id_set
};

function first_get(prim) {
  return prim[0];
}

function first_set(v, a) {
  return [
          v,
          a[1]
        ];
}

var first = {
  get: first_get,
  set: first_set
};

function second_get(prim) {
  return prim[1];
}

function second_set(v, a) {
  return [
          a[0],
          v
        ];
}

var second = {
  get: second_get,
  set: second_set
};

function head_set(v, xs) {
  return {
          hd: v,
          tl: List.tl(xs)
        };
}

var head = {
  get: List.hd,
  set: head_set
};

function tail_set(v, xs) {
  return {
          hd: List.hd(xs),
          tl: v
        };
}

var tail = {
  get: List.tl,
  set: tail_set
};

function for_hash(key) {
  return {
          get: (function (h) {
              try {
                return Caml_option.some(Hashtbl.find(h, key));
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.RE_EXN_ID === "Not_found") {
                  return ;
                }
                throw exn;
              }
            }),
          set: (function (v, h) {
              if (v !== undefined) {
                Hashtbl.add(h, key, Caml_option.valFromOption(v));
                return h;
              } else {
                Hashtbl.remove(h, key);
                return h;
              }
            })
        };
}

function for_assoc(key) {
  return {
          get: (function (l) {
              try {
                return Caml_option.some(List.assoc(key, l));
              }
              catch (raw_exn){
                var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                if (exn.RE_EXN_ID === "Not_found") {
                  return ;
                }
                throw exn;
              }
            }),
          set: (function (v, l) {
              if (v === undefined) {
                return List.remove_assoc(key, l);
              }
              var l$p = List.remove_assoc(key, l);
              return {
                      hd: [
                        key,
                        Caml_option.valFromOption(v)
                      ],
                      tl: l$p
                    };
            })
        };
}

function for_array(i) {
  return {
          get: (function (a) {
              return Caml_array.get(a, i);
            }),
          set: (function (v, a) {
              var a$p = $$Array.copy(a);
              Caml_array.set(a$p, i, v);
              return a$p;
            })
        };
}

function for_list(i) {
  return {
          get: (function (xs) {
              return List.nth(xs, i);
            }),
          set: (function (v, xs) {
              return List.rev(List.fold_left((function (param, x) {
                                  var j = param[1];
                                  var xs$p = param[0];
                                  return [
                                          i === j ? ({
                                                hd: v,
                                                tl: xs$p
                                              }) : ({
                                                hd: x,
                                                tl: xs$p
                                              }),
                                          j + 1 | 0
                                        ];
                                }), [
                                /* [] */0,
                                0
                              ], xs)[0]);
            })
        };
}

function option_get_get(x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function option_get_set(v, param) {
  return Caml_option.some(v);
}

var option_get = {
  get: option_get_get,
  set: option_get_set
};

function list_map(l) {
  var partial_arg = l.get;
  var partial_arg$1 = l.set;
  return {
          get: (function (param) {
              return List.map(partial_arg, param);
            }),
          set: (function (param, param$1) {
              return List.map2(partial_arg$1, param, param$1);
            })
        };
}

function xmap(f, g, l) {
  var partial_arg = l.get;
  var partial_arg$1 = l.set;
  return {
          get: (function (param) {
              return Curry._1(f, Curry._1(partial_arg, param));
            }),
          set: (function (param) {
              return Curry._1(partial_arg$1, Curry._1(g, param));
            })
        };
}

function $caret$eq(l, v, a) {
  return Curry._2(l.set, v, a);
}

function $pipe$neg$neg(l1, l2) {
  return compose(l2, l1);
}

var $star$star$star = pair;

function $plus$eq(l, v) {
  return function (param) {
    return modify(l, (function (param) {
                  return v + param | 0;
                }), param);
  };
}

function $neg$eq(l, v) {
  var partial_arg = -v | 0;
  var partial_arg$1 = function (param) {
    return partial_arg + param | 0;
  };
  return function (param) {
    return modify(l, partial_arg$1, param);
  };
}

var Infix = {
  $caret$eq: $caret$eq,
  $caret$percent$eq: modify,
  $pipe$neg$neg: $pipe$neg$neg,
  $neg$neg$pipe: compose,
  $star$star$star: $star$star$star,
  $plus$eq: $plus$eq,
  $neg$eq: $neg$eq
};

function $caret$eq$bang(l, v) {
  return function (param) {
    return put_state(l, v, param);
  };
}

function $plus$eq$bang(l, v) {
  return function (param) {
    return modify_state(l, (function (param) {
                  return v + param | 0;
                }), param);
  };
}

function $neg$eq$bang(l, v) {
  var partial_arg = -v | 0;
  var partial_arg$1 = function (param) {
    return partial_arg + param | 0;
  };
  return function (param) {
    return modify_state(l, partial_arg$1, param);
  };
}

function $at$eq$bang(l, v) {
  return function (param) {
    return modify_state(l, (function (a) {
                  return Pervasives.$at(a, v);
                }), param);
  };
}

var StateInfix = {
  $caret$eq$bang: $caret$eq$bang,
  $plus$eq$bang: $plus$eq$bang,
  $neg$eq$bang: $neg$eq$bang,
  $at$eq$bang: $at$eq$bang
};

export {
  modify ,
  _get ,
  _set ,
  _modify ,
  compose ,
  pair ,
  pair3 ,
  cond ,
  get_state ,
  put_state ,
  modify_state ,
  ignore ,
  id ,
  first ,
  second ,
  head ,
  tail ,
  for_hash ,
  for_assoc ,
  for_array ,
  for_list ,
  option_get ,
  list_map ,
  xmap ,
  Infix ,
  StateInfix ,
}
/* No side effect */
