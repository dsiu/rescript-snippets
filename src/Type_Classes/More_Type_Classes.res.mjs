// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";
import * as Pervasives from "@rescript/runtime/lib/es6/Pervasives.js";
import * as Stdlib_List from "@rescript/runtime/lib/es6/Stdlib_List.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function compose(f, g, x) {
  return f(g(x));
}

function compose_right(f, g, x) {
  return g(f(x));
}

function id(x) {
  return x;
}

function $$const(x) {
  return param => x;
}

function map(f, x) {
  return Stdlib_List.map(x, f);
}

let ListFunctor = {
  map: map
};

function TestFunctor(F) {
  let test_id = x => Primitive_object.equal(F.map(id, x), x);
  let test_compose = xs => {
    let f = x => x % 2;
    let g = x => x - 1 | 0;
    return Primitive_object.equal(F.map(extra => (extra - 1 | 0) % 2, xs), F.map(f, F.map(g, xs)));
  };
  return {
    test_id: test_id,
    test_compose: test_compose
  };
}

function test_id(x) {
  return Primitive_object.equal(Stdlib_List.map(x, id), x);
}

function test_compose(xs) {
  let f = x => x % 2;
  let g = x => x - 1 | 0;
  return Primitive_object.equal(Stdlib_List.map(xs, extra => (extra - 1 | 0) % 2), Stdlib_List.map(Stdlib_List.map(xs, g), f));
}

let TFL = {
  test_id: test_id,
  test_compose: test_compose
};

console.log("Test List Functor");

let __x = test_id(/* [] */0);

console.log("id: P{", __x);

let __x$1 = test_id({
  hd: 1,
  tl: {
    hd: 2,
    tl: /* [] */0
  }
});

console.log("id: {1,2}", __x$1);

let __x$2 = test_compose(/* [] */0);

console.log("compose: {}", __x$2);

let __x$3 = test_compose({
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: /* [] */0
    }
  }
});

console.log("compose: {1,2,3}", __x$3);

function map$1(f, x) {
  if (x !== undefined) {
    return Primitive_option.some(f(Primitive_option.valFromOption(x)));
  }
}

let OptionFunctor = {
  map: map$1
};

function test_id$1(x) {
  return Primitive_object.equal(map$1(id, x), x);
}

function test_compose$1(xs) {
  let f = x => x % 2;
  let g = x => x - 1 | 0;
  return Primitive_object.equal(map$1(extra => (extra - 1 | 0) % 2, xs), map$1(f, map$1(g, xs)));
}

let TOF = {
  test_id: test_id$1,
  test_compose: test_compose$1
};

console.log("Test Option Functor");

let __x$4 = test_id$1(42);

console.log("id: Some(42)", __x$4);

let __x$5 = test_id$1(undefined);

console.log("id: None", __x$5);

let __x$6 = test_compose$1(42);

console.log("compose: Some(42)", __x$6);

let __x$7 = test_compose$1(undefined);

console.log("compose: None", __x$7);

function TestMonoid(M) {
  let test_left_id = x => Primitive_object.equal(M.append(M.empty, x), x);
  let test_right_id = x => Primitive_object.equal(M.append(x, M.empty), x);
  let test_assoc = (x, y, z) => Primitive_object.equal(M.append(x, M.append(y, z)), M.append(M.append(x, y), z));
  return {
    test_left_id: test_left_id,
    test_right_id: test_right_id,
    test_assoc: test_assoc
  };
}

function append(a, b) {
  return a + b | 0;
}

let IntAddMonoid = {
  empty: 0,
  append: append
};

let __x$8 = Stdlib_List.reduce({
  hd: 1,
  tl: {
    hd: 10,
    tl: {
      hd: 102,
      tl: /* [] */0
    }
  }
}, 0, append);

console.log("IntAddMonoid.sum {1,10,102}", __x$8);

function MonoidUtils(M) {
  let empty = M.empty;
  let append = M.append;
  let $less$plus$great = (x, y) => append(x, y);
  let concat = xs => Stdlib_List.reduce(xs, empty, $less$plus$great);
  return {
    empty: empty,
    append: append,
    $less$plus$great: $less$plus$great,
    concat: concat
  };
}

function ListMonoid(T) {
  let append = Pervasives.$at;
  return {
    empty: /* [] */0,
    append: append
  };
}

function pure(x) {
  return {
    hd: x,
    tl: /* [] */0
  };
}

function apply(fs, xs) {
  return Stdlib_List.flat(Stdlib_List.map(fs, f => Stdlib_List.map(xs, x => f(x))));
}

let ListApplicative = {
  map: map,
  pure: pure,
  apply: apply
};

function ApplicativeUtils(A) {
  let map = A.map;
  let apply = A.apply;
  let $less$$great = (f, xs) => map(f, xs);
  let $less$star$great = (f, xs) => apply(f, xs);
  let $less$star = (x, y) => apply(map($$const, x), y);
  let $star$great = (x, y) => apply(map(param => (y => y), x), y);
  let liftA2 = (f, x, y) => apply(map(f, x), y);
  return {
    map: map,
    pure: A.pure,
    apply: apply,
    $less$$great: $less$$great,
    $less$star$great: $less$star$great,
    $less$star: $less$star,
    $star$great: $star$great,
    liftA2: liftA2
  };
}

function $less$$great(f, xs) {
  return Stdlib_List.map(xs, f);
}

let $less$star$great = apply;

function $less$star(x, y) {
  return apply(Stdlib_List.map(x, $$const), y);
}

function $star$great(x, y) {
  return apply(Stdlib_List.map(x, param => (y => y)), y);
}

function liftA2(f, x, y) {
  return apply(Stdlib_List.map(x, f), y);
}

let LAU = {
  map: map,
  pure: pure,
  apply: apply,
  $less$$great: $less$$great,
  $less$star$great: $less$star$great,
  $less$star: $less$star,
  $star$great: $star$great,
  liftA2: liftA2
};

function makeQuote(time) {
  return offer => (ticker => (value => ({
    time: time,
    offer: offer,
    ticker: ticker,
    value: value
  })));
}

let quotes = apply(apply(apply(Stdlib_List.map({
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: {
        hd: 4,
        tl: {
          hd: 5,
          tl: /* [] */0
        }
      }
    }
  }
}, makeQuote), {
  hd: "Ask",
  tl: {
    hd: "Bid",
    tl: /* [] */0
  }
}), {
  hd: "XYZ",
  tl: {
    hd: "ZYK",
    tl: {
      hd: "ABC",
      tl: {
        hd: "CDE",
        tl: {
          hd: "QRZ",
          tl: /* [] */0
        }
      }
    }
  }
}), {
  hd: 100,
  tl: {
    hd: 90,
    tl: {
      hd: 80,
      tl: {
        hd: 70,
        tl: /* [] */0
      }
    }
  }
});

let __x$9 = Belt_List.toArray(quotes);

console.log("quotes", __x$9);

function pure$1(x) {
  return Primitive_option.some(x);
}

function apply$1(fo, xo) {
  if (fo !== undefined && xo !== undefined) {
    return Primitive_option.some(fo(Primitive_option.valFromOption(xo)));
  }
}

let OptionApplicative = {
  map: map$1,
  pure: pure$1,
  apply: apply$1
};

let $less$$great$1 = map$1;

let $less$star$great$1 = apply$1;

function $less$star$1(x, y) {
  return apply$1(map$1($$const, x), y);
}

function $star$great$1(x, y) {
  return apply$1(map$1(param => (y => y), x), y);
}

function liftA2$1(f, x, y) {
  return apply$1(map$1(f, x), y);
}

let OAU = {
  map: map$1,
  pure: pure$1,
  apply: apply$1,
  $less$$great: $less$$great$1,
  $less$star$great: $less$star$great$1,
  $less$star: $less$star$1,
  $star$great: $star$great$1,
  liftA2: liftA2$1
};

function $slash$slash$dot(n, d) {
  if (d === 0) {
    return;
  } else {
    return n / d;
  }
}

function ssqrt(x) {
  if (x < 0) {
    return;
  } else {
    return Math.sqrt(x);
  }
}

function f(x, y) {
  let match = $slash$slash$dot(x, y);
  let match$1 = ssqrt(x);
  let match$2 = ssqrt(y);
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined) {
    return match + match$1 - match$2;
  }
}

function f$p(x, y) {
  return apply$1(apply$1(map$1(z => (r1 => (r2 => z + r1 - r2)), $slash$slash$dot(x, y)), ssqrt(x)), ssqrt(y));
}

let __x$10 = f(1, 2);

console.log("f(1.,2.) = ", __x$10);

let __x$11 = f$p(1, 2);

console.log("f'(1.,2.) = ", __x$11);

let __x$12 = f(1, 0);

console.log("f(1.,0.) = ", __x$12);

let __x$13 = f$p(1, 0);

console.log("f'(1.,0.) = ", __x$13);

let __x$14 = f(1, -2);

console.log("f(1.,2.) = ", __x$14);

let __x$15 = f$p(1, -2);

console.log("f'(1.,2.) = ", __x$15);

function TestApplicative(A) {
  let map = A.map;
  let pure = A.pure;
  let apply = A.apply;
  let $less$$great = (f, xs) => map(f, xs);
  let $less$star$great = (f, xs) => apply(f, xs);
  let $less$star = (x, y) => apply(map($$const, x), y);
  let $star$great = (x, y) => apply(map(param => (y => y), x), y);
  let liftA2 = (f, x, y) => apply(map(f, x), y);
  let AU = {
    map: map,
    pure: pure,
    apply: apply,
    $less$$great: $less$$great,
    $less$star$great: $less$star$great,
    $less$star: $less$star,
    $star$great: $star$great,
    liftA2: liftA2
  };
  let test_id = x => Primitive_object.equal(apply(pure(id), x), x);
  let test_hom = (f, x) => Primitive_object.equal(apply(pure(f), pure(x)), pure(f(x)));
  let test_composition = (u, v, w) => Primitive_object.equal(apply(apply(apply(pure(f => (g => (x => f(g(x))))), u), v), w), apply(u, apply(v, w)));
  return {
    AU: AU,
    test_id: test_id,
    test_hom: test_hom,
    test_composition: test_composition
  };
}

function $less$$great$2(f, xs) {
  return Stdlib_List.map(xs, f);
}

let $less$star$great$2 = apply;

function $less$star$2(x, y) {
  return apply(Stdlib_List.map(x, $$const), y);
}

function $star$great$2(x, y) {
  return apply(Stdlib_List.map(x, param => (y => y)), y);
}

function liftA2$2(f, x, y) {
  return apply(Stdlib_List.map(x, f), y);
}

let AU = {
  map: map,
  pure: pure,
  apply: apply,
  $less$$great: $less$$great$2,
  $less$star$great: $less$star$great$2,
  $less$star: $less$star$2,
  $star$great: $star$great$2,
  liftA2: liftA2$2
};

function test_id$2(x) {
  return Primitive_object.equal(apply({
    hd: id,
    tl: /* [] */0
  }, x), x);
}

function test_hom(f, x) {
  return Primitive_object.equal(apply({
    hd: f,
    tl: /* [] */0
  }, {
    hd: x,
    tl: /* [] */0
  }), {
    hd: f(x),
    tl: /* [] */0
  });
}

function test_composition(u, v, w) {
  return Primitive_object.equal(apply(apply(apply({
    hd: f => (g => (x => f(g(x)))),
    tl: /* [] */0
  }, u), v), w), apply(u, apply(v, w)));
}

let TAL = {
  AU: AU,
  test_id: test_id$2,
  test_hom: test_hom,
  test_composition: test_composition
};

let __x$16 = test_id$2(/* [] */0);

console.log("test_id = ", __x$16);

let __x$17 = test_hom(prim => prim.length, "Homomorphism");

console.log("test_hom = ", __x$17);

function ListTraversable(A) {
  let traverse = (f, xs) => {
    if (xs === 0) {
      return A.pure(/* [] */0);
    }
    let __x = f(xs.hd);
    return A.apply(A.map(y => (ys => ({
      hd: y,
      tl: ys
    })), __x), traverse(f, xs.tl));
  };
  return {
    Applicative: A,
    traverse: traverse
  };
}

function traverse(f, xs) {
  if (xs === 0) {
    return /* [] */0;
  }
  let __x = f(xs.hd);
  return apply$1(map$1(y => (ys => ({
    hd: y,
    tl: ys
  })), __x), traverse(f, xs.tl));
}

let LTO = {
  Applicative: OptionApplicative,
  traverse: traverse
};

let __x$18 = traverse(ssqrt, {
  hd: 4.0,
  tl: {
    hd: 9.0,
    tl: {
      hd: 16.0,
      tl: /* [] */0
    }
  }
});

console.log("all_roots = ", __x$18);

let __x$19 = traverse(ssqrt, {
  hd: 4.0,
  tl: {
    hd: -9.0,
    tl: {
      hd: 16.0,
      tl: /* [] */0
    }
  }
});

console.log("all_roots = ", __x$19);

function node(l, x, r) {
  return {
    TAG: "Node",
    _0: l,
    _1: x,
    _2: r
  };
}

function TreeTraversable(A) {
  let traverse = (f, t) => {
    let apply = A.apply;
    if (typeof t !== "object") {
      return A.pure("Leaf");
    } else {
      return apply(apply(A.map(l => (x => (r => ({
        TAG: "Node",
        _0: l,
        _1: x,
        _2: r
      }))), traverse(f, t._0)), f(t._1)), traverse(f, t._2));
    }
  };
  return {
    Applicative: A,
    traverse: traverse
  };
}

function pure$2(x) {
  return x;
}

function map$2(f) {
  return f;
}

function apply$2(f) {
  return f;
}

let IdApplicative = {
  map: map$2,
  pure: pure$2,
  apply: apply$2
};

function traverse$1(f, t) {
  if (typeof t !== "object") {
    return "Leaf";
  } else {
    return apply$2(apply$2(map$2(l => (x => (r => ({
      TAG: "Node",
      _0: l,
      _1: x,
      _2: r
    }))))(traverse$1(f, t._0)))(f(t._1)))(traverse$1(f, t._2));
  }
}

let TreeTraversableId = {
  Applicative: IdApplicative,
  traverse: traverse$1
};

function map$3(f) {
  return extra => traverse$1(f, extra);
}

function TraversableFunctor(MT) {
  let TI = MT(IdApplicative);
  let map = (f, xs) => TI.traverse(f, xs);
  return {
    TI: TI,
    map: map
  };
}

function traverse$2(f, t) {
  if (typeof t !== "object") {
    return "Leaf";
  } else {
    return apply$2(apply$2(map$2(l => (x => (r => ({
      TAG: "Node",
      _0: l,
      _1: x,
      _2: r
    }))))(traverse$2(f, t._0)))(f(t._1)))(traverse$2(f, t._2));
  }
}

let TI = {
  Applicative: IdApplicative,
  traverse: traverse$2
};

let map$4 = traverse$2;

let TTU = {
  TI: TI,
  map: map$4
};

let __x$20 = traverse$2(x => x * x | 0, {
  TAG: "Node",
  _0: "Leaf",
  _1: 3,
  _2: {
    TAG: "Node",
    _0: "Leaf",
    _1: 5,
    _2: "Leaf"
  }
});

console.log("TTU.map = ", __x$20);

function TestTraversableNat(T2) {
  return A1 => (A2 => (MT => {
    let T1 = MT(A1);
    let T2 = MT(A2);
    let test = (f, param, x) => {
      let t = param.t;
      return Primitive_object.equal(t(T1.traverse(f, x)), T2.traverse(extra => t(f(extra)), x));
    };
    return {
      T1: T1,
      T2: T2,
      test: test
    };
  }));
}

let T1 = ListTraversable(IdApplicative);

let T2 = ListTraversable(OptionApplicative);

function test(f, param, x) {
  let t = param.t;
  return Primitive_object.equal(t(T1.traverse(f, x)), T2.traverse(extra => t(f(extra)), x));
}

let TTN = {
  T1: T1,
  T2: T2,
  test: test
};

function TestTraversableId(MT) {
  let TI = MT(IdApplicative);
  let test = x => Primitive_object.equal(TI.traverse(id, x), x);
  return {
    TI: TI,
    test: test
  };
}

function traverse$3(f, xs) {
  if (xs !== 0) {
    return apply$2(map$2(y => (ys => ({
      hd: y,
      tl: ys
    })))(f(xs.hd)))(traverse$3(f, xs.tl));
  } else {
    return /* [] */0;
  }
}

let TI$1 = {
  Applicative: IdApplicative,
  traverse: traverse$3
};

function test$1(x) {
  return Primitive_object.equal(traverse$3(id, x), x);
}

let TTIL = {
  TI: TI$1,
  test: test$1
};

let __x$21 = test$1({
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: /* [] */0
    }
  }
});

console.log("TTIL.test = ", __x$21);

function ComposeApplicative(F) {
  return G => {
    let pure = x => F.pure(G.pure(x));
    let map = f => (extra => F.map(extra => G.map(f, extra), extra));
    let apply = (f, x) => F.apply(F.map(fs => (xs => G.apply(fs, xs)), f), x);
    return {
      map: map,
      pure: pure,
      apply: apply
    };
  };
}

function TestTraversableCompose(T2) {
  return F => (G => (MT => {
    let pure = x => F.pure(G.pure(x));
    let map = f => (extra => F.map(extra => G.map(f, extra), extra));
    let apply = (f, x) => {
      let map = F.map;
      let apply$1 = F.apply;
      let $less$$great = (f, xs) => map(f, xs);
      let f$1 = $less$$great(fs => (xs => G.apply(fs, xs)), f);
      return apply$1(f$1, x);
    };
    let AC = {
      map: map,
      pure: pure,
      apply: apply
    };
    let TF = MT(F);
    let TG = MT(G);
    let TC = MT(AC);
    let test = (f, g, x) => Primitive_object.equal(F.map(__x => TG.traverse(g, __x), TF.traverse(f, x)), TC.traverse(__x => {
      let __x$1 = f(__x);
      return F.map(g, __x$1);
    }, x));
    return {
      AC: AC,
      TF: TF,
      TG: TG,
      TC: TC,
      test: test
    };
  }));
}

function pure$3(x) {
  return {
    hd: Primitive_option.some(x),
    tl: /* [] */0
  };
}

function map$5(f) {
  return extra => Stdlib_List.map(extra, extra => map$1(f, extra));
}

function apply$3(f, x) {
  let $less$$great = (f, xs) => map(f, xs);
  let $less$star$great = (f, xs) => apply(f, xs);
  let $less$star = (x, y) => $less$star$great($less$$great($$const, x), y);
  let $star$great = (x, y) => $less$star$great($less$$great(param => (y => y), x), y);
  let liftA2 = (f, x, y) => $less$star$great($less$$great(f, x), y);
  return $less$star$great($less$$great(fs => (xs => apply$1(fs, xs)), f), x);
}

let AC = {
  map: map$5,
  pure: pure$3,
  apply: apply$3
};

let TF = ListTraversable(ListApplicative);

let TG = ListTraversable(OptionApplicative);

let TC = ListTraversable(AC);

function test$2(f, g, x) {
  return Primitive_object.equal(Stdlib_List.map(TF.traverse(f, x), __x => TG.traverse(g, __x)), TC.traverse(__x => Stdlib_List.map(f(__x), g), x));
}

let TTCL = {
  AC: AC,
  TF: TF,
  TG: TG,
  TC: TC,
  test: test$2
};

let prim = test$2(x => ({
  hd: x,
  tl: {
    hd: x + 1 | 0,
    tl: /* [] */0
  }
}), x => {
  if (x > 10) {
    return -x | 0;
  }
}, {
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: {
        hd: 5,
        tl: /* [] */0
      }
    }
  }
});

console.log(prim);

let $less$less = compose;

let $great$great = compose_right;

export {
  log,
  log2,
  compose,
  $less$less,
  compose_right,
  $great$great,
  id,
  $$const,
  ListFunctor,
  TestFunctor,
  TFL,
  OptionFunctor,
  TOF,
  TestMonoid,
  IntAddMonoid,
  MonoidUtils,
  ListMonoid,
  ListApplicative,
  ApplicativeUtils,
  LAU,
  OptionApplicative,
  OAU,
  $slash$slash$dot,
  ssqrt,
  TestApplicative,
  TAL,
  ListTraversable,
  LTO,
  node,
  TreeTraversable,
  IdApplicative,
  TreeTraversableId,
  map$3 as map,
  TraversableFunctor,
  TTU,
  TestTraversableNat,
  TTN,
  TestTraversableId,
  TTIL,
  ComposeApplicative,
  TestTraversableCompose,
  TTCL,
}
/*  Not a pure module */
