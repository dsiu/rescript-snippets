// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function compose(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function compose_right(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function id(x) {
  return x;
}

function $$const(x, param) {
  return x;
}

var map = List.map;

var ListFunctor = {
  map: map
};

function TestFunctor(F) {
  var test_id = function (x) {
    return Caml_obj.equal(Curry._2(F.map, id, x), x);
  };
  var test_compose = function (xs) {
    var f = function (x) {
      return x % 2;
    };
    var g = function (x) {
      return x - 1 | 0;
    };
    return Caml_obj.equal(Curry._2(F.map, (function (param) {
                      return (param - 1 | 0) % 2;
                    }), xs), Curry._2(F.map, f, Curry._2(F.map, g, xs)));
  };
  return {
          test_id: test_id,
          test_compose: test_compose
        };
}

function test_id(x) {
  return Caml_obj.equal(List.map(id, x), x);
}

function test_compose(xs) {
  var f = function (x) {
    return x % 2;
  };
  var g = function (x) {
    return x - 1 | 0;
  };
  return Caml_obj.equal(List.map((function (param) {
                    return (param - 1 | 0) % 2;
                  }), xs), List.map(f, List.map(g, xs)));
}

var TFL = {
  test_id: test_id,
  test_compose: test_compose
};

console.log("Test List Functor");

((function (__x) {
        console.log("id: P{", __x);
      })(test_id(/* [] */0)));

((function (__x) {
        console.log("id: {1,2}", __x);
      })(test_id({
            hd: 1,
            tl: {
              hd: 2,
              tl: /* [] */0
            }
          })));

((function (__x) {
        console.log("compose: {}", __x);
      })(test_compose(/* [] */0)));

((function (__x) {
        console.log("compose: {1,2,3}", __x);
      })(test_compose({
            hd: 1,
            tl: {
              hd: 2,
              tl: {
                hd: 3,
                tl: /* [] */0
              }
            }
          })));

function map$1(f, x) {
  if (x !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
  }
  
}

var OptionFunctor = {
  map: map$1
};

function test_id$1(x) {
  return Caml_obj.equal(map$1(id, x), x);
}

function test_compose$1(xs) {
  var f = function (x) {
    return x % 2;
  };
  var g = function (x) {
    return x - 1 | 0;
  };
  return Caml_obj.equal(map$1((function (param) {
                    return (param - 1 | 0) % 2;
                  }), xs), map$1(f, map$1(g, xs)));
}

var TOF = {
  test_id: test_id$1,
  test_compose: test_compose$1
};

console.log("Test Option Functor");

((function (__x) {
        console.log("id: Some(42)", __x);
      })(test_id$1(42)));

((function (__x) {
        console.log("id: None", __x);
      })(test_id$1(undefined)));

((function (__x) {
        console.log("compose: Some(42)", __x);
      })(test_compose$1(42)));

((function (__x) {
        console.log("compose: None", __x);
      })(test_compose$1(undefined)));

function TestMonoid(M) {
  var test_left_id = function (x) {
    return Caml_obj.equal(Curry._2(M.append, M.empty, x), x);
  };
  var test_right_id = function (x) {
    return Caml_obj.equal(Curry._2(M.append, x, M.empty), x);
  };
  var test_assoc = function (x, y, z) {
    return Caml_obj.equal(Curry._2(M.append, x, Curry._2(M.append, y, z)), Curry._2(M.append, Curry._2(M.append, x, y), z));
  };
  return {
          test_left_id: test_left_id,
          test_right_id: test_right_id,
          test_assoc: test_assoc
        };
}

function append(a, b) {
  return a + b | 0;
}

var IntAddMonoid = {
  empty: 0,
  append: append
};

((function (__x) {
        console.log("IntAddMonoid.sum {1,10,102}", __x);
      })(List.fold_left(append, 0, {
            hd: 1,
            tl: {
              hd: 10,
              tl: {
                hd: 102,
                tl: /* [] */0
              }
            }
          })));

function MonoidUtils(M) {
  var empty = M.empty;
  var append = M.append;
  var $less$plus$great = Curry.__2(append);
  var concat = function (xs) {
    return List.fold_left($less$plus$great, empty, xs);
  };
  return {
          empty: empty,
          append: append,
          $less$plus$great: $less$plus$great,
          concat: concat
        };
}

function ListMonoid(T) {
  var append = function (xs, ys) {
    return PervasivesU.$at(xs, ys);
  };
  return {
          empty: /* [] */0,
          append: append
        };
}

function pure(x) {
  return {
          hd: x,
          tl: /* [] */0
        };
}

function apply(fs, xs) {
  return List.concat(List.map((function (f) {
                    return List.map(f, xs);
                  }), fs));
}

var ListApplicative = {
  map: map,
  pure: pure,
  apply: apply
};

function ApplicativeUtils(A) {
  var map = A.map;
  var apply = A.apply;
  var $less$$great = Curry.__1(map);
  var $less$star$great = Curry.__1(apply);
  var $less$star = function (x, y) {
    return Curry._2(apply, Curry._2(map, $$const, x), y);
  };
  var $star$great = function (x, y) {
    return Curry._2(apply, Curry._2(map, (function (param, y) {
                      return y;
                    }), x), y);
  };
  var liftA2 = function (f, x, y) {
    return Curry._2(apply, Curry._2(map, f, x), y);
  };
  return {
          map: map,
          pure: A.pure,
          apply: apply,
          $less$$great: $less$$great,
          $less$star$great: $less$star$great,
          $less$star: $less$star,
          $star$great: $star$great,
          liftA2: liftA2
        };
}

function $less$$great(f) {
  return function (param) {
    return List.map(f, param);
  };
}

function $less$star$great(f) {
  return function (param) {
    return apply(f, param);
  };
}

function $less$star(x, y) {
  var f = List.map($$const, x);
  return apply(f, y);
}

function $star$great(x, y) {
  var f = function (param, y) {
    return y;
  };
  var f$1 = List.map(f, x);
  return apply(f$1, y);
}

function liftA2(f, x, y) {
  var f$1 = List.map(f, x);
  return apply(f$1, y);
}

var LAU = {
  map: map,
  pure: pure,
  apply: apply,
  $less$$great: $less$$great,
  $less$star$great: $less$star$great,
  $less$star: $less$star,
  $star$great: $star$great,
  liftA2: liftA2
};

function makeQuote(time, offer, ticker, value) {
  return {
          time: time,
          offer: offer,
          ticker: ticker,
          value: value
        };
}

var f = List.map(makeQuote, {
      hd: 1,
      tl: {
        hd: 2,
        tl: {
          hd: 3,
          tl: {
            hd: 4,
            tl: {
              hd: 5,
              tl: /* [] */0
            }
          }
        }
      }
    });

var f$1 = apply(f, {
      hd: "Ask",
      tl: {
        hd: "Bid",
        tl: /* [] */0
      }
    });

var f$2 = apply(f$1, {
      hd: "XYZ",
      tl: {
        hd: "ZYK",
        tl: {
          hd: "ABC",
          tl: {
            hd: "CDE",
            tl: {
              hd: "QRZ",
              tl: /* [] */0
            }
          }
        }
      }
    });

var quotes = apply(f$2, {
      hd: 100,
      tl: {
        hd: 90,
        tl: {
          hd: 80,
          tl: {
            hd: 70,
            tl: /* [] */0
          }
        }
      }
    });

((function (__x) {
        console.log("quotes", __x);
      })(Belt_List.toArray(quotes)));

function pure$1(x) {
  return Caml_option.some(x);
}

function apply$1(fo, xo) {
  if (fo !== undefined && xo !== undefined) {
    return Caml_option.some(Curry._1(fo, Caml_option.valFromOption(xo)));
  }
  
}

var OptionApplicative = {
  map: map$1,
  pure: pure$1,
  apply: apply$1
};

function $less$$great$1(f) {
  return function (param) {
    return map$1(f, param);
  };
}

function $less$star$great$1(f) {
  return function (param) {
    return apply$1(f, param);
  };
}

function $less$star$1(x, y) {
  var f = map$1($$const, x);
  return apply$1(f, y);
}

function $star$great$1(x, y) {
  var f = function (param, y) {
    return y;
  };
  var f$1 = map$1(f, x);
  return apply$1(f$1, y);
}

function liftA2$1(f, x, y) {
  var f$1 = map$1(f, x);
  return apply$1(f$1, y);
}

var OAU = {
  map: map$1,
  pure: pure$1,
  apply: apply$1,
  $less$$great: $less$$great$1,
  $less$star$great: $less$star$great$1,
  $less$star: $less$star$1,
  $star$great: $star$great$1,
  liftA2: liftA2$1
};

function $slash$slash$dot(n, d) {
  if (d === 0) {
    return ;
  } else {
    return n / d;
  }
}

function ssqrt(x) {
  if (x < 0) {
    return ;
  } else {
    return Math.sqrt(x);
  }
}

function f$3(x, y) {
  var match = $slash$slash$dot(x, y);
  var match$1 = ssqrt(x);
  var match$2 = ssqrt(y);
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined) {
    return match + match$1 - match$2;
  }
  
}

function f$p(x, y) {
  var f = function (z, r1, r2) {
    return z + r1 - r2;
  };
  var f$1 = map$1(f, $slash$slash$dot(x, y));
  var f$2 = apply$1(f$1, ssqrt(x));
  return apply$1(f$2, ssqrt(y));
}

((function (__x) {
        console.log("f(1.,2.) = ", __x);
      })(f$3(1, 2)));

((function (__x) {
        console.log("f'(1.,2.) = ", __x);
      })(f$p(1, 2)));

((function (__x) {
        console.log("f(1.,0.) = ", __x);
      })(f$3(1, 0)));

((function (__x) {
        console.log("f'(1.,0.) = ", __x);
      })(f$p(1, 0)));

((function (__x) {
        console.log("f(1.,2.) = ", __x);
      })(f$3(1, -2)));

((function (__x) {
        console.log("f'(1.,2.) = ", __x);
      })(f$p(1, -2)));

function TestApplicative(A) {
  var map = A.map;
  var pure = A.pure;
  var apply = A.apply;
  var $less$$great = Curry.__1(map);
  var $less$star$great = Curry.__1(apply);
  var $less$star = function (x, y) {
    return Curry._2(apply, Curry._2(map, $$const, x), y);
  };
  var $star$great = function (x, y) {
    return Curry._2(apply, Curry._2(map, (function (param, y) {
                      return y;
                    }), x), y);
  };
  var liftA2 = function (f, x, y) {
    return Curry._2(apply, Curry._2(map, f, x), y);
  };
  var AU = {
    map: map,
    pure: pure,
    apply: apply,
    $less$$great: $less$$great,
    $less$star$great: $less$star$great,
    $less$star: $less$star,
    $star$great: $star$great,
    liftA2: liftA2
  };
  var test_id = function (x) {
    return Caml_obj.equal(Curry._2(apply, Curry._1(pure, id), x), x);
  };
  var test_hom = function (f, x) {
    return Caml_obj.equal(Curry._2(apply, Curry._1(pure, f), Curry._1(pure, x)), Curry._1(pure, Curry._1(f, x)));
  };
  var test_composition = function (u, v, w) {
    return Caml_obj.equal(Curry._2(apply, Curry._2(apply, Curry._2(apply, Curry._1(pure, compose), u), v), w), Curry._2(apply, u, Curry._2(apply, v, w)));
  };
  return {
          AU: AU,
          test_id: test_id,
          test_hom: test_hom,
          test_composition: test_composition
        };
}

function $less$$great$2(f) {
  return function (param) {
    return List.map(f, param);
  };
}

function $less$star$great$2(f) {
  return function (param) {
    return apply(f, param);
  };
}

function $less$star$2(x, y) {
  var f = List.map($$const, x);
  return apply(f, y);
}

function $star$great$2(x, y) {
  var f = function (param, y) {
    return y;
  };
  var f$1 = List.map(f, x);
  return apply(f$1, y);
}

function liftA2$2(f, x, y) {
  var f$1 = List.map(f, x);
  return apply(f$1, y);
}

var AU = {
  map: map,
  pure: pure,
  apply: apply,
  $less$$great: $less$$great$2,
  $less$star$great: $less$star$great$2,
  $less$star: $less$star$2,
  $star$great: $star$great$2,
  liftA2: liftA2$2
};

function test_id$2(x) {
  var f = {
    hd: id,
    tl: /* [] */0
  };
  return Caml_obj.equal(apply(f, x), x);
}

function test_hom(f, x) {
  var f$1 = {
    hd: f,
    tl: /* [] */0
  };
  return Caml_obj.equal(apply(f$1, {
                  hd: x,
                  tl: /* [] */0
                }), {
              hd: Curry._1(f, x),
              tl: /* [] */0
            });
}

function test_composition(u, v, w) {
  var f = {
    hd: compose,
    tl: /* [] */0
  };
  var f$1 = apply(f, u);
  var f$2 = apply(f$1, v);
  return Caml_obj.equal(apply(f$2, w), apply(u, apply(v, w)));
}

var TAL = {
  AU: AU,
  test_id: test_id$2,
  test_hom: test_hom,
  test_composition: test_composition
};

((function (__x) {
        console.log("test_id = ", __x);
      })(test_id$2(/* [] */0)));

((function (__x) {
        console.log("test_hom = ", __x);
      })(test_hom((function (prim) {
              return prim.length;
            }), "Homomorphism")));

function ListTraversable(A) {
  var traverse = function (f, xs) {
    var map = A.map;
    if (xs) {
      return Curry._2(A.apply, (function (__x) {
                      return Curry._2(map, (function (y, ys) {
                                    return {
                                            hd: y,
                                            tl: ys
                                          };
                                  }), __x);
                    })(Curry._1(f, xs.hd)), traverse(f, xs.tl));
    } else {
      return Curry._1(A.pure, /* [] */0);
    }
  };
  return {
          Applicative: A,
          traverse: traverse
        };
}

function traverse(f, xs) {
  if (!xs) {
    return /* [] */0;
  }
  var f$1 = (function (__x) {
        var f = function (y, ys) {
          return {
                  hd: y,
                  tl: ys
                };
        };
        return map$1(f, __x);
      })(Curry._1(f, xs.hd));
  return apply$1(f$1, traverse(f, xs.tl));
}

var LTO = {
  Applicative: OptionApplicative,
  traverse: traverse
};

((function (__x) {
        console.log("all_roots = ", __x);
      })(traverse(ssqrt, {
            hd: 4.0,
            tl: {
              hd: 9.0,
              tl: {
                hd: 16.0,
                tl: /* [] */0
              }
            }
          })));

((function (__x) {
        console.log("all_roots = ", __x);
      })(traverse(ssqrt, {
            hd: 4.0,
            tl: {
              hd: -9.0,
              tl: {
                hd: 16.0,
                tl: /* [] */0
              }
            }
          })));

function node(l, x, r) {
  return {
          TAG: "Node",
          _0: l,
          _1: x,
          _2: r
        };
}

function TreeTraversable(A) {
  var traverse = function (f, t) {
    var apply = A.apply;
    if (typeof t !== "object") {
      return Curry._1(A.pure, "Leaf");
    } else {
      return Curry._2(apply, Curry._2(apply, Curry._2(A.map, node, traverse(f, t._0)), Curry._1(f, t._1)), traverse(f, t._2));
    }
  };
  return {
          Applicative: A,
          traverse: traverse
        };
}

function pure$2(x) {
  return x;
}

function map$2(f) {
  return f;
}

function apply$2(f) {
  return f;
}

var IdApplicative = {
  map: map$2,
  pure: pure$2,
  apply: apply$2
};

function traverse$1(f, t) {
  if (typeof t !== "object") {
    return "Leaf";
  }
  var partial_arg = Curry._1(f, t._1);
  var partial_arg$1 = traverse$1(f, t._0);
  var param = traverse$1(f, t._2);
  return node(partial_arg$1, partial_arg, param);
}

var TreeTraversableId = {
  Applicative: IdApplicative,
  traverse: traverse$1
};

function map$3(f) {
  return function (param) {
    return traverse$1(f, param);
  };
}

function TraversableFunctor(MT) {
  var TI = Curry._1(MT, IdApplicative);
  var map = function (f) {
    return Curry._1(TI.traverse, f);
  };
  return {
          TI: TI,
          map: map
        };
}

function traverse$2(f, t) {
  if (typeof t !== "object") {
    return "Leaf";
  }
  var partial_arg = Curry._1(f, t._1);
  var partial_arg$1 = traverse$2(f, t._0);
  var param = traverse$2(f, t._2);
  return node(partial_arg$1, partial_arg, param);
}

var TI = {
  Applicative: IdApplicative,
  traverse: traverse$2
};

function map$4(f) {
  return function (param) {
    return traverse$2(f, param);
  };
}

var TTU = {
  TI: TI,
  map: map$4
};

function f$4(x) {
  return Math.imul(x, x);
}

((function (__x) {
        console.log("TTU.map = ", __x);
      })(traverse$2(f$4, {
            TAG: "Node",
            _0: "Leaf",
            _1: 3,
            _2: {
              TAG: "Node",
              _0: "Leaf",
              _1: 5,
              _2: "Leaf"
            }
          })));

function TestTraversableNat(T2, A1, A2, MT) {
  var T1 = Curry._1(MT, A1);
  var T2$1 = Curry._1(MT, A2);
  var test = function (f, param, x) {
    var t = param.t;
    return Caml_obj.equal(Curry._1(t, Curry._2(T1.traverse, f, x)), Curry._2(T2$1.traverse, (function (param) {
                      return Curry._1(t, Curry._1(f, param));
                    }), x));
  };
  return {
          T1: T1,
          T2: T2$1,
          test: test
        };
}

function partial_arg(param, param$1) {
  var T1 = Curry._1(param$1, IdApplicative);
  var T2 = Curry._1(param$1, param);
  var test = function (f, param, x) {
    var t = param.t;
    return Caml_obj.equal(Curry._1(t, Curry._2(T1.traverse, f, x)), Curry._2(T2.traverse, (function (param) {
                      return Curry._1(t, Curry._1(f, param));
                    }), x));
  };
  return {
          T1: T1,
          T2: T2,
          test: test
        };
}

var TTN = partial_arg(OptionApplicative, ListTraversable);

function TestTraversableId(MT) {
  var TI = Curry._1(MT, IdApplicative);
  var test = function (x) {
    return Caml_obj.equal(Curry._2(TI.traverse, id, x), x);
  };
  return {
          TI: TI,
          test: test
        };
}

function traverse$3(f, xs) {
  if (xs) {
    return Curry._1((function (__x) {
                    return function (param) {
                      return {
                              hd: __x,
                              tl: param
                            };
                    };
                  })(Curry._1(f, xs.hd)), traverse$3(f, xs.tl));
  } else {
    return /* [] */0;
  }
}

var TI$1 = {
  Applicative: IdApplicative,
  traverse: traverse$3
};

function test(x) {
  return Caml_obj.equal(traverse$3(id, x), x);
}

var TTIL = {
  TI: TI$1,
  test: test
};

((function (__x) {
        console.log("TTIL.test = ", __x);
      })(test({
            hd: 1,
            tl: {
              hd: 2,
              tl: {
                hd: 3,
                tl: /* [] */0
              }
            }
          })));

function ComposeApplicative(F, G) {
  var pure = function (x) {
    return Curry._1(F.pure, Curry._1(G.pure, x));
  };
  var map = function (f) {
    return Curry._1(F.map, Curry._1(G.map, f));
  };
  var apply = function (f, x) {
    return Curry._2(F.apply, Curry._2(F.map, G.apply, f), x);
  };
  return {
          map: map,
          pure: pure,
          apply: apply
        };
}

function TestTraversableCompose(T2, F, G, MT) {
  var pure = function (x) {
    return Curry._1(F.pure, Curry._1(G.pure, x));
  };
  var map = function (f) {
    return Curry._1(F.map, Curry._1(G.map, f));
  };
  var apply = function (f, x) {
    var map = F.map;
    var apply$1 = F.apply;
    var $less$$great = Curry.__1(map);
    var $less$star$great = Curry.__1(apply$1);
    return Curry._1($less$star$great(Curry._1($less$$great(G.apply), f)), x);
  };
  var AC = {
    map: map,
    pure: pure,
    apply: apply
  };
  var TF = Curry._1(MT, F);
  var TG = Curry._1(MT, G);
  var TC = Curry._1(MT, AC);
  var test = function (f, g, x) {
    var partial_arg = Curry._1(F.map, g);
    return Caml_obj.equal(Curry._2(F.map, Curry._1(TG.traverse, g), Curry._2(TF.traverse, f, x)), Curry._2(TC.traverse, (function (param) {
                      return Curry._1(partial_arg, Curry._1(f, param));
                    }), x));
  };
  return {
          AC: AC,
          TF: TF,
          TG: TG,
          TC: TC,
          test: test
        };
}

function partial_arg$1(param, param$1) {
  var pure$3 = function (x) {
    return Curry._1(pure, Curry._1(param.pure, x));
  };
  var map$5 = function (f) {
    return Curry._1(map, Curry._1(param.map, f));
  };
  var apply$3 = function (f, x) {
    var map$6 = map;
    var apply$4 = apply;
    var $less$$great = Curry.__1(map$6);
    var $less$star$great = Curry.__1(apply$4);
    return Curry._1($less$star$great(Curry._1($less$$great(param.apply), f)), x);
  };
  var AC = {
    map: map$5,
    pure: pure$3,
    apply: apply$3
  };
  var TF = Curry._1(param$1, ListApplicative);
  var TG = Curry._1(param$1, param);
  var TC = Curry._1(param$1, AC);
  var test = function (f, g, x) {
    var partial_arg = Curry._1(map, g);
    return Caml_obj.equal(Curry._2(map, Curry._1(TG.traverse, g), Curry._2(TF.traverse, f, x)), Curry._2(TC.traverse, (function (param) {
                      return Curry._1(partial_arg, Curry._1(f, param));
                    }), x));
  };
  return {
          AC: AC,
          TF: TF,
          TG: TG,
          TC: TC,
          test: test
        };
}

var TTCL = partial_arg$1(OptionApplicative, ListTraversable);

var prim = TTCL.test((function (x) {
        return {
                hd: x,
                tl: {
                  hd: x + 1 | 0,
                  tl: /* [] */0
                }
              };
      }), (function (x) {
        if (x > 10) {
          return -x | 0;
        }
        
      }), {
      hd: 1,
      tl: {
        hd: 2,
        tl: {
          hd: 3,
          tl: {
            hd: 5,
            tl: /* [] */0
          }
        }
      }
    });

console.log(prim);

var $less$less = compose;

var $great$great = compose_right;

export {
  log ,
  log2 ,
  compose ,
  $less$less ,
  compose_right ,
  $great$great ,
  id ,
  $$const ,
  ListFunctor ,
  TestFunctor ,
  TFL ,
  OptionFunctor ,
  TOF ,
  TestMonoid ,
  IntAddMonoid ,
  MonoidUtils ,
  ListMonoid ,
  ListApplicative ,
  ApplicativeUtils ,
  LAU ,
  OptionApplicative ,
  OAU ,
  $slash$slash$dot ,
  ssqrt ,
  TestApplicative ,
  TAL ,
  ListTraversable ,
  LTO ,
  node ,
  TreeTraversable ,
  IdApplicative ,
  TreeTraversableId ,
  map$3 as map,
  TraversableFunctor ,
  TTU ,
  TestTraversableNat ,
  TTN ,
  TestTraversableId ,
  TTIL ,
  ComposeApplicative ,
  TestTraversableCompose ,
  TTCL ,
}
/*  Not a pure module */
