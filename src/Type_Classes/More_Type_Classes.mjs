// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function log(prim) {
  console.log(prim);
  
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
  
}

function compose(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function compose_right(f, g) {
  return function (param) {
    return Curry._1(g, Curry._1(f, param));
  };
}

function id(x) {
  return x;
}

function $$const(x, param) {
  return x;
}

function map(f) {
  return function (param) {
    return List.map(f, param);
  };
}

var ListFunctor = {
  map: map
};

function TestFunctor(F) {
  var test_id = function (x) {
    return Caml_obj.caml_equal(Curry._2(F.map, id, x), x);
  };
  var test_compose = function (xs) {
    var f = function (x) {
      return x % 2;
    };
    var g = function (x) {
      return x - 1 | 0;
    };
    return Caml_obj.caml_equal(Curry._2(F.map, (function (param) {
                      return (param - 1 | 0) % 2;
                    }), xs), Curry._2(F.map, f, Curry._2(F.map, g, xs)));
  };
  return {
          test_id: test_id,
          test_compose: test_compose
        };
}

function test_id(x) {
  return Caml_obj.caml_equal(List.map(id, x), x);
}

function test_compose(xs) {
  var f = function (x) {
    return x % 2;
  };
  var g = function (x) {
    return x - 1 | 0;
  };
  var f$1 = function (param) {
    return (param - 1 | 0) % 2;
  };
  return Caml_obj.caml_equal(List.map(f$1, xs), List.map(f, List.map(g, xs)));
}

var TFL = {
  test_id: test_id,
  test_compose: test_compose
};

console.log("Test List Functor");

var prim = test_id(/* [] */0);

console.log(prim);

var prim$1 = test_id({
      hd: 1,
      tl: {
        hd: 2,
        tl: /* [] */0
      }
    });

console.log(prim$1);

var prim$2 = test_compose(/* [] */0);

console.log(prim$2);

var prim$3 = test_compose({
      hd: 1,
      tl: {
        hd: 2,
        tl: {
          hd: 3,
          tl: /* [] */0
        }
      }
    });

console.log(prim$3);

function map$1(f, x) {
  if (x !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
  }
  
}

var OptionFunctor = {
  map: map$1
};

function test_id$1(x) {
  return Caml_obj.caml_equal(map$1(id, x), x);
}

function test_compose$1(xs) {
  var f = function (x) {
    return x % 2;
  };
  var g = function (x) {
    return x - 1 | 0;
  };
  return Caml_obj.caml_equal(map$1((function (param) {
                    return (param - 1 | 0) % 2;
                  }), xs), map$1(f, map$1(g, xs)));
}

var TOF = {
  test_id: test_id$1,
  test_compose: test_compose$1
};

console.log("Test Option Functor");

var prim$4 = test_id$1(42);

console.log(prim$4);

var prim$5 = test_id$1(undefined);

console.log(prim$5);

var prim$6 = test_compose$1(42);

console.log(prim$6);

var prim$7 = test_compose$1(undefined);

console.log(prim$7);

function TestMonoid(M) {
  var test_left_id = function (x) {
    return Caml_obj.caml_equal(Curry._2(M.append, M.empty, x), x);
  };
  var test_right_id = function (x) {
    return Caml_obj.caml_equal(Curry._2(M.append, x, M.empty), x);
  };
  var test_assoc = function (x, y, z) {
    return Caml_obj.caml_equal(Curry._2(M.append, x, Curry._2(M.append, y, z)), Curry._2(M.append, Curry._2(M.append, x, y), z));
  };
  return {
          test_left_id: test_left_id,
          test_right_id: test_right_id,
          test_assoc: test_assoc
        };
}

function append(prim0, prim1) {
  return prim0 + prim1 | 0;
}

var IntAddMonoid = {
  empty: 0,
  append: append
};

var prim$8 = List.fold_left(append, 0, {
      hd: 1,
      tl: {
        hd: 10,
        tl: {
          hd: 102,
          tl: /* [] */0
        }
      }
    });

console.log(prim$8);

function MonoidUtils(M) {
  var empty = M.empty;
  var append = M.append;
  var $less$plus$great = Curry.__2(append);
  var concat = function (xs) {
    return List.fold_left($less$plus$great, empty, xs);
  };
  return {
          empty: empty,
          append: append,
          $less$plus$great: $less$plus$great,
          concat: concat
        };
}

function ListMonoid(T) {
  var append = Pervasives.$at;
  return {
          empty: /* [] */0,
          append: append
        };
}

export {
  log ,
  log2 ,
  compose ,
  compose_right ,
  id ,
  $$const ,
  ListFunctor ,
  TestFunctor ,
  TFL ,
  OptionFunctor ,
  TOF ,
  TestMonoid ,
  IntAddMonoid ,
  MonoidUtils ,
  ListMonoid ,
  
}
/*  Not a pure module */
