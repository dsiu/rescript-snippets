// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Format from "rescript/lib/es6/format.js";
import * as Printf from "rescript/lib/es6/printf.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as Graphviz$Graph from "rescript-ocamlgraph/src/graphviz.bs.js";
import * as Traverse$Graph from "rescript-ocamlgraph/src/traverse.bs.js";
import * as Imperative$Graph from "rescript-ocamlgraph/src/imperative.bs.js";

function log(prim) {
  console.log(prim);
  
}

function logList(l) {
  var prim = Belt_List.toArray(l);
  console.log(prim);
  
}

function log2(x, y) {
  console.log(y, x);
  
}

function logList2(l, str) {
  var x = Belt_List.toArray(l);
  console.log(str, x);
  
}

function mapListToString(m) {
  var b = Belt_MapString.toList(m);
  return $$String.concat(", ", Belt_List.map(b, (function (param) {
                    return param[0] + ": " + param[1];
                  })));
}

function logStrMapList(m, str) {
  var prim = str + ": " + mapListToString(m);
  console.log(prim);
  
}

function string_of_state(param) {
  var bindings = function (m, fmt) {
    var b = Belt_MapString.toList(m);
    return $$String.concat(", ", Belt_List.map(b, (function (param) {
                      return Curry._2(Printf.sprintf(fmt), param[0], param[1]);
                    })));
  };
  return Curry._3(Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: " d = {",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "}\n f = {",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "}\n pred = {",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "}\n",
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: " d = {%s}\n f = {%s}\n pred = {%s}\n"
                }), bindings(param.d, /* Format */{
                  _0: {
                    TAG: /* Char_literal */12,
                    _0: /* '\'' */39,
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "':'",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* '\'' */39,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "'%s':'%d'"
                }), bindings(param.f, /* Format */{
                  _0: {
                    TAG: /* Char_literal */12,
                    _0: /* '\'' */39,
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "':'",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* '\'' */39,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "'%s':'%d'"
                }), bindings(param.pred, /* Format */{
                  _0: {
                    TAG: /* Char_literal */12,
                    _0: /* '\'' */39,
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: "':'",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* Char_literal */12,
                            _0: /* '\'' */39,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "'%s':'%s'"
                }));
}

function depth_first_search(g) {
  var node = function (param, u) {
    var match = param[1];
    var color = match.color;
    var pred = match.pred;
    var f = match.f;
    var d = match.d;
    var t = param[0];
    var dfs_visit = function (t, u, param) {
      var edge = function (param, v) {
        var match = param[1];
        var color = match.color;
        var pred = match.pred;
        var f = match.f;
        var d = match.d;
        var t = param[0];
        if (Belt_MapString.getExn(color, v) === /* White */0) {
          return dfs_visit(t, v, {
                      d: d,
                      f: f,
                      pred: Belt_MapString.set(pred, v, u),
                      color: color
                    });
        } else {
          return [
                  t,
                  {
                    d: d,
                    f: f,
                    pred: pred,
                    color: color
                  }
                ];
        }
      };
      var t$1 = t + 1 | 0;
      var match = Belt_List.reduce(Belt_MapString.getExn(g, u), [
            t$1,
            {
              d: Belt_MapString.set(param.d, u, t$1),
              f: param.f,
              pred: param.pred,
              color: Belt_MapString.set(param.color, u, /* Gray */1)
            }
          ], edge);
      var match$1 = match[1];
      var t$2 = match[0] + 1 | 0;
      return [
              t$2,
              {
                d: match$1.d,
                f: Belt_MapString.set(match$1.f, u, t$2),
                pred: match$1.pred,
                color: Belt_MapString.set(match$1.color, u, /* Black */2)
              }
            ];
    };
    if (Belt_MapString.getExn(color, u) === /* White */0) {
      return dfs_visit(t, u, {
                  d: d,
                  f: f,
                  pred: pred,
                  color: color
                });
    } else {
      return [
              t,
              {
                d: d,
                f: f,
                pred: pred,
                color: color
              }
            ];
    }
  };
  var v = Belt_List.reduce(Belt_MapString.toList(g), /* [] */0, (function (acc, param) {
          return {
                  hd: param[0],
                  tl: acc
                };
        }));
  var initial_state_color = Belt_List.reduceReverse(v, undefined, (function (m, x) {
          return Belt_MapString.set(m, x, /* White */0);
        }));
  var initial_state = {
    d: undefined,
    f: undefined,
    pred: undefined,
    color: initial_state_color
  };
  return Belt_List.reduceReverse(v, [
                0,
                initial_state
              ], node)[1];
}

var Dfs = {
  string_of_state: string_of_state,
  depth_first_search: depth_first_search
};

var g = Belt_List.reduceReverse({
      hd: [
        "u",
        {
          hd: "v",
          tl: {
            hd: "x",
            tl: /* [] */0
          }
        }
      ],
      tl: {
        hd: [
          "v",
          {
            hd: "y",
            tl: /* [] */0
          }
        ],
        tl: {
          hd: [
            "w",
            {
              hd: "z",
              tl: {
                hd: "y",
                tl: /* [] */0
              }
            }
          ],
          tl: {
            hd: [
              "x",
              {
                hd: "v",
                tl: /* [] */0
              }
            ],
            tl: {
              hd: [
                "y",
                {
                  hd: "x",
                  tl: /* [] */0
                }
              ],
              tl: {
                hd: [
                  "z",
                  {
                    hd: "z",
                    tl: /* [] */0
                  }
                ],
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, undefined, (function (m, param) {
        return Belt_MapString.set(m, param[0], param[1]);
      }));

var s = depth_first_search(g);

Curry._1(Printf.printf(/* Format */{
          _0: {
            TAG: /* String */2,
            _0: /* No_padding */0,
            _1: {
              TAG: /* Char_literal */12,
              _0: /* '\n' */10,
              _1: /* End_of_format */0
            }
          },
          _1: "%s\n"
        }), string_of_state(s));

var compare = Caml_obj.caml_compare;

var equal = Caml_obj.caml_equal;

var G = Imperative$Graph.Digraph.ConcreteBidirectional({
      compare: compare,
      hash: Hashtbl.hash,
      equal: equal
    });

var g$1 = Curry._2(G.create, undefined, undefined);

var temp = Curry._2(G.create, undefined, undefined);

Belt_List.forEach({
      hd: [
        "u",
        {
          hd: "v",
          tl: {
            hd: "x",
            tl: /* [] */0
          }
        }
      ],
      tl: {
        hd: [
          "v",
          {
            hd: "y",
            tl: /* [] */0
          }
        ],
        tl: {
          hd: [
            "w",
            {
              hd: "z",
              tl: {
                hd: "y",
                tl: /* [] */0
              }
            }
          ],
          tl: {
            hd: [
              "x",
              {
                hd: "v",
                tl: /* [] */0
              }
            ],
            tl: {
              hd: [
                "y",
                {
                  hd: "x",
                  tl: /* [] */0
                }
              ],
              tl: {
                hd: [
                  "z",
                  {
                    hd: "z",
                    tl: /* [] */0
                  }
                ],
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, (function (param) {
        var v = param[0];
        return Belt_List.forEach(param[1], (function (y) {
                      return Curry._3(G.add_edge, g$1, v, y);
                    }));
      }));

var Dfs$1 = Traverse$Graph.Dfs({
      is_directed: G.is_directed,
      V: G.V,
      iter_vertex: G.iter_vertex,
      fold_vertex: G.fold_vertex,
      iter_succ: G.iter_succ,
      fold_succ: G.fold_succ
    });

var prim = Curry._1(Dfs$1.has_cycle, g$1);

console.log(prim);

function pre(v) {
  console.log(" pre " + Curry._1(G.V.label, v) + ".");
  
}

function post(v) {
  console.log("post " + Curry._1(G.V.label, v) + ".");
  
}

console.log("iter: ");

Curry._4(Dfs$1.iter_component, pre, post, g$1, "w");

console.log("prefix: ");

Curry._3(Dfs$1.prefix_component, pre, g$1, "w");

var E = G.E;

function vertex_name(v) {
  return Curry._1(G.V.label, v);
}

function graph_attributes(param) {
  return /* [] */0;
}

function default_vertex_attributes(param) {
  return /* [] */0;
}

function vertex_attributes(param) {
  return /* [] */0;
}

function default_edge_attributes(param) {
  return /* [] */0;
}

function edge_attributes(param) {
  return /* [] */0;
}

function get_subgraph(param) {
  
}

var Gv = Graphviz$Graph.Dot({
      V: {},
      E: {
        src: E.src,
        dst: E.dst
      },
      iter_vertex: G.iter_vertex,
      iter_edges_e: G.iter_edges_e,
      graph_attributes: graph_attributes,
      default_vertex_attributes: default_vertex_attributes,
      vertex_name: vertex_name,
      vertex_attributes: vertex_attributes,
      get_subgraph: get_subgraph,
      default_edge_attributes: default_edge_attributes,
      edge_attributes: edge_attributes
    });

Curry._3(G.add_edge, temp, "a", "b");

Curry._3(G.add_edge, temp, "a", "c");

Curry._3(G.add_edge, temp, "b", "e");

Curry._3(G.add_edge, temp, "a", "a");

Curry._2(Gv.fprint_graph, Format.str_formatter, g$1);

var s$1 = Format.flush_str_formatter(undefined);

console.log("s=");

console.log(s$1);

var Str_map;

export {
  Str_map ,
  log ,
  logList ,
  log2 ,
  logList2 ,
  mapListToString ,
  logStrMapList ,
  Dfs ,
  
}
/* g Not a pure module */
