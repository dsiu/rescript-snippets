// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as OP_ListQueue from "../OP_Ch05_6_Functional_Data_Structure/Queue/OP_ListQueue.mjs";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

var Complex_Synonym = {};

function add(param, param$1) {
  return [
          param[0] + param$1[0],
          param[1] + param$1[1]
        ];
}

var Complex_zero = [
  0,
  0
];

var Complex = {
  zero: Complex_zero,
  add: add
};

var Complex_Encapsulation = {
  Complex: Complex
};

function fill_listqueue(n) {
  var _n = n;
  var _q = OP_ListQueue.M.empty;
  while(true) {
    var q = _q;
    var n$1 = _n;
    if (n$1 === 0) {
      return q;
    }
    _q = OP_ListQueue.M.enqueue(n$1, q);
    _n = n$1 - 1 | 0;
    continue ;
  };
}

var Big_List_Queue = {
  ListQueue: undefined,
  fill_listqueue: fill_listqueue
};

var Fraction_Exn = /* @__PURE__ */Caml_exceptions.create("OP_CH05_11_Exercises.Fraction.Fraction_Exn");

function make(p, q) {
  if (q === 0) {
    throw {
          RE_EXN_ID: Fraction_Exn,
          _1: "Division by zero",
          Error: new Error()
        };
  }
  return {
          p: p,
          q: q
        };
}

function numerator(t) {
  return t.p;
}

function denominator(t) {
  return t.q;
}

function to_string(param) {
  return "" + param.p + " / " + param.q;
}

function to_float(param) {
  return param.p / param.q;
}

function add$1(param, param$1) {
  var q2 = param$1.q;
  var q1 = param.q;
  var p = Math.imul(param.p, q2) + Math.imul(param$1.p, q1) | 0;
  var q = Math.imul(q1, q2);
  return make(p, q);
}

function mul(param, param$1) {
  var p = Math.imul(param.p, param$1.p);
  var q = Math.imul(param.q, param$1.q);
  return make(p, q);
}

var Fraction = {
  make: make,
  numerator: numerator,
  denominator: denominator,
  to_string: to_string,
  to_float: to_float,
  add: add$1,
  mul: mul
};

var Fraction$1 = {
  Fraction_Exn: Fraction_Exn,
  Fraction: Fraction
};

function gcd(_x, _y) {
  while(true) {
    var y = _y;
    var x = _x;
    if (x === 0) {
      return y;
    }
    if (x < y) {
      _y = x;
      _x = y - x | 0;
      continue ;
    }
    _y = x - y | 0;
    _x = y;
    continue ;
  };
}

function make$1(p, q) {
  if (q === 0) {
    throw {
          RE_EXN_ID: Fraction_Exn,
          _1: "Division by zero",
          Error: new Error()
        };
  }
  if (q < 0) {
    throw {
          RE_EXN_ID: Fraction_Exn,
          _1: "Denominator must be positive",
          Error: new Error()
        };
  }
  var g = gcd(p, q);
  return {
          p: Caml_int32.div(p, g),
          q: Caml_int32.div(q, g)
        };
}

function numerator$1(t) {
  return t.p;
}

function denominator$1(t) {
  return t.q;
}

function to_string$1(param) {
  return "" + param.p + " / " + param.q;
}

function to_float$1(param) {
  return param.p / param.q;
}

function add$2(param, param$1) {
  var q2 = param$1.q;
  var q1 = param.q;
  var p = Math.imul(param.p, q2) + Math.imul(param$1.p, q1) | 0;
  var q = Math.imul(q1, q2);
  return make$1(p, q);
}

function mul$1(param, param$1) {
  var p = Math.imul(param.p, param$1.p);
  var q = Math.imul(param.q, param$1.q);
  return make$1(p, q);
}

var Fraction$2 = {
  make: make$1,
  numerator: numerator$1,
  denominator: denominator$1,
  to_string: to_string$1,
  to_float: to_float$1,
  add: add$2,
  mul: mul$1
};

var prim = to_string$1(make$1(12, 6));

console.log(prim);

var Fraction_Reduced = {
  gcd: gcd,
  Fraction: Fraction$2
};

export {
  log ,
  log2 ,
  Complex_Synonym ,
  Complex_Encapsulation ,
  Big_List_Queue ,
  Fraction$1 as Fraction,
  Fraction_Reduced ,
}
/* prim Not a pure module */
