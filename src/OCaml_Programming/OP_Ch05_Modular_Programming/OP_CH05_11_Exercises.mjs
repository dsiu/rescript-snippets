// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Id from "rescript/lib/es6/Belt_Id.js";
import * as Belt_Map from "rescript/lib/es6/Belt_Map.js";
import * as OP_ListQueue from "../OP_Ch05_6_Functional_Data_Structure/Queue/OP_ListQueue.mjs";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Primitive_object from "rescript/lib/es6/Primitive_object.js";
import * as Primitive_exceptions from "rescript/lib/es6/Primitive_exceptions.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

let Complex_Synonym = {};

function add(param, param$1) {
  return [
    param[0] + param$1[0],
    param[1] + param$1[1]
  ];
}

let Complex_zero = [
  0,
  0
];

let Complex = {
  zero: Complex_zero,
  add: add
};

let Complex_Encapsulation = {
  Complex: Complex
};

function fill_listqueue(n) {
  let _n = n;
  let _q = OP_ListQueue.M.empty;
  while (true) {
    let q = _q;
    let n$1 = _n;
    if (n$1 === 0) {
      return q;
    }
    _q = OP_ListQueue.M.enqueue(n$1, q);
    _n = n$1 - 1 | 0;
    continue;
  };
}

let Big_List_Queue = {
  ListQueue: undefined,
  fill_listqueue: fill_listqueue
};

let Fraction_Exn = /* @__PURE__ */Primitive_exceptions.create("OP_CH05_11_Exercises.Fraction.Fraction_Exn");

function make(p, q) {
  if (q === 0) {
    throw {
      RE_EXN_ID: Fraction_Exn,
      _1: "Division by zero",
      Error: new Error()
    };
  }
  return {
    p: p,
    q: q
  };
}

function numerator(t) {
  return t.p;
}

function denominator(t) {
  return t.q;
}

function to_string(param) {
  return param.p.toString() + " / " + param.q.toString();
}

function to_float(param) {
  return param.p / param.q;
}

function add$1(param, param$1) {
  let q2 = param$1.q;
  let q1 = param.q;
  let p = Math.imul(param.p, q2) + Math.imul(param$1.p, q1) | 0;
  let q = Math.imul(q1, q2);
  return make(p, q);
}

function mul(param, param$1) {
  let p = Math.imul(param.p, param$1.p);
  let q = Math.imul(param.q, param$1.q);
  return make(p, q);
}

let Fraction = {
  make: make,
  numerator: numerator,
  denominator: denominator,
  to_string: to_string,
  to_float: to_float,
  add: add$1,
  mul: mul
};

let Fraction$1 = {
  Fraction_Exn: Fraction_Exn,
  Fraction: Fraction
};

function gcd(_x, _y) {
  while (true) {
    let y = _y;
    let x = _x;
    if (x === 0) {
      return y;
    }
    if (x < y) {
      _y = x;
      _x = y - x | 0;
      continue;
    }
    _y = x - y | 0;
    _x = y;
    continue;
  };
}

function make$1(p, q) {
  if (q === 0) {
    throw {
      RE_EXN_ID: Fraction_Exn,
      _1: "Division by zero",
      Error: new Error()
    };
  }
  if (q < 0) {
    throw {
      RE_EXN_ID: Fraction_Exn,
      _1: "Denominator must be positive",
      Error: new Error()
    };
  }
  let g = gcd(p, q);
  return {
    p: Primitive_int.div(p, g),
    q: Primitive_int.div(q, g)
  };
}

function numerator$1(t) {
  return t.p;
}

function denominator$1(t) {
  return t.q;
}

function to_string$1(param) {
  return param.p.toString() + " / " + param.q.toString();
}

function to_float$1(param) {
  return param.p / param.q;
}

function add$2(param, param$1) {
  let q2 = param$1.q;
  let q1 = param.q;
  let p = Math.imul(param.p, q2) + Math.imul(param$1.p, q1) | 0;
  let q = Math.imul(q1, q2);
  return make$1(p, q);
}

function mul$1(param, param$1) {
  let p = Math.imul(param.p, param$1.p);
  let q = Math.imul(param.q, param$1.q);
  return make$1(p, q);
}

let Fraction$2 = {
  make: make$1,
  numerator: numerator$1,
  denominator: denominator$1,
  to_string: to_string$1,
  to_float: to_float$1,
  add: add$2,
  mul: mul$1
};

let prim = to_string$1(make$1(12, 6));

console.log(prim);

let Fraction_Reduced = {
  gcd: gcd,
  Fraction: Fraction$2
};

let cmp = Primitive_object.compare;

let CharCmp = Belt_Id.MakeComparableU({
  cmp: cmp
});

let empty = Belt_Map.make(CharCmp);

let nm = Belt_Map.set(Belt_Map.set(Belt_Map.set(Belt_Map.set(empty, /* 'A' */65, "Alpha"), /* 'E' */69, "Echo"), /* 'S' */83, "Sierra"), /* 'V' */86, "Victor");

let prim$1 = Belt_Map.toArray(nm);

console.log(prim$1);

let Char_Map = {
  CharCmp: CharCmp,
  $$Map: undefined,
  empty: empty,
  nm: nm
};

function cmp$1(a, b) {
  let x = a.month - b.month | 0;
  if (x !== 0) {
    return x;
  } else {
    return a.day - b.day | 0;
  }
}

let DateCmp = Belt_Id.MakeComparableU({
  cmp: cmp$1
});

let empty$1 = Belt_Map.make(DateCmp);

let dm = Belt_Map.set(empty$1, {
  month: 12,
  day: 1
}, 1);

let prim$2 = Belt_Map.toArray(dm);

console.log(prim$2);

let Date_Order = {
  DateCmp: DateCmp,
  $$Map: undefined,
  empty: empty$1,
  dm: dm
};

export {
  log,
  log2,
  Complex_Synonym,
  Complex_Encapsulation,
  Big_List_Queue,
  Fraction$1 as Fraction,
  Fraction_Reduced,
  Char_Map,
  Date_Order,
}
/* prim Not a pure module */
