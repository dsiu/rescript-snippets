// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "@rescript/runtime/lib/es6/Belt_List.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function strToChar(__x) {
  return __x[0];
}

function charToStr(prim) {
  return String(prim);
}

function parseA(str) {
  if (str.length === 0) {
    return [
      false,
      ""
    ];
  }
  if (str.charAt(0) !== "A") {
    return [
      false,
      str
    ];
  }
  let remaining = str.slice(1);
  return [
    true,
    remaining
  ];
}

console.log("Understanding Parser Combinators");

let inputABC = "ABC";

let __x = parseA(inputABC);

console.log("parseA", __x);

let inputZBC = "ZBC";

let __x$1 = parseA(inputZBC);

console.log("parseA", __x$1);

console.log("");

console.log("-- Parsing a specified character");

function pchar(charToMatch, str) {
  if (str.length === 0) {
    return [
      "No more input",
      ""
    ];
  }
  let first = str.charAt(0);
  if (first === charToMatch) {
    let remaining = str.slice(1);
    let msg = `Found ` + String(charToMatch);
    return [
      msg,
      remaining
    ];
  }
  let msg$1 = `Expecting '` + String(charToMatch) + `'. Got '` + String(first) + `'`;
  return [
    msg$1,
    str
  ];
}

let __x$2 = pchar("A", inputABC);

console.log("pchar", __x$2);

let __x$3 = pchar("A", inputZBC);

console.log("pchar", __x$3);

let __x$4 = pchar("Z", inputZBC);

console.log("pchar", __x$4);

console.log("");

console.log("-- Returning a Success/Failure");

function pchar$1(charToMatch, str) {
  if (str.length === 0) {
    return {
      TAG: "Failure",
      _0: "No more input"
    };
  }
  let first = str.charAt(0);
  if (first === charToMatch) {
    let remaining = str.slice(1);
    return {
      TAG: "Success",
      _0: [
        charToMatch,
        remaining
      ]
    };
  }
  let msg = `Expecting '` + String(charToMatch) + `'. Got '` + String(first) + `'`;
  return {
    TAG: "Failure",
    _0: msg
  };
}

let __x$5 = pchar$1("A", inputABC);

console.log("pchar", __x$5);

let __x$6 = pchar$1("A", inputZBC);

console.log("pchar", __x$6);

console.log("");

console.log("-- Rewriting with an inner function");

function pchar$2(charToMatch) {
  return str => {
    if (str.length === 0) {
      return {
        TAG: "Failure",
        _0: "No more input"
      };
    }
    let first = str.charAt(0);
    if (first === charToMatch) {
      let remaining = str.slice(1);
      return {
        TAG: "Success",
        _0: [
          charToMatch,
          remaining
        ]
      };
    }
    let msg = `Expecting '` + String(charToMatch) + `'. Got '` + String(first) + `'`;
    return {
      TAG: "Failure",
      _0: msg
    };
  };
}

console.log("");

console.log("-- The benefits of the curried implementation");

let parseA$1 = pchar$2("A");

let __x$7 = parseA$1(inputABC);

console.log("parseA", __x$7);

let __x$8 = parseA$1(inputZBC);

console.log("parseA", __x$8);

console.log("Encapsulating the parsing function in a type");

function pchar$3(charToMatch) {
  let innerFn = str => {
    if (str.length === 0) {
      return {
        TAG: "Failure",
        _0: "No more input"
      };
    }
    let first = str.charAt(0);
    if (first === charToMatch) {
      let remaining = str.slice(1);
      return {
        TAG: "Success",
        _0: [
          charToMatch,
          remaining
        ]
      };
    }
    let msg = `Expecting '` + String(charToMatch) + `'. Got '` + String(first) + `'`;
    return {
      TAG: "Failure",
      _0: msg
    };
  };
  return {
    TAG: "Parser",
    _0: innerFn
  };
}

console.log("");

console.log("-- Testing the wrapped function");

function run(parser, input) {
  return parser._0(input);
}

let parseA$2 = pchar$3("A");

let __x$9 = run(parseA$2, inputABC);

console.log("parseA", __x$9);

let __x$10 = run(parseA$2, inputZBC);

console.log("parseA", __x$10);

console.log("");

console.log("-- Combining two parsers in sequence");

function andThen(parser1, parser2) {
  let innerFn = input => {
    let result1 = run(parser1, input);
    if (result1.TAG !== "Success") {
      return {
        TAG: "Failure",
        _0: result1._0
      };
    }
    let match = result1._0;
    let result2 = run(parser2, match[1]);
    if (result2.TAG !== "Success") {
      return {
        TAG: "Failure",
        _0: result2._0
      };
    }
    let match$1 = result2._0;
    let newValue_0 = match[0];
    let newValue_1 = match$1[0];
    let newValue = [
      newValue_0,
      newValue_1
    ];
    return {
      TAG: "Success",
      _0: [
        newValue,
        match$1[1]
      ]
    };
  };
  return {
    TAG: "Parser",
    _0: innerFn
  };
}

console.log("");

console.log("-- Testing andThen");

let parseA$3 = pchar$3("A");

let parseB = pchar$3("B");

let parseAThenB = andThen(parseA$3, parseB);

let __x$11 = run(parseAThenB, "ABC");

console.log("parseAThenB ABC", __x$11);

let __x$12 = run(parseAThenB, "ZBC");

console.log("parseAThenB ZBC", __x$12);

let __x$13 = run(parseAThenB, "AZC");

console.log("parseAThenB AZC", __x$13);

console.log("");

console.log("-- Choosing between two parsers");

function orElse(parser1, parser2) {
  let innerFn = input => {
    let result1 = run(parser1, input);
    if (result1.TAG === "Success") {
      return result1;
    } else {
      return run(parser2, input);
    }
  };
  return {
    TAG: "Parser",
    _0: innerFn
  };
}

console.log("");

console.log("-- Testing orElse");

let parseA$4 = pchar$3("A");

let parseB$1 = pchar$3("B");

let parseAOrElseB = orElse(parseA$4, parseB$1);

let __x$14 = run(parseAOrElseB, "AZZ");

console.log("parseAOrElseB AZZ", __x$14);

let __x$15 = run(parseAOrElseB, "BZZ");

console.log("parseAOrElseB BZZ", __x$15);

let __x$16 = run(parseAOrElseB, "CZZ");

console.log("parseAOrElseB CZZ", __x$16);

console.log("");

console.log("-- Combining andThen and orElse");

let parseA$5 = pchar$3("A");

let parseB$2 = pchar$3("B");

let parseC = pchar$3("C");

let bOrElseC = orElse(parseB$2, parseC);

let aAndThenBorC = andThen(parseA$5, bOrElseC);

let __x$17 = run(aAndThenBorC, "ABZ");

console.log("aAndThenBorC ABZ", __x$17);

let __x$18 = run(aAndThenBorC, "ACZ");

console.log("aAndThenBorC ACZ", __x$18);

let __x$19 = run(aAndThenBorC, "QBZ");

console.log("aAndThenBorC QBZ", __x$19);

let __x$20 = run(aAndThenBorC, "AQZ");

console.log("aAndThenBorC AQZ", __x$20);

console.log("");

console.log("-- Choosing from a list of parsers");

function choice(listOfParsers) {
  return Belt_List.reduce(listOfParsers, {
    TAG: "Parser",
    _0: string => ({
      TAG: "Failure",
      _0: "Initial parser"
    })
  }, orElse);
}

function anyOf(listOfChars) {
  return choice(Belt_List.map(listOfChars, pchar$3));
}

let listOfChars = Belt_List.fromArray("abcdefghijklmnopqrstuvwxyz".split(""));

let parseLowercase = choice(Belt_List.map(listOfChars, pchar$3));

let listOfChars$1 = Belt_List.fromArray("0123456789".split(""));

let parseDigit = choice(Belt_List.map(listOfChars$1, pchar$3));

let __x$21 = run(parseLowercase, "aBC");

console.log("parseLowercase aBC", __x$21);

let __x$22 = run(parseLowercase, "ABC");

console.log("parseLowercase ABC", __x$22);

let __x$23 = run(parseDigit, "1ABC");

console.log("parseDigit 1ABC", __x$23);

let __x$24 = run(parseDigit, "9ABC");

console.log("parseDigit 9ABC", __x$24);

let __x$25 = run(parseDigit, "|ABC");

console.log("parseDigit |ABC", __x$25);

export {
  log,
  log2,
  strToChar,
  charToStr,
  inputABC,
  inputZBC,
  pchar$3 as pchar,
  run,
  andThen,
  parseAThenB,
  orElse,
  parseAOrElseB,
  parseA$5 as parseA,
  parseB$2 as parseB,
  parseC,
  bOrElseC,
  aAndThenBorC,
  choice,
  anyOf,
  parseLowercase,
  parseDigit,
}
/*  Not a pure module */
