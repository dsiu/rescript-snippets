// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$String from "rescript/lib/es6/string.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_string from "rescript/lib/es6/caml_string.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function strToChar(__x) {
  return Caml_string.get(__x, 0);
}

function charToStr(__x) {
  return $$String.make(1, __x);
}

function parseA(str) {
  if (str.length === 0) {
    return [
            false,
            ""
          ];
  }
  if (Caml_string.get(str.charAt(0), 0) !== /* 'A' */65) {
    return [
            false,
            str
          ];
  }
  var remaining = str.slice(1);
  return [
          true,
          remaining
        ];
}

console.log("Understanding Parser Combinators");

var inputABC = "ABC";

((function (__x) {
        console.log("parseA", __x);
      })(parseA(inputABC)));

var inputZBC = "ZBC";

((function (__x) {
        console.log("parseA", __x);
      })(parseA(inputZBC)));

console.log("");

console.log("-- Parsing a specified character");

function pchar(charToMatch, str) {
  if (str.length === 0) {
    return [
            "No more input",
            ""
          ];
  }
  var first = Caml_string.get(str.charAt(0), 0);
  if (first === charToMatch) {
    var remaining = str.slice(1);
    var msg = "Found " + $$String.make(1, charToMatch);
    return [
            msg,
            remaining
          ];
  }
  var msg$1 = "Expecting '" + $$String.make(1, charToMatch) + "'. Got '" + $$String.make(1, first) + "'";
  return [
          msg$1,
          str
        ];
}

((function (__x) {
        console.log("pchar", __x);
      })(pchar(/* 'A' */65, inputABC)));

((function (__x) {
        console.log("pchar", __x);
      })(pchar(/* 'A' */65, inputZBC)));

((function (__x) {
        console.log("pchar", __x);
      })(pchar(/* 'Z' */90, inputZBC)));

console.log("");

console.log("-- Returning a Success/Failure");

function pchar$1(charToMatch, str) {
  if (str.length === 0) {
    return {
            TAG: "Failure",
            _0: "No more input"
          };
  }
  var first = Caml_string.get(str.charAt(0), 0);
  if (first === charToMatch) {
    var remaining = str.slice(1);
    return {
            TAG: "Success",
            _0: [
              charToMatch,
              remaining
            ]
          };
  }
  var msg = "Expecting '" + $$String.make(1, charToMatch) + "'. Got '" + $$String.make(1, first) + "'";
  return {
          TAG: "Failure",
          _0: msg
        };
}

((function (__x) {
        console.log("pchar", __x);
      })(pchar$1(/* 'A' */65, inputABC)));

((function (__x) {
        console.log("pchar", __x);
      })(pchar$1(/* 'A' */65, inputZBC)));

console.log("");

console.log("-- Rewriting with an inner function");

function pchar$2(charToMatch) {
  return function (str) {
    if (str.length === 0) {
      return {
              TAG: "Failure",
              _0: "No more input"
            };
    }
    var first = Caml_string.get(str.charAt(0), 0);
    if (first === charToMatch) {
      var remaining = str.slice(1);
      return {
              TAG: "Success",
              _0: [
                charToMatch,
                remaining
              ]
            };
    }
    var msg = "Expecting '" + $$String.make(1, charToMatch) + "'. Got '" + $$String.make(1, first) + "'";
    return {
            TAG: "Failure",
            _0: msg
          };
  };
}

console.log("");

console.log("-- The benefits of the curried implementation");

var parseA$1 = pchar$2(/* 'A' */65);

((function (__x) {
        console.log("parseA", __x);
      })(parseA$1(inputABC)));

((function (__x) {
        console.log("parseA", __x);
      })(parseA$1(inputZBC)));

console.log("Encapsulating the parsing function in a type");

function pchar$3(charToMatch) {
  var innerFn = function (str) {
    if (str.length === 0) {
      return {
              TAG: "Failure",
              _0: "No more input"
            };
    }
    var first = Caml_string.get(str.charAt(0), 0);
    if (first === charToMatch) {
      var remaining = str.slice(1);
      return {
              TAG: "Success",
              _0: [
                charToMatch,
                remaining
              ]
            };
    }
    var msg = "Expecting '" + $$String.make(1, charToMatch) + "'. Got '" + $$String.make(1, first) + "'";
    return {
            TAG: "Failure",
            _0: msg
          };
  };
  return {
          TAG: "Parser",
          _0: innerFn
        };
}

console.log("");

console.log("-- Testing the wrapped function");

function run(parser, input) {
  return parser._0(input);
}

var parseA$2 = pchar$3(/* 'A' */65);

((function (__x) {
        console.log("parseA", __x);
      })(run(parseA$2, inputABC)));

((function (__x) {
        console.log("parseA", __x);
      })(run(parseA$2, inputZBC)));

console.log("");

console.log("-- Combining two parsers in sequence");

function andThen(parser1, parser2) {
  var innerFn = function (input) {
    var result1 = run(parser1, input);
    if (result1.TAG !== "Success") {
      return {
              TAG: "Failure",
              _0: result1._0
            };
    }
    var match = result1._0;
    var result2 = run(parser2, match[1]);
    if (result2.TAG !== "Success") {
      return {
              TAG: "Failure",
              _0: result2._0
            };
    }
    var match$1 = result2._0;
    var newValue_0 = match[0];
    var newValue_1 = match$1[0];
    var newValue = [
      newValue_0,
      newValue_1
    ];
    return {
            TAG: "Success",
            _0: [
              newValue,
              match$1[1]
            ]
          };
  };
  return {
          TAG: "Parser",
          _0: innerFn
        };
}

console.log("");

console.log("-- Testing andThen");

var parseA$3 = pchar$3(/* 'A' */65);

var parseB = pchar$3(/* 'B' */66);

var parseAThenB = andThen(parseA$3, parseB);

((function (__x) {
        console.log("parseAThenB ABC", __x);
      })(run(parseAThenB, "ABC")));

((function (__x) {
        console.log("parseAThenB ZBC", __x);
      })(run(parseAThenB, "ZBC")));

((function (__x) {
        console.log("parseAThenB AZC", __x);
      })(run(parseAThenB, "AZC")));

console.log("");

console.log("-- Choosing between two parsers");

function orElse(parser1, parser2) {
  var innerFn = function (input) {
    var result1 = run(parser1, input);
    if (result1.TAG === "Success") {
      return result1;
    } else {
      return run(parser2, input);
    }
  };
  return {
          TAG: "Parser",
          _0: innerFn
        };
}

console.log("");

console.log("-- Testing orElse");

var parseA$4 = pchar$3(/* 'A' */65);

var parseB$1 = pchar$3(/* 'B' */66);

var parseAOrElseB = orElse(parseA$4, parseB$1);

((function (__x) {
        console.log("parseAOrElseB AZZ", __x);
      })(run(parseAOrElseB, "AZZ")));

((function (__x) {
        console.log("parseAOrElseB BZZ", __x);
      })(run(parseAOrElseB, "BZZ")));

((function (__x) {
        console.log("parseAOrElseB CZZ", __x);
      })(run(parseAOrElseB, "CZZ")));

console.log("");

console.log("-- Combining andThen and orElse");

var parseA$5 = pchar$3(/* 'A' */65);

var parseB$2 = pchar$3(/* 'B' */66);

var parseC = pchar$3(/* 'C' */67);

var bOrElseC = orElse(parseB$2, parseC);

var aAndThenBorC = andThen(parseA$5, bOrElseC);

((function (__x) {
        console.log("aAndThenBorC ABZ", __x);
      })(run(aAndThenBorC, "ABZ")));

((function (__x) {
        console.log("aAndThenBorC ACZ", __x);
      })(run(aAndThenBorC, "ACZ")));

((function (__x) {
        console.log("aAndThenBorC QBZ", __x);
      })(run(aAndThenBorC, "QBZ")));

((function (__x) {
        console.log("aAndThenBorC AQZ", __x);
      })(run(aAndThenBorC, "AQZ")));

console.log("");

console.log("-- Choosing from a list of parsers");

function choice(listOfParsers) {
  return Belt_List.reduce(listOfParsers, {
              TAG: "Parser",
              _0: (function (string) {
                  return {
                          TAG: "Failure",
                          _0: "Initial parser"
                        };
                })
            }, orElse);
}

function anyOf(listOfChars) {
  return choice(Belt_List.map(listOfChars, pchar$3));
}

var parseLowercase = anyOf(Belt_List.fromArray(Belt_Array.map("abcdefghijklmnopqrstuvwxyz".split(""), strToChar)));

var parseDigit = anyOf(Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar)));

((function (__x) {
        console.log("parseLowercase aBC", __x);
      })(run(parseLowercase, "aBC")));

((function (__x) {
        console.log("parseLowercase ABC", __x);
      })(run(parseLowercase, "ABC")));

((function (__x) {
        console.log("parseDigit 1ABC", __x);
      })(run(parseDigit, "1ABC")));

((function (__x) {
        console.log("parseDigit 9ABC", __x);
      })(run(parseDigit, "9ABC")));

((function (__x) {
        console.log("parseDigit |ABC", __x);
      })(run(parseDigit, "|ABC")));

export {
  log ,
  log2 ,
  strToChar ,
  charToStr ,
  inputABC ,
  inputZBC ,
  pchar$3 as pchar,
  run ,
  andThen ,
  parseAThenB ,
  orElse ,
  parseAOrElseB ,
  parseA$5 as parseA,
  parseB$2 as parseB,
  parseC ,
  bOrElseC ,
  aAndThenBorC ,
  choice ,
  anyOf ,
  parseLowercase ,
  parseDigit ,
}
/*  Not a pure module */
