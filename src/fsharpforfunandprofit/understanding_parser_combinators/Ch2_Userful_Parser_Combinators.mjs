// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_string from "rescript/lib/es6/caml_string.js";

function log(prim) {
  console.log(prim);
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
}

function strToChar(__x) {
  return Caml_string.get(__x, 0);
}

function charToStr(__x) {
  return $$String.make(1, __x);
}

function pchar(charToMatch) {
  var innerFn = function (str) {
    if (str.length === 0) {
      return {
              TAG: /* Failure */1,
              _0: "No more input"
            };
    }
    var first = Caml_string.get(str.charAt(0), 0);
    if (first === charToMatch) {
      var remaining = str.slice(1);
      return {
              TAG: /* Success */0,
              _0: [
                charToMatch,
                remaining
              ]
            };
    }
    var msg = "Expecting '" + $$String.make(1, charToMatch) + "'. Got '" + $$String.make(1, first) + "'";
    return {
            TAG: /* Failure */1,
            _0: msg
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function run(parser, input) {
  return Curry._1(parser._0, input);
}

function andThen(parser1, parser2) {
  var innerFn = function (input) {
    var result1 = run(parser1, input);
    if (result1.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: result1._0
            };
    }
    var match = result1._0;
    var result2 = run(parser2, match[1]);
    if (result2.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: result2._0
            };
    }
    var match$1 = result2._0;
    var newValue_0 = match[0];
    var newValue_1 = match$1[0];
    var newValue = [
      newValue_0,
      newValue_1
    ];
    return {
            TAG: /* Success */0,
            _0: [
              newValue,
              match$1[1]
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function orElse(parser1, parser2) {
  var innerFn = function (input) {
    var result1 = run(parser1, input);
    if (result1.TAG === /* Success */0) {
      return result1;
    } else {
      return run(parser2, input);
    }
  };
  return /* Parser */{
          _0: innerFn
        };
}

function choice(listOfParsers) {
  return Belt_List.reduce(listOfParsers, /* Parser */{
              _0: (function (string) {
                  return {
                          TAG: /* Failure */1,
                          _0: "Initial parser"
                        };
                })
            }, orElse);
}

console.log("Building a useful set of parser combinators");

console.log("-- 1. Transforming the contents of a parser with map");

var listOfChars = Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar));

var parseDigit = choice(Belt_List.map(listOfChars, pchar));

var parseThreeDigits = andThen(andThen(parseDigit, parseDigit), parseDigit);

var prim1 = run(parseThreeDigits, "123A");

console.log("parseThreeDigits 123A", prim1);

function mapP(f, parser) {
  var innerFn = function (input) {
    var result = run(parser, input);
    if (result.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: result._0
            };
    }
    var match = result._0;
    var newValue = Curry._1(f, match[0]);
    return {
            TAG: /* Success */0,
            _0: [
              newValue,
              match[1]
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function transformTuple(param) {
  var match = param[0];
  return $$String.make(1, match[0]) + $$String.make(1, match[1]) + $$String.make(1, param[1]);
}

var parseThreeDigitsAsStr = mapP(transformTuple, parseThreeDigits);

var prim1$1 = run(parseThreeDigitsAsStr, "123A");

console.log("parseThreeDigitsAsStr 123A", prim1$1);

var __x = andThen(andThen(parseDigit, parseDigit), parseDigit);

var parseThreeDigitsAsStr$1 = mapP((function (param) {
        var match = param[0];
        return $$String.make(1, match[0]) + $$String.make(1, match[1]) + $$String.make(1, param[1]);
      }), __x);

var prim1$2 = run(parseThreeDigitsAsStr$1, "123A");

console.log("parseThreeDigitsAsStr 123A", prim1$2);

var parseThreeDigitsAsInt = mapP((function (s) {
        return Belt_Option.getExn(Belt_Int.fromString(s));
      }), parseThreeDigitsAsStr$1);

var prim1$3 = run(parseThreeDigitsAsInt, "123A");

console.log("parseThreeDigitsAsInt 123A", prim1$3);

console.log("");

console.log("-- 2. Lifting functions to the world of Parsers");

function returnP(x) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              x,
              input
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function applyP(fP, xP) {
  var __x = andThen(fP, xP);
  return mapP((function (param) {
                return Curry._1(param[0], param[1]);
              }), __x);
}

function lift2(f, xP, yP) {
  return applyP(applyP(returnP(f), xP), yP);
}

function addP(param, param$1) {
  return lift2((function (prim0, prim1) {
                return prim0 + prim1 | 0;
              }), param, param$1);
}

function startsWith(str, prefix) {
  return str.startsWith(prefix);
}

function startWithP(param, param$1) {
  return lift2(startsWith, param, param$1);
}

console.log("");

console.log("-- 3. Turning a list of Parsers into a single Parser");

function sequence(parserList) {
  var cons = function (head, tail) {
    return {
            hd: head,
            tl: tail
          };
  };
  if (parserList) {
    return lift2(cons, parserList.hd, sequence(parserList.tl));
  }
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              /* [] */0,
              input
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

var parsers_0 = pchar(/* 'A' */65);

var parsers_1 = {
  hd: pchar(/* 'B' */66),
  tl: {
    hd: pchar(/* 'C' */67),
    tl: /* [] */0
  }
};

var parsers = {
  hd: parsers_0,
  tl: parsers_1
};

var combined = sequence(parsers);

var prim1$4 = run(combined, "ABCD");

console.log("combined ABCD", prim1$4);

console.log("");

console.log("-- Implementing the pstring parser");

function charListToStr(charList) {
  return Belt_List.toArray(Belt_List.map(charList, charToStr)).join("");
}

function pstring(str) {
  return mapP(charListToStr, sequence(Belt_List.fromArray(Belt_Array.map(Belt_Array.map(str.split(""), strToChar), pchar))));
}

var parseABC = pstring("ABC");

var prim1$5 = run(parseABC, "ABCDE");

console.log("parseABC ABCDE", prim1$5);

var prim1$6 = run(parseABC, "A|CDE");

console.log("parseABC A|CDE", prim1$6);

var prim1$7 = run(parseABC, "AB|DE");

console.log("parseABC AB|DE", prim1$7);

console.log("");

console.log("-- 4. Matching a parser multiple times");

function parseZeroOrMore(parser, input) {
  var firstResult = run(parser, input);
  if (firstResult.TAG !== /* Success */0) {
    return [
            /* [] */0,
            input
          ];
  }
  var match = firstResult._0;
  var match$1 = parseZeroOrMore(parser, match[1]);
  var values_0 = match[0];
  var values_1 = match$1[0];
  var values = {
    hd: values_0,
    tl: values_1
  };
  return [
          values,
          match$1[1]
        ];
}

function many(parser) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: parseZeroOrMore(parser, input)
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

var manyA = many(pchar(/* 'A' */65));

var prim1$8 = run(manyA, "ABCD");

console.log("manyA ABCD", prim1$8);

var prim1$9 = run(manyA, "AACD");

console.log("manyA AACD", prim1$9);

var prim1$10 = run(manyA, "AAAD");

console.log("manyA AAAD", prim1$10);

var prim1$11 = run(manyA, "|BCD");

console.log("manyA |BCD", prim1$11);

var manyAB = many(pstring("AB"));

var prim1$12 = run(manyAB, "ABCD");

console.log("manyAB ABCD", prim1$12);

var prim1$13 = run(manyAB, "ABABCD");

console.log("manyAB ABABCD", prim1$13);

var prim1$14 = run(manyAB, "ZCD");

console.log("manyAB ZCD", prim1$14);

var prim1$15 = run(manyAB, "AZCD");

console.log("manyAB AZCD", prim1$15);

var whitespaceChar = choice(Belt_List.map({
          hd: /* ' ' */32,
          tl: {
            hd: /* '\t' */9,
            tl: {
              hd: /* '\n' */10,
              tl: /* [] */0
            }
          }
        }, pchar));

var whitespace = many(whitespaceChar);

var prim1$16 = run(whitespace, "ABC");

console.log("whitespace ABC", prim1$16);

var prim1$17 = run(whitespace, " ABC");

console.log("whitespace  ABC", prim1$17);

var prim1$18 = run(whitespace, " \tABC");

console.log("whitespace \tABC", prim1$18);

console.log("");

console.log("-- Defining many1");

function many1(parser) {
  var innerFn = function (input) {
    var firstResult = run(parser, input);
    if (firstResult.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: firstResult._0
            };
    }
    var match = firstResult._0;
    var match$1 = parseZeroOrMore(parser, match[1]);
    var values_0 = match[0];
    var values_1 = match$1[0];
    var values = {
      hd: values_0,
      tl: values_1
    };
    return {
            TAG: /* Success */0,
            _0: [
              values,
              match$1[1]
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

var listOfChars$1 = Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar));

var digit = choice(Belt_List.map(listOfChars$1, pchar));

var digits = many1(digit);

var prim1$19 = run(digits, "1ABC");

console.log("digits 1ABC", prim1$19);

var prim1$20 = run(digits, "12BC");

console.log("digits 12BC", prim1$20);

var prim1$21 = run(digits, "123C");

console.log("digits 123C", prim1$21);

var prim1$22 = run(digits, "1234");

console.log("digits 1234", prim1$22);

var prim1$23 = run(digits, "ABC");

console.log("digits ABC", prim1$23);

console.log("");

console.log("-- Parsing an integer");

function resultToInt(digitList) {
  return Belt_Option.getExn(Belt_Int.fromString(Belt_List.toArray(Belt_List.map(digitList, charToStr)).join("")));
}

var listOfChars$2 = Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar));

var digit$1 = choice(Belt_List.map(listOfChars$2, pchar));

var digits$1 = many1(digit$1);

var pint = mapP(resultToInt, digits$1);

var prim1$24 = run(pint, "1ABC");

console.log("pint 1ABC", prim1$24);

var prim1$25 = run(pint, "12BC");

console.log("pint 12BC", prim1$25);

var prim1$26 = run(pint, "123C");

console.log("pint 123C", prim1$26);

var prim1$27 = run(pint, "1234");

console.log("pint 1234", prim1$27);

var prim1$28 = run(pint, "ABC");

console.log("pint ABC", prim1$28);

console.log("");

console.log("-- 5. Matching a parser zero or one time");

function opt(p) {
  var some = mapP((function (x) {
          return Caml_option.some(x);
        }), p);
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              undefined,
              input
            ]
          };
  };
  var none = /* Parser */{
    _0: innerFn
  };
  return orElse(some, none);
}

var digitThenSemicolon = andThen(digit, opt(pchar(/* ';' */59)));

var prim1$29 = run(digitThenSemicolon, "1;");

console.log("digitThenSemicolon 1;", prim1$29);

var prim1$30 = run(digitThenSemicolon, "1");

console.log("digitThenSemicolon 1;", prim1$30);

function resultToInt$1(param) {
  var i = Belt_Option.getExn(Belt_Int.fromString(Belt_List.toArray(Belt_List.map(param[1], charToStr)).join("")));
  if (param[0] !== undefined) {
    return -i | 0;
  } else {
    return i;
  }
}

var listOfChars$3 = Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar));

var digit$2 = choice(Belt_List.map(listOfChars$3, pchar));

var digits$2 = many1(digit$2);

var pint$1 = mapP(resultToInt$1, andThen(opt(pchar(/* '-' */45)), digits$2));

var prim1$31 = run(pint$1, "123C");

console.log("pint 123C", prim1$31);

var prim1$32 = run(pint$1, "-123C");

console.log("pint 123C", prim1$32);

console.log("");

console.log("-- 6. Throwing results away");

function keepLeft(p1, p2) {
  var __x = andThen(p1, p2);
  return mapP((function (param) {
                return param[0];
              }), __x);
}

function keepRight(p1, p2) {
  var __x = andThen(p1, p2);
  return mapP((function (param) {
                return param[1];
              }), __x);
}

var digitThenSemicolon$1 = keepLeft(digit, opt(pchar(/* ';' */59)));

var prim1$33 = run(digitThenSemicolon$1, "1;");

console.log("digitThenSemicolon 1;", prim1$33);

var prim1$34 = run(digitThenSemicolon$1, "1");

console.log("digitThenSemicolon 1;", prim1$34);

var whitespaceChar$1 = choice(Belt_List.map({
          hd: /* ' ' */32,
          tl: {
            hd: /* '\t' */9,
            tl: {
              hd: /* '\n' */10,
              tl: /* [] */0
            }
          }
        }, pchar));

var whitespace$1 = many(whitespaceChar$1);

var ab = pstring("AB");

var cd = pstring("CD");

var ab_cd = andThen(keepLeft(ab, whitespace$1), cd);

var prim1$35 = run(ab_cd, "AB \t\nCD");

console.log("ab_cd AB \\t\\nCD", prim1$35);

console.log("");

console.log("-- Introducing between");

function between(p1, p2, p3) {
  return keepLeft(keepRight(p1, p2), p3);
}

var pdoublequote = pchar(/* '"' */34);

var quotedInterger = between(pdoublequote, pint$1, pdoublequote);

var prim1$36 = run(quotedInterger, "\"1234\"");

console.log("quotedInterger \"1234\"", prim1$36);

var prim1$37 = run(quotedInterger, "1234");

console.log("quotedInterger \"1234\"", prim1$37);

console.log("");

console.log("-- 7. Parsing lists with separators");

function sepBy1(p, sep) {
  var sepThenP = keepRight(sep, p);
  var __x = andThen(p, many(sepThenP));
  return mapP((function (param) {
                return {
                        hd: param[0],
                        tl: param[1]
                      };
              }), __x);
}

function sepBy(p, sep) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              /* [] */0,
              input
            ]
          };
  };
  return orElse(sepBy1(p, sep), /* Parser */{
              _0: innerFn
            });
}

var comma = pchar(/* ',' */44);

var zeroOfMoreDigitList = sepBy(digit, comma);

var oneOrMoreDigitList = sepBy1(digit, comma);

var prim1$38 = run(oneOrMoreDigitList, "1;");

console.log("oneOrMoreDigitList 1", prim1$38);

var prim1$39 = run(oneOrMoreDigitList, "1,2;");

console.log("oneOrMoreDigitList 1,2", prim1$39);

var prim1$40 = run(oneOrMoreDigitList, "1,2,3;");

console.log("oneOrMoreDigitList 1,2,3", prim1$40);

var prim1$41 = run(oneOrMoreDigitList, "Z;");

console.log("oneOrMoreDigitList Z;", prim1$41);

var prim1$42 = run(zeroOfMoreDigitList, "1;");

console.log("zeroOfMoreDigitList 1", prim1$42);

var prim1$43 = run(zeroOfMoreDigitList, "1,2;");

console.log("zeroOfMoreDigitList 1,2", prim1$43);

var prim1$44 = run(zeroOfMoreDigitList, "1,2,3;");

console.log("zeroOfMoreDigitList 1,2,3", prim1$44);

var prim1$45 = run(zeroOfMoreDigitList, "Z;");

console.log("zeroOfMoreDigitList Z;", prim1$45);

console.log("");

console.log("-- What about bind?");

console.log("-- Reimplementing other combinators using bind");

function strToChar$1(__x) {
  return Caml_string.get(__x, 0);
}

function charToStr$1(__x) {
  return $$String.make(1, __x);
}

function compose(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function pchar$1(charToMatch) {
  var innerFn = function (str) {
    if (str.length === 0) {
      return {
              TAG: /* Failure */1,
              _0: "No more input"
            };
    }
    var first = Caml_string.get(str.charAt(0), 0);
    if (first === charToMatch) {
      var remaining = str.slice(1);
      return {
              TAG: /* Success */0,
              _0: [
                charToMatch,
                remaining
              ]
            };
    }
    var msg = "Expecting '" + $$String.make(1, charToMatch) + "'. Got '" + $$String.make(1, first) + "'";
    return {
            TAG: /* Failure */1,
            _0: msg
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function run$1(parser, input) {
  return Curry._1(parser._0, input);
}

function bindP(f, p) {
  var innerFn = function (input) {
    var result1 = run$1(p, input);
    if (result1.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: result1._0
            };
    }
    var match = result1._0;
    var p2 = Curry._1(f, match[0]);
    return run$1(p2, match[1]);
  };
  return /* Parser */{
          _0: innerFn
        };
}

function returnP$1(x) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              x,
              input
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function mapP$1(f, __x) {
  return bindP((function (param) {
                return returnP$1(Curry._1(f, param));
              }), __x);
}

function applyP$1(fP, xP) {
  return bindP((function (f) {
                return bindP((function (x) {
                              return returnP$1(Curry._1(f, x));
                            }), xP);
              }), fP);
}

function lift2$1(f, xP, yP) {
  return applyP$1(applyP$1(returnP$1(f), xP), yP);
}

function andThen$1(p1, p2) {
  return bindP((function (p1Result) {
                return bindP((function (p2Result) {
                              return returnP$1([
                                          p1Result,
                                          p2Result
                                        ]);
                            }), p2);
              }), p1);
}

function orElse$1(parser1, parser2) {
  var innerFn = function (input) {
    var result1 = run$1(parser1, input);
    if (result1.TAG === /* Success */0) {
      return result1;
    } else {
      return run$1(parser2, input);
    }
  };
  return /* Parser */{
          _0: innerFn
        };
}

function choice$1(listOfParsers) {
  return Belt_List.reduce(listOfParsers, /* Parser */{
              _0: (function (string) {
                  return {
                          TAG: /* Failure */1,
                          _0: "Initial parser"
                        };
                })
            }, orElse$1);
}

function anyOf(listOfChars) {
  return choice$1(Belt_List.map(listOfChars, pchar$1));
}

function sequence$1(parserList) {
  var cons = function (head, tail) {
    return {
            hd: head,
            tl: tail
          };
  };
  if (parserList) {
    return lift2$1(cons, parserList.hd, sequence$1(parserList.tl));
  }
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              /* [] */0,
              input
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function parseZeroOrMore$1(parser, input) {
  var firstResult = run$1(parser, input);
  if (firstResult.TAG !== /* Success */0) {
    return [
            /* [] */0,
            input
          ];
  }
  var match = firstResult._0;
  var match$1 = parseZeroOrMore$1(parser, match[1]);
  var values_0 = match[0];
  var values_1 = match$1[0];
  var values = {
    hd: values_0,
    tl: values_1
  };
  return [
          values,
          match$1[1]
        ];
}

function many$1(parser) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: parseZeroOrMore$1(parser, input)
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function many1$1(p) {
  return bindP((function (head) {
                var __x = many$1(p);
                return bindP((function (tail) {
                              return returnP$1({
                                          hd: head,
                                          tl: tail
                                        });
                            }), __x);
              }), p);
}

function opt$1(p) {
  var some = mapP$1((function (x) {
          return Caml_option.some(x);
        }), p);
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              undefined,
              input
            ]
          };
  };
  var none = /* Parser */{
    _0: innerFn
  };
  return orElse$1(some, none);
}

function keepLeft$1(p1, p2) {
  var __x = andThen$1(p1, p2);
  return mapP$1((function (param) {
                return param[0];
              }), __x);
}

function keepRight$1(p1, p2) {
  var __x = andThen$1(p1, p2);
  return mapP$1((function (param) {
                return param[1];
              }), __x);
}

function between$1(p1, p2, p3) {
  return keepLeft$1(keepRight$1(p1, p2), p3);
}

function sepBy1$1(p, sep) {
  var sepThenP = keepRight$1(sep, p);
  var __x = andThen$1(p, many$1(sepThenP));
  return mapP$1((function (param) {
                return {
                        hd: param[0],
                        tl: param[1]
                      };
              }), __x);
}

function sepBy$1(p, sep) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              /* [] */0,
              input
            ]
          };
  };
  return orElse$1(sepBy1$1(p, sep), /* Parser */{
              _0: innerFn
            });
}

export {
  log ,
  log2 ,
  parseDigit ,
  parseThreeDigits ,
  parseThreeDigitsAsStr$1 as parseThreeDigitsAsStr,
  parseThreeDigitsAsInt ,
  addP ,
  startsWith ,
  startWithP ,
  parsers ,
  combined ,
  charListToStr ,
  pstring ,
  parseABC ,
  manyA ,
  manyAB ,
  digit ,
  digits ,
  pint$1 as pint,
  digitThenSemicolon$1 as digitThenSemicolon,
  whitespaceChar$1 as whitespaceChar,
  whitespace$1 as whitespace,
  ab ,
  cd ,
  ab_cd ,
  pdoublequote ,
  quotedInterger ,
  comma ,
  zeroOfMoreDigitList ,
  oneOrMoreDigitList ,
  strToChar$1 as strToChar,
  charToStr$1 as charToStr,
  compose ,
  pchar$1 as pchar,
  run$1 as run,
  bindP ,
  returnP$1 as returnP,
  mapP$1 as mapP,
  applyP$1 as applyP,
  lift2$1 as lift2,
  andThen$1 as andThen,
  orElse$1 as orElse,
  choice$1 as choice,
  anyOf ,
  sequence$1 as sequence,
  parseZeroOrMore$1 as parseZeroOrMore,
  many$1 as many,
  many1$1 as many1,
  opt$1 as opt,
  keepLeft$1 as keepLeft,
  keepRight$1 as keepRight,
  between$1 as between,
  sepBy1$1 as sepBy1,
  sepBy$1 as sepBy,
}
/*  Not a pure module */
