// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_string from "rescript/lib/es6/caml_string.js";

function log(prim) {
  console.log(prim);
  
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
  
}

function strToChar(__x) {
  return Caml_string.get(__x, 0);
}

function charToStr(__x) {
  return $$String.make(1, __x);
}

function pchar(charToMatch) {
  var innerFn = function (str) {
    if (str.length === 0) {
      return {
              TAG: /* Failure */1,
              _0: "No more input"
            };
    }
    var first = Caml_string.get(str.charAt(0), 0);
    if (first === charToMatch) {
      var remaining = str.slice(1);
      return {
              TAG: /* Success */0,
              _0: [
                charToMatch,
                remaining
              ]
            };
    }
    var msg = "Expecting '" + $$String.make(1, charToMatch) + "'. Got '" + $$String.make(1, first) + "'";
    return {
            TAG: /* Failure */1,
            _0: msg
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function run(parser, input) {
  return Curry._1(parser._0, input);
}

function andThen(parser1, parser2) {
  var innerFn = function (input) {
    var result1 = run(parser1, input);
    if (result1.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: result1._0
            };
    }
    var match = result1._0;
    var result2 = run(parser2, match[1]);
    if (result2.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: result2._0
            };
    }
    var match$1 = result2._0;
    var newValue_0 = match[0];
    var newValue_1 = match$1[0];
    var newValue = [
      newValue_0,
      newValue_1
    ];
    return {
            TAG: /* Success */0,
            _0: [
              newValue,
              match$1[1]
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function orElse(parser1, parser2) {
  var innerFn = function (input) {
    var result1 = run(parser1, input);
    if (result1.TAG === /* Success */0) {
      return result1;
    } else {
      return run(parser2, input);
    }
  };
  return /* Parser */{
          _0: innerFn
        };
}

function choice(listOfParsers) {
  return Belt_List.reduce(listOfParsers, /* Parser */{
              _0: (function (string) {
                  return {
                          TAG: /* Failure */1,
                          _0: "Initial parser"
                        };
                })
            }, orElse);
}

function anyOf(listOfChars) {
  return choice(Belt_List.map(listOfChars, pchar));
}

console.log("Building a useful set of parser combinators");

console.log("-- 1. Transforming the contents of a parser with map");

var listOfChars = Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar));

var parseDigit = choice(Belt_List.map(listOfChars, pchar));

var parseThreeDigits = andThen(andThen(parseDigit, parseDigit), parseDigit);

var prim1 = run(parseThreeDigits, "123A");

console.log("parseThreeDigits 123A", prim1);

function mapP(f, parser) {
  var innerFn = function (input) {
    var result = run(parser, input);
    if (result.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: result._0
            };
    }
    var match = result._0;
    var newValue = Curry._1(f, match[0]);
    return {
            TAG: /* Success */0,
            _0: [
              newValue,
              match[1]
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function transformTuple(param) {
  var match = param[0];
  return $$String.make(1, match[0]) + $$String.make(1, match[1]) + $$String.make(1, param[1]);
}

var parseThreeDigitsAsStr = mapP(transformTuple, parseThreeDigits);

var prim1$1 = run(parseThreeDigitsAsStr, "123A");

console.log("parseThreeDigitsAsStr 123A", prim1$1);

var __x = andThen(andThen(parseDigit, parseDigit), parseDigit);

var parseThreeDigitsAsStr$1 = mapP((function (param) {
        var match = param[0];
        return $$String.make(1, match[0]) + $$String.make(1, match[1]) + $$String.make(1, param[1]);
      }), __x);

var prim1$2 = run(parseThreeDigitsAsStr$1, "123A");

console.log("parseThreeDigitsAsStr 123A", prim1$2);

var parseThreeDigitsAsInt = mapP((function (s) {
        return Belt_Option.getExn(Belt_Int.fromString(s));
      }), parseThreeDigitsAsStr$1);

var prim1$3 = run(parseThreeDigitsAsInt, "123A");

console.log("parseThreeDigitsAsInt 123A", prim1$3);

console.log("");

console.log("-- 2. Lifting functions to the world of Parsers");

function returnP(x) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              x,
              input
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

function applyP(fP, xP) {
  var __x = andThen(fP, xP);
  return mapP((function (param) {
                return Curry._1(param[0], param[1]);
              }), __x);
}

function lift2(f, xP, yP) {
  return applyP(applyP(returnP(f), xP), yP);
}

function addP(param, param$1) {
  return lift2((function (prim0, prim1) {
                return prim0 + prim1 | 0;
              }), param, param$1);
}

function startsWith(str, prefix) {
  return str.startsWith(prefix);
}

function startWithP(param, param$1) {
  return lift2(startsWith, param, param$1);
}

console.log("");

console.log("-- 3. Turning a list of Parsers into a single Parser");

function sequence(parserList) {
  var cons = function (head, tail) {
    return {
            hd: head,
            tl: tail
          };
  };
  if (parserList) {
    return lift2(cons, parserList.hd, sequence(parserList.tl));
  }
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              /* [] */0,
              input
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

var parsers_0 = pchar(/* 'A' */65);

var parsers_1 = {
  hd: pchar(/* 'B' */66),
  tl: {
    hd: pchar(/* 'C' */67),
    tl: /* [] */0
  }
};

var parsers = {
  hd: parsers_0,
  tl: parsers_1
};

var combined = sequence(parsers);

var prim1$4 = run(combined, "ABCD");

console.log("combined ABCD", prim1$4);

console.log("");

console.log("-- Implementing the pstring parser");

function charListToStr(charList) {
  return Belt_List.toArray(Belt_List.map(charList, charToStr)).join("");
}

function pstring(str) {
  return mapP(charListToStr, sequence(Belt_List.fromArray(Belt_Array.map(Belt_Array.map(str.split(""), strToChar), pchar))));
}

var parseABC = pstring("ABC");

var prim1$5 = run(parseABC, "ABCDE");

console.log("parseABC ABCDE", prim1$5);

var prim1$6 = run(parseABC, "A|CDE");

console.log("parseABC A|CDE", prim1$6);

var prim1$7 = run(parseABC, "AB|DE");

console.log("parseABC AB|DE", prim1$7);

console.log("");

console.log("-- 4. Matching a parser multiple times");

function parseZeroOrMore(parser, input) {
  var firstResult = run(parser, input);
  if (firstResult.TAG !== /* Success */0) {
    return [
            /* [] */0,
            input
          ];
  }
  var match = firstResult._0;
  var match$1 = parseZeroOrMore(parser, match[1]);
  var values_0 = match[0];
  var values_1 = match$1[0];
  var values = {
    hd: values_0,
    tl: values_1
  };
  return [
          values,
          match$1[1]
        ];
}

function many(parser) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: parseZeroOrMore(parser, input)
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

var manyA = many(pchar(/* 'A' */65));

var prim1$8 = run(manyA, "ABCD");

console.log("manyA ABCD", prim1$8);

var prim1$9 = run(manyA, "AACD");

console.log("manyA AACD", prim1$9);

var prim1$10 = run(manyA, "AAAD");

console.log("manyA AAAD", prim1$10);

var prim1$11 = run(manyA, "|BCD");

console.log("manyA |BCD", prim1$11);

var manyAB = many(pstring("AB"));

var prim1$12 = run(manyAB, "ABCD");

console.log("manyAB ABCD", prim1$12);

var prim1$13 = run(manyAB, "ABABCD");

console.log("manyAB ABABCD", prim1$13);

var prim1$14 = run(manyAB, "ZCD");

console.log("manyAB ZCD", prim1$14);

var prim1$15 = run(manyAB, "AZCD");

console.log("manyAB AZCD", prim1$15);

var whitespaceChar = choice(Belt_List.map({
          hd: /* ' ' */32,
          tl: {
            hd: /* '\t' */9,
            tl: {
              hd: /* '\n' */10,
              tl: /* [] */0
            }
          }
        }, pchar));

var whitespace = many(whitespaceChar);

var prim1$16 = run(whitespace, "ABC");

console.log("whitespace ABC", prim1$16);

var prim1$17 = run(whitespace, " ABC");

console.log("whitespace  ABC", prim1$17);

var prim1$18 = run(whitespace, " \tABC");

console.log("whitespace \tABC", prim1$18);

console.log("");

console.log("-- Defining many1");

function many1(parser) {
  var innerFn = function (input) {
    var firstResult = run(parser, input);
    if (firstResult.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: firstResult._0
            };
    }
    var match = firstResult._0;
    var match$1 = parseZeroOrMore(parser, match[1]);
    var values_0 = match[0];
    var values_1 = match$1[0];
    var values = {
      hd: values_0,
      tl: values_1
    };
    return {
            TAG: /* Success */0,
            _0: [
              values,
              match$1[1]
            ]
          };
  };
  return /* Parser */{
          _0: innerFn
        };
}

var listOfChars$1 = Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar));

var digit = choice(Belt_List.map(listOfChars$1, pchar));

var digits = many1(digit);

var prim1$19 = run(digits, "1ABC");

console.log("digits 1ABC", prim1$19);

var prim1$20 = run(digits, "12BC");

console.log("digits 12BC", prim1$20);

var prim1$21 = run(digits, "123C");

console.log("digits 123C", prim1$21);

var prim1$22 = run(digits, "1234");

console.log("digits 1234", prim1$22);

var prim1$23 = run(digits, "ABC");

console.log("digits ABC", prim1$23);

console.log("");

console.log("-- Parsing an integer");

function resultToInt(digitList) {
  return Belt_Option.getExn(Belt_Int.fromString(Belt_List.toArray(Belt_List.map(digitList, charToStr)).join("")));
}

var listOfChars$2 = Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar));

var digit$1 = choice(Belt_List.map(listOfChars$2, pchar));

var digits$1 = many1(digit$1);

var pint = mapP(resultToInt, digits$1);

var prim1$24 = run(pint, "1ABC");

console.log("pint 1ABC", prim1$24);

var prim1$25 = run(pint, "12BC");

console.log("pint 12BC", prim1$25);

var prim1$26 = run(pint, "123C");

console.log("pint 123C", prim1$26);

var prim1$27 = run(pint, "1234");

console.log("pint 1234", prim1$27);

var prim1$28 = run(pint, "ABC");

console.log("pint ABC", prim1$28);

console.log("-- 5. Matching a parser zero or one time");

function opt(p) {
  var some = mapP((function (x) {
          return Caml_option.some(x);
        }), p);
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              undefined,
              input
            ]
          };
  };
  var none = /* Parser */{
    _0: innerFn
  };
  return orElse(some, none);
}

var digitThenSemicolon = andThen(digit, opt(pchar(/* ';' */59)));

var prim1$29 = run(digitThenSemicolon, "1;");

console.log("digitThenSemicolon 1;", prim1$29);

var prim1$30 = run(digitThenSemicolon, "1");

console.log("digitThenSemicolon 1;", prim1$30);

function resultToInt$1(param) {
  var i = Belt_Option.getExn(Belt_Int.fromString(Belt_List.toArray(Belt_List.map(param[1], charToStr)).join("")));
  if (param[0] !== undefined) {
    return -i | 0;
  } else {
    return i;
  }
}

var listOfChars$3 = Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar));

var digit$2 = choice(Belt_List.map(listOfChars$3, pchar));

var digits$2 = many1(digit$2);

var pint$1 = mapP(resultToInt$1, andThen(opt(pchar(/* '-' */45)), digits$2));

var prim1$31 = run(pint$1, "123C");

console.log("pint 123C", prim1$31);

var prim1$32 = run(pint$1, "-123C");

console.log("pint 123C", prim1$32);

console.log("-- 6. Throwing results away");

export {
  log ,
  log2 ,
  strToChar ,
  charToStr ,
  pchar ,
  run ,
  andThen ,
  orElse ,
  choice ,
  anyOf ,
  parseDigit ,
  parseThreeDigits ,
  mapP ,
  parseThreeDigitsAsStr$1 as parseThreeDigitsAsStr,
  parseThreeDigitsAsInt ,
  returnP ,
  applyP ,
  lift2 ,
  addP ,
  startsWith ,
  startWithP ,
  sequence ,
  parsers ,
  combined ,
  charListToStr ,
  pstring ,
  parseABC ,
  parseZeroOrMore ,
  many ,
  manyA ,
  manyAB ,
  whitespaceChar ,
  whitespace ,
  many1 ,
  digit ,
  digits ,
  opt ,
  digitThenSemicolon ,
  pint$1 as pint,
  
}
/*  Not a pure module */
