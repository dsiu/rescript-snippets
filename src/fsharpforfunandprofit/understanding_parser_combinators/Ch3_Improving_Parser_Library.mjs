// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Char from "rescript/lib/es6/char.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_string from "rescript/lib/es6/caml_string.js";

function log(prim) {
  console.log(prim);
  
}

function log2(prim0, prim1) {
  console.log(prim0, prim1);
  
}

function strToChar(__x) {
  return Caml_string.get(__x, 0);
}

function charToStr(__x) {
  return $$String.make(1, __x);
}

function isDigit(c) {
  if (c >= /* '1' */49 && /* '9' */57 >= c) {
    return true;
  } else {
    return c === /* '0' */48;
  }
}

function isWhitespace(c) {
  return c === /* ' ' */32;
}

function charListToString(chars) {
  return Belt_List.reduce(Belt_List.map(chars, Char.escaped), "", (function (prim0, prim1) {
                return prim0.concat(prim1);
              }));
}

function compose(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function printResult(result) {
  if (result.TAG === /* Success */0) {
    console.log(result._0[0]);
    return ;
  }
  console.log("Error parsing " + result._0 + "\n" + result._1);
  
}

function getLabel(param) {
  return param.label;
}

function setLabel(param, newLabel) {
  var parseFn = param.parseFn;
  var newInnerFn = function (input) {
    var result = Curry._1(parseFn, input);
    if (result.TAG === /* Success */0) {
      return {
              TAG: /* Success */0,
              _0: result._0
            };
    } else {
      return {
              TAG: /* Failure */1,
              _0: newLabel,
              _1: result._1
            };
    }
  };
  return /* Parser */{
          parseFn: newInnerFn,
          label: newLabel
        };
}

function satisfy(predicate, label) {
  var innerFn = function (input) {
    if (input.length === 0) {
      return {
              TAG: /* Failure */1,
              _0: label,
              _1: "No more input"
            };
    }
    var first = Caml_string.get(input.charAt(0), 0);
    if (Curry._1(predicate, first)) {
      var remainingInput = input.slice(1);
      return {
              TAG: /* Success */0,
              _0: [
                first,
                remainingInput
              ]
            };
    }
    var err = "Unexpected " + $$String.make(1, first);
    return {
            TAG: /* Failure */1,
            _0: label,
            _1: err
          };
  };
  return /* Parser */{
          parseFn: innerFn,
          label: label
        };
}

function pchar(charToMatch) {
  var predicate = function (ch) {
    return ch === charToMatch;
  };
  var lablel = $$String.make(1, charToMatch);
  return satisfy(predicate, lablel);
}

function run(param, input) {
  return Curry._1(param.parseFn, input);
}

function bindP(f, p) {
  var innerFn = function (input) {
    var result1 = run(p, input);
    if (result1.TAG !== /* Success */0) {
      return {
              TAG: /* Failure */1,
              _0: result1._0,
              _1: result1._1
            };
    }
    var match = result1._0;
    var p2 = Curry._1(f, match[0]);
    return run(p2, match[1]);
  };
  return /* Parser */{
          parseFn: innerFn,
          label: "unknown"
        };
}

function returnP(x) {
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: [
              x,
              input
            ]
          };
  };
  return /* Parser */{
          parseFn: innerFn,
          label: ""
        };
}

function mapP(f, __x) {
  return bindP((function (param) {
                return returnP(Curry._1(f, param));
              }), __x);
}

function applyP(fP, xP) {
  return bindP((function (f) {
                return bindP((function (x) {
                              return returnP(Curry._1(f, x));
                            }), xP);
              }), fP);
}

function lift2(f, xP, yP) {
  return applyP(applyP(returnP(f), xP), yP);
}

function andThen(p1, p2) {
  var label = getLabel(p1) + " andThen " + getLabel(p2);
  return setLabel(bindP((function (p1Result) {
                    return bindP((function (p2Result) {
                                  return returnP([
                                              p1Result,
                                              p2Result
                                            ]);
                                }), p2);
                  }), p1), label);
}

function orElse(parser1, parser2) {
  var label = getLabel(parser1) + " orElse " + getLabel(parser2);
  var innerFn = function (input) {
    var result1 = run(parser1, input);
    if (result1.TAG === /* Success */0) {
      return result1;
    } else {
      return run(parser2, input);
    }
  };
  return /* Parser */{
          parseFn: innerFn,
          label: label
        };
}

function choice(listOfParsers) {
  return Belt_List.reduce(listOfParsers, /* Parser */{
              parseFn: (function (string) {
                  return {
                          TAG: /* Failure */1,
                          _0: "Initial parser",
                          _1: "Initial parser"
                        };
                }),
              label: "choice"
            }, orElse);
}

function anyOf(listOfChars) {
  var label = "any of " + charListToString(listOfChars);
  return setLabel(choice(Belt_List.map(listOfChars, pchar)), label);
}

function sequence(parserList) {
  var cons = function (head, tail) {
    return {
            hd: head,
            tl: tail
          };
  };
  if (parserList) {
    return lift2(cons, parserList.hd, sequence(parserList.tl));
  } else {
    return returnP(/* [] */0);
  }
}

function parseZeroOrMore(parser, input) {
  var firstResult = run(parser, input);
  if (firstResult.TAG !== /* Success */0) {
    return [
            /* [] */0,
            input
          ];
  }
  var match = firstResult._0;
  var match$1 = parseZeroOrMore(parser, match[1]);
  var values_0 = match[0];
  var values_1 = match$1[0];
  var values = {
    hd: values_0,
    tl: values_1
  };
  return [
          values,
          match$1[1]
        ];
}

function many(parser) {
  var label = "many " + getLabel(parser);
  var innerFn = function (input) {
    return {
            TAG: /* Success */0,
            _0: parseZeroOrMore(parser, input)
          };
  };
  return /* Parser */{
          parseFn: innerFn,
          label: label
        };
}

function many1(p) {
  return bindP((function (head) {
                var __x = many(p);
                return bindP((function (tail) {
                              return returnP({
                                          hd: head,
                                          tl: tail
                                        });
                            }), __x);
              }), p);
}

function opt(p) {
  var some = mapP((function (x) {
          return Caml_option.some(x);
        }), p);
  var none = returnP(undefined);
  return orElse(some, none);
}

function keepLeft(p1, p2) {
  var __x = andThen(p1, p2);
  return mapP((function (param) {
                return param[0];
              }), __x);
}

function keepRight(p1, p2) {
  var __x = andThen(p1, p2);
  return mapP((function (param) {
                return param[1];
              }), __x);
}

function between(p1, p2, p3) {
  return keepLeft(keepRight(p1, p2), p3);
}

function sepBy1(p, sep) {
  var sepThenP = keepRight(sep, p);
  var __x = andThen(p, many(sepThenP));
  return mapP((function (param) {
                return {
                        hd: param[0],
                        tl: param[1]
                      };
              }), __x);
}

function sepBy(p, sep) {
  return orElse(sepBy1(p, sep), returnP(/* [] */0));
}

console.log("-- Improving the parser library");

console.log("");

console.log("1. Labelling a Parser");

console.log("-- Updating the code");

console.log("-- Updating the label");

var digit = anyOf(Belt_List.fromArray(Belt_Array.map("0123456789".split(""), strToChar)));

var parseDigit_WithLabel = setLabel(digit, "digit");

printResult(run(parseDigit_WithLabel, "|ABC"));

console.log("-- 2. Replacing pchar with satisfy");

var digitChar = satisfy(isDigit, "digit");

var whitespaceChar = satisfy(isWhitespace, "whitespace");

console.log("-- 3. Adding position and context to error messages");

export {
  log ,
  log2 ,
  strToChar ,
  charToStr ,
  isDigit ,
  isWhitespace ,
  charListToString ,
  compose ,
  printResult ,
  getLabel ,
  setLabel ,
  satisfy ,
  pchar ,
  run ,
  bindP ,
  returnP ,
  mapP ,
  applyP ,
  lift2 ,
  andThen ,
  orElse ,
  choice ,
  anyOf ,
  sequence ,
  parseZeroOrMore ,
  many ,
  many1 ,
  opt ,
  keepLeft ,
  keepRight ,
  between ,
  sepBy1 ,
  sepBy ,
  digit ,
  parseDigit_WithLabel ,
  digitChar ,
  whitespaceChar ,
  
}
/*  Not a pure module */
