// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib__Function from "@dsiu/rescript-stdlib-fp/src/Stdlib__Function.mjs";

let contents = {
  hd: 1.0,
  tl: {
    hd: 2.0,
    tl: {
      hd: 3.0,
      tl: /* [] */0
    }
  }
};

console.log(contents);

function push(contents, x) {
  return {
    TAG: "StackContents",
    _0: {
      hd: x,
      tl: contents._0
    }
  };
}

let emptyStack = {
  TAG: "StackContents",
  _0: /* [] */0
};

let stackWith1 = push(emptyStack, 1.0);

let stackWith2 = push(stackWith1, 2.0);

console.log(stackWith1);

console.log(stackWith2);

function one(__x) {
  return push(__x, 1.0);
}

function two(__x) {
  return push(__x, 2.0);
}

function three(__x) {
  return push(__x, 3.0);
}

function four(__x) {
  return push(__x, 4.0);
}

function five(__x) {
  return push(__x, 5.0);
}

let empty = {
  TAG: "StackContents",
  _0: /* [] */0
};

let stackWith1$1 = push(empty, 1.0);

let stackWith2$1 = push(stackWith1$1, 2.0);

let stackWith3 = push(stackWith2$1, 3.0);

let result123 = push(push(push(empty, 1.0), 2.0), 3.0);

let result321 = push(push(push(empty, 3.0), 2.0), 1.0);

console.log(result123);

console.log(result321);

function pop(contents) {
  let contents$1 = contents._0;
  if (contents$1) {
    let newStack = {
      TAG: "StackContents",
      _0: contents$1.tl
    };
    return [
      contents$1.hd,
      newStack
    ];
  }
  throw {
    RE_EXN_ID: "Not_found",
    Error: new Error()
  };
}

let initialStack = push(push(empty, 1.0), 2.0);

let match = pop(initialStack);

let poppedStack = match[1];

let match$1 = pop(poppedStack);

function add_(stack) {
  let match = pop(stack);
  let match$1 = pop(match[1]);
  let result = match[0] + match$1[0];
  return push(match$1[1], result);
}

function mul_(stack) {
  let match = pop(stack);
  let match$1 = pop(match[1]);
  let result = match[0] * match$1[0];
  return push(match$1[1], result);
}

function binary(mathFn, stack) {
  let match = pop(stack);
  let match$1 = pop(match[1]);
  let z = mathFn(match$1[0], match[0]);
  return push(match$1[1], z);
}

function float_add(x, y) {
  return x + y;
}

function float_mul(x, y) {
  return x * y;
}

function float_sub(x, y) {
  return x - y;
}

function float_div(x, y) {
  return x / y;
}

function add(__x) {
  return binary(float_add, __x);
}

function mul(__x) {
  return binary(float_mul, __x);
}

function sub(__x) {
  return binary(float_sub, __x);
}

function div(__x) {
  return binary(float_div, __x);
}

console.log(binary(float_div, push(push(empty, 3.0), 2.0)), "threeDivTwo");

console.log(binary(float_sub, push(push(empty, 2.0), 5.0)), "twoSubtractFive");

console.log(binary(float_sub, push(binary(float_add, push(push(empty, 1.0), 2.0)), 3.0)), "oneAddTwoSubThree");

function unary(f, stack) {
  let match = pop(stack);
  return push(match[1], f(match[0]));
}

function neg(extra) {
  return unary(x => 0.0 - x, extra);
}

function square(extra) {
  return unary(x => x * x, extra);
}

console.log(neg(push(empty, 3.0)), "neg3");

console.log(square(push(empty, 2.0)), "square2");

function show(stack) {
  let match = pop(stack);
  console.log(match[0]);
  return stack;
}

function show2(stack, str) {
  let match = pop(stack);
  console.log(match[0], str);
  return stack;
}

let oneAddTwoSubThree = show2(binary(float_sub, push(binary(float_add, push(push(empty, 1.0), 2.0)), 3.0)), "oneAddTwoSubThree");

function dup(stack) {
  let match = pop(stack);
  return push(stack, match[0]);
}

function swap(stack) {
  let match = pop(stack);
  let match$1 = pop(match[1]);
  return push(push(match$1[1], match[0]), match$1[0]);
}

function drop(stack) {
  return pop(stack)[1];
}

show2(push(push(empty, 1.0), 2.0), "1,2");

show2(binary(float_add, push(show2(binary(float_add, push(push(empty, 1.0), 2.0)), "1+2"), 3.0)), "+3");

show2(binary(float_div, push(show2(binary(float_mul, push(show2(binary(float_add, push(push(empty, 1.0), 2.0)), "1+2"), 3.0)), "*3"), 2.0)), "/2");

function one_two_add(extra) {
  return Stdlib__Function.compose(extra => Stdlib__Function.compose(one, two, extra), add, extra);
}

function one_two_sub(extra) {
  return Stdlib__Function.compose(extra => Stdlib__Function.compose(one, two, extra), sub, extra);
}

show2(one_two_add(empty), "one_two_add");

show2(one_two_sub(empty), "one_two_sub");

function square$1(extra) {
  return Stdlib__Function.compose(dup, mul, extra);
}

show2(square$1(push(empty, 2.0)), "square");

function cube(extra) {
  return Stdlib__Function.compose(extra => Stdlib__Function.compose(extra => Stdlib__Function.compose(dup, dup, extra), mul, extra), mul, extra);
}

show2(cube(push(empty, 3.0)), "cube");

function sum_numbers_upto(extra) {
  return Stdlib__Function.compose(extra => Stdlib__Function.compose4(dup, one, add, mul, extra), extra => Stdlib__Function.compose(two, div, extra), extra);
}

show2(sum_numbers_upto(square$1(push(empty, 3.0))), "sum up to 9");

function composed_square(extra) {
  return Stdlib__Function.compose(dup, mul, extra);
}

let stackWith2$2 = push(empty, 2.0);

let twoSquared = binary(float_mul, dup(stackWith2$2));

function lambda_square(extra) {
  return unary(x => x * x, extra);
}

let newStack = {
  TAG: "StackContents",
  _0: {
    hd: 1.0,
    tl: {
      hd: 2.0,
      tl: {
        hd: 3.0,
        tl: /* [] */0
      }
    }
  }
};

let popped1 = match[0];

let popped2 = match$1[0];

let poppedStack2 = match$1[1];

let threeDivTwo;

let twoSubtractFive;

let neg3;

let square2;

let start = empty;

let compose = Stdlib__Function.compose;

let compose3 = Stdlib__Function.compose3;

let compose4 = Stdlib__Function.compose4;

export {
  newStack,
  contents,
  push,
  emptyStack,
  one,
  two,
  three,
  four,
  five,
  empty,
  stackWith1$1 as stackWith1,
  stackWith3,
  result123,
  result321,
  pop,
  initialStack,
  popped1,
  poppedStack,
  popped2,
  poppedStack2,
  add_,
  mul_,
  binary,
  float_add,
  float_mul,
  float_sub,
  float_div,
  add,
  mul,
  sub,
  div,
  threeDivTwo,
  twoSubtractFive,
  unary,
  neg,
  neg3,
  square2,
  show,
  show2,
  oneAddTwoSubThree,
  dup,
  swap,
  drop,
  start,
  one_two_add,
  one_two_sub,
  square$1 as square,
  cube,
  compose,
  compose3,
  compose4,
  sum_numbers_upto,
  composed_square,
  stackWith2$2 as stackWith2,
  twoSquared,
  lambda_square,
}
/*  Not a pure module */
